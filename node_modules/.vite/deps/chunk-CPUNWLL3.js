import {
  AbstractEngine,
  AbstractMesh,
  AbstractScene,
  Animation,
  AnimationRange,
  ArrayTools,
  Axis,
  BaseTexture,
  BindBonesParameters,
  BindFogParameters,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindTextureMatrix,
  BoundingInfo,
  Buffer,
  Camera,
  Color3,
  Color4,
  Coordinate,
  Decode,
  DeepCopier,
  DetailMapConfiguration,
  DumpTools,
  EffectFallbacks,
  Engine,
  EngineStore,
  Epsilon,
  EventConstants,
  Geometry,
  GetClass,
  GetExponentOfTwo,
  HandleFallbacksForShadows,
  ImageProcessingConfiguration,
  InternalTexture,
  InternalTextureSource,
  IsExponentOfTwo,
  KeyboardEventTypes,
  Light,
  LoadImage,
  Logger,
  Material,
  MaterialDefines,
  MaterialFlags,
  MaterialPluginBase,
  MaterialPluginEvent,
  Matrix,
  Mesh,
  Node,
  Observable,
  PointerEventTypes,
  PostProcess,
  PrePassConfiguration,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformsAndSamplersList,
  PushMaterial,
  Quaternion,
  RandomGUID,
  RegisterClass,
  RenderTargetTexture,
  Scalar,
  Scene,
  SerializationHelper,
  ShaderStore,
  SmartArray,
  Space,
  SubMesh,
  Texture,
  ThinEngine,
  TmpColors,
  TmpVectors,
  ToLinearSpace,
  Tools,
  TransformNode,
  Vector2,
  Vector3,
  Vector4,
  VertexBuffer,
  VertexData,
  _WarnImport,
  __decorate,
  addClipPlaneUniforms,
  bindClipPlane,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-33R7RJFH.js";

// node_modules/@babylonjs/core/Bones/bone.js
var Bone = class _Bone extends Node {
  /** @internal */
  get _matrix() {
    this._compose();
    return this._localMatrix;
  }
  /** @internal */
  set _matrix(value) {
    if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {
      return;
    }
    this._needToCompose = false;
    this._localMatrix.copyFrom(value);
    this._markAsDirtyAndDecompose();
  }
  /**
   * Create a new bone
   * @param name defines the bone name
   * @param skeleton defines the parent skeleton
   * @param parentBone defines the parent (can be null if the bone is the root)
   * @param localMatrix defines the local matrix (default: identity)
   * @param restMatrix defines the rest matrix (default: localMatrix)
   * @param bindMatrix defines the bind matrix (default: localMatrix)
   * @param index defines index of the bone in the hierarchy (default: null)
   */
  constructor(name50, skeleton, parentBone = null, localMatrix = null, restMatrix = null, bindMatrix = null, index = null) {
    super(name50, skeleton.getScene(), false);
    this.name = name50;
    this.children = [];
    this.animations = [];
    this._index = null;
    this._scalingDeterminant = 1;
    this._needToDecompose = true;
    this._needToCompose = false;
    this._linkedTransformNode = null;
    this._waitingTransformNodeId = null;
    this._skeleton = skeleton;
    this._localMatrix = (localMatrix == null ? void 0 : localMatrix.clone()) ?? Matrix.Identity();
    this._restMatrix = restMatrix ?? this._localMatrix.clone();
    this._bindMatrix = bindMatrix ?? this._localMatrix.clone();
    this._index = index;
    this._absoluteMatrix = new Matrix();
    this._absoluteBindMatrix = new Matrix();
    this._absoluteInverseBindMatrix = new Matrix();
    this._finalMatrix = new Matrix();
    skeleton.bones.push(this);
    this.setParent(parentBone, false);
    this._updateAbsoluteBindMatrices();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "Bone";
  }
  // Members
  /**
   * Gets the parent skeleton
   * @returns a skeleton
   */
  getSkeleton() {
    return this._skeleton;
  }
  get parent() {
    return this._parentNode;
  }
  /**
   * Gets parent bone
   * @returns a bone or null if the bone is the root of the bone hierarchy
   */
  getParent() {
    return this.parent;
  }
  /**
   * Returns an array containing the children of the bone
   * @returns an array containing the children of the bone (can be empty if the bone has no children)
   */
  getChildren() {
    return this.children;
  }
  /**
   * Gets the node index in matrix array generated for rendering
   * @returns the node index
   */
  getIndex() {
    return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;
  }
  set parent(newParent) {
    this.setParent(newParent);
  }
  /**
   * Sets the parent bone
   * @param parent defines the parent (can be null if the bone is the root)
   * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be updated
   */
  setParent(parent, updateAbsoluteBindMatrices = true) {
    if (this.parent === parent) {
      return;
    }
    if (this.parent) {
      const index = this.parent.children.indexOf(this);
      if (index !== -1) {
        this.parent.children.splice(index, 1);
      }
    }
    this._parentNode = parent;
    if (this.parent) {
      this.parent.children.push(this);
    }
    if (updateAbsoluteBindMatrices) {
      this._updateAbsoluteBindMatrices();
    }
    this.markAsDirty();
  }
  /**
   * Gets the local matrix
   * @returns the local matrix
   */
  getLocalMatrix() {
    this._compose();
    return this._localMatrix;
  }
  /**
   * Gets the bind matrix
   * @returns the bind matrix
   */
  getBindMatrix() {
    return this._bindMatrix;
  }
  /**
   * Gets the bind matrix.
   * @returns the bind matrix
   * @deprecated Please use getBindMatrix instead
   */
  getBaseMatrix() {
    return this.getBindMatrix();
  }
  /**
   * Gets the rest matrix
   * @returns the rest matrix
   */
  getRestMatrix() {
    return this._restMatrix;
  }
  /**
   * Gets the rest matrix
   * @returns the rest matrix
   * @deprecated Please use getRestMatrix instead
   */
  getRestPose() {
    return this.getRestMatrix();
  }
  /**
   * Sets the rest matrix
   * @param matrix the local-space rest matrix to set for this bone
   */
  setRestMatrix(matrix) {
    this._restMatrix.copyFrom(matrix);
  }
  /**
   * Sets the rest matrix
   * @param matrix the local-space rest to set for this bone
   * @deprecated Please use setRestMatrix instead
   */
  setRestPose(matrix) {
    this.setRestMatrix(matrix);
  }
  /**
   * Gets the bind matrix
   * @returns the bind matrix
   * @deprecated Please use getBindMatrix instead
   */
  getBindPose() {
    return this.getBindMatrix();
  }
  /**
   * Sets the bind matrix
   * This will trigger a recomputation of the absolute bind and absolute inverse bind matrices for this bone and its children
   * Note that the local matrix will also be set with the matrix passed in parameter!
   * @param matrix the local-space bind matrix to set for this bone
   */
  setBindMatrix(matrix) {
    this.updateMatrix(matrix);
  }
  /**
   * Sets the bind matrix
   * @param matrix the local-space bind to set for this bone
   * @deprecated Please use setBindMatrix instead
   */
  setBindPose(matrix) {
    this.setBindMatrix(matrix);
  }
  /**
   * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)
   * @returns the final world matrix
   */
  getFinalMatrix() {
    return this._finalMatrix;
  }
  /**
   * Gets the matrix used to store the final world transformation of the bone (ie. the matrix sent to shaders)
   * @deprecated Please use getFinalMatrix instead
   * @returns the final world matrix
   */
  getWorldMatrix() {
    return this.getFinalMatrix();
  }
  /**
   * Sets the local matrix to the rest matrix
   */
  returnToRest() {
    if (this._linkedTransformNode) {
      const localScaling = TmpVectors.Vector3[0];
      const localRotation = TmpVectors.Quaternion[0];
      const localPosition = TmpVectors.Vector3[1];
      this.getRestMatrix().decompose(localScaling, localRotation, localPosition);
      this._linkedTransformNode.position.copyFrom(localPosition);
      this._linkedTransformNode.rotationQuaternion = this._linkedTransformNode.rotationQuaternion ?? Quaternion.Identity();
      this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);
      this._linkedTransformNode.scaling.copyFrom(localScaling);
    } else {
      this._matrix = this._restMatrix;
    }
  }
  /**
   * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)
   * @returns the inverse bind matrix, in world space
   */
  getAbsoluteInverseBindMatrix() {
    return this._absoluteInverseBindMatrix;
  }
  /**
   * Gets the inverse of the bind matrix, in world space (relative to the skeleton root)
   * @returns the inverse bind matrix, in world space
   * @deprecated Please use getAbsoluteInverseBindMatrix instead
   */
  getInvertedAbsoluteTransform() {
    return this.getAbsoluteInverseBindMatrix();
  }
  /**
   * Gets the bone matrix, in world space (relative to the skeleton root)
   * @returns the bone matrix, in world space
   */
  getAbsoluteMatrix() {
    return this._absoluteMatrix;
  }
  /**
   * Gets the bone matrix, in world space (relative to the skeleton root)
   * @returns the bone matrix, in world space
   * @deprecated Please use getAbsoluteMatrix instead
   */
  getAbsoluteTransform() {
    return this._absoluteMatrix;
  }
  /**
   * Links with the given transform node.
   * The local matrix of this bone is overwritten by the transform of the node every frame.
   * @param transformNode defines the transform node to link to
   */
  linkTransformNode(transformNode) {
    if (this._linkedTransformNode) {
      this._skeleton._numBonesWithLinkedTransformNode--;
    }
    this._linkedTransformNode = transformNode;
    if (this._linkedTransformNode) {
      this._skeleton._numBonesWithLinkedTransformNode++;
    }
  }
  // Properties (matches TransformNode properties)
  /**
   * Gets the node used to drive the bone's transformation
   * @returns a transform node or null
   */
  getTransformNode() {
    return this._linkedTransformNode;
  }
  /** Gets or sets current position (in local space) */
  get position() {
    this._decompose();
    return this._localPosition;
  }
  set position(newPosition) {
    this._decompose();
    this._localPosition.copyFrom(newPosition);
    this._markAsDirtyAndCompose();
  }
  /** Gets or sets current rotation (in local space) */
  get rotation() {
    return this.getRotation();
  }
  set rotation(newRotation) {
    this.setRotation(newRotation);
  }
  /** Gets or sets current rotation quaternion (in local space) */
  get rotationQuaternion() {
    this._decompose();
    return this._localRotation;
  }
  set rotationQuaternion(newRotation) {
    this.setRotationQuaternion(newRotation);
  }
  /** Gets or sets current scaling (in local space) */
  get scaling() {
    return this.getScale();
  }
  set scaling(newScaling) {
    this.setScale(newScaling);
  }
  /**
   * Gets the animation properties override
   */
  get animationPropertiesOverride() {
    return this._skeleton.animationPropertiesOverride;
  }
  // Methods
  _decompose() {
    if (!this._needToDecompose) {
      return;
    }
    this._needToDecompose = false;
    if (!this._localScaling) {
      this._localScaling = Vector3.Zero();
      this._localRotation = Quaternion.Zero();
      this._localPosition = Vector3.Zero();
    }
    this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);
  }
  _compose() {
    if (!this._needToCompose) {
      return;
    }
    if (!this._localScaling) {
      this._needToCompose = false;
      return;
    }
    this._needToCompose = false;
    Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);
  }
  /**
   * Update the bind (and optionally the local) matrix
   * @param bindMatrix defines the new matrix to set to the bind/local matrix, in local space
   * @param updateAbsoluteBindMatrices defines if the absolute bind and absolute inverse bind matrices must be recomputed (default: true)
   * @param updateLocalMatrix defines if the local matrix should also be updated with the matrix passed in parameter (default: true)
   */
  updateMatrix(bindMatrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true) {
    this._bindMatrix.copyFrom(bindMatrix);
    if (updateAbsoluteBindMatrices) {
      this._updateAbsoluteBindMatrices();
    }
    if (updateLocalMatrix) {
      this._matrix = bindMatrix;
    } else {
      this.markAsDirty();
    }
  }
  /**
   * @internal
   */
  _updateAbsoluteBindMatrices(bindMatrix, updateChildren = true) {
    if (!bindMatrix) {
      bindMatrix = this._bindMatrix;
    }
    if (this.parent) {
      bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);
    } else {
      this._absoluteBindMatrix.copyFrom(bindMatrix);
    }
    this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);
    if (updateChildren) {
      for (let index = 0; index < this.children.length; index++) {
        this.children[index]._updateAbsoluteBindMatrices();
      }
    }
    this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;
  }
  /**
   * Flag the bone as dirty (Forcing it to update everything)
   * @returns this bone
   */
  markAsDirty() {
    this._currentRenderId++;
    this._childUpdateId++;
    this._skeleton._markAsDirty();
    return this;
  }
  /** @internal */
  _markAsDirtyAndCompose() {
    this.markAsDirty();
    this._needToCompose = true;
  }
  _markAsDirtyAndDecompose() {
    this.markAsDirty();
    this._needToDecompose = true;
  }
  _updatePosition(vec, space = Space.LOCAL, tNode, translationMode = true) {
    const lm = this.getLocalMatrix();
    if (space == Space.LOCAL) {
      if (translationMode) {
        lm.addAtIndex(12, vec.x);
        lm.addAtIndex(13, vec.y);
        lm.addAtIndex(14, vec.z);
      } else {
        lm.setTranslationFromFloats(vec.x, vec.y, vec.z);
      }
    } else {
      let wm = null;
      if (tNode) {
        wm = tNode.getWorldMatrix();
      }
      this._skeleton.computeAbsoluteMatrices();
      const tmat = _Bone._TmpMats[0];
      const tvec = _Bone._TmpVecs[0];
      if (this.parent) {
        if (tNode && wm) {
          tmat.copyFrom(this.parent.getAbsoluteMatrix());
          tmat.multiplyToRef(wm, tmat);
        } else {
          tmat.copyFrom(this.parent.getAbsoluteMatrix());
        }
      } else {
        Matrix.IdentityToRef(tmat);
      }
      if (translationMode) {
        tmat.setTranslationFromFloats(0, 0, 0);
      }
      tmat.invert();
      Vector3.TransformCoordinatesToRef(vec, tmat, tvec);
      if (translationMode) {
        lm.addAtIndex(12, tvec.x);
        lm.addAtIndex(13, tvec.y);
        lm.addAtIndex(14, tvec.z);
      } else {
        lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);
      }
    }
    this._markAsDirtyAndDecompose();
  }
  /**
   * Translate the bone in local or world space
   * @param vec The amount to translate the bone
   * @param space The space that the translation is in (default: Space.LOCAL)
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  translate(vec, space = Space.LOCAL, tNode) {
    this._updatePosition(vec, space, tNode, true);
  }
  /**
   * Set the position of the bone in local or world space
   * @param position The position to set the bone
   * @param space The space that the position is in (default: Space.LOCAL)
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setPosition(position, space = Space.LOCAL, tNode) {
    this._updatePosition(position, space, tNode, false);
  }
  /**
   * Set the absolute position of the bone (world space)
   * @param position The position to set the bone
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setAbsolutePosition(position, tNode) {
    this.setPosition(position, Space.WORLD, tNode);
  }
  /**
   * Scale the bone on the x, y and z axes (in local space)
   * @param x The amount to scale the bone on the x axis
   * @param y The amount to scale the bone on the y axis
   * @param z The amount to scale the bone on the z axis
   * @param scaleChildren sets this to true if children of the bone should be scaled as well (false by default)
   */
  scale(x, y, z, scaleChildren = false) {
    const locMat = this.getLocalMatrix();
    const scaleMat = _Bone._TmpMats[0];
    Matrix.ScalingToRef(x, y, z, scaleMat);
    scaleMat.multiplyToRef(locMat, locMat);
    scaleMat.invert();
    for (const child of this.children) {
      const cm = child.getLocalMatrix();
      cm.multiplyToRef(scaleMat, cm);
      cm.multiplyAtIndex(12, x);
      cm.multiplyAtIndex(13, y);
      cm.multiplyAtIndex(14, z);
      child._markAsDirtyAndDecompose();
    }
    this._markAsDirtyAndDecompose();
    if (scaleChildren) {
      for (const child of this.children) {
        child.scale(x, y, z, scaleChildren);
      }
    }
  }
  /**
   * Set the bone scaling in local space
   * @param scale defines the scaling vector
   */
  setScale(scale) {
    this._decompose();
    this._localScaling.copyFrom(scale);
    this._markAsDirtyAndCompose();
  }
  /**
   * Gets the current scaling in local space
   * @returns the current scaling vector
   */
  getScale() {
    this._decompose();
    return this._localScaling;
  }
  /**
   * Gets the current scaling in local space and stores it in a target vector
   * @param result defines the target vector
   */
  getScaleToRef(result) {
    this._decompose();
    result.copyFrom(this._localScaling);
  }
  /**
   * Set the yaw, pitch, and roll of the bone in local or world space
   * @param yaw The rotation of the bone on the y axis
   * @param pitch The rotation of the bone on the x axis
   * @param roll The rotation of the bone on the z axis
   * @param space The space that the axes of rotation are in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setYawPitchRoll(yaw, pitch, roll, space = Space.LOCAL, tNode) {
    if (space === Space.LOCAL) {
      const quat = _Bone._TmpQuat;
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);
      this.setRotationQuaternion(quat, space, tNode);
      return;
    }
    const rotMatInv = _Bone._TmpMats[0];
    if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
      return;
    }
    const rotMat = _Bone._TmpMats[1];
    Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, tNode);
  }
  /**
   * Add a rotation to the bone on an axis in local or world space
   * @param axis The axis to rotate the bone on
   * @param amount The amount to rotate the bone
   * @param space The space that the axis is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  rotate(axis, amount, space = Space.LOCAL, tNode) {
    const rmat = _Bone._TmpMats[0];
    rmat.setTranslationFromFloats(0, 0, 0);
    Matrix.RotationAxisToRef(axis, amount, rmat);
    this._rotateWithMatrix(rmat, space, tNode);
  }
  /**
   * Set the rotation of the bone to a particular axis angle in local or world space
   * @param axis The axis to rotate the bone on
   * @param angle The angle that the bone should be rotated to
   * @param space The space that the axis is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setAxisAngle(axis, angle, space = Space.LOCAL, tNode) {
    if (space === Space.LOCAL) {
      const quat = _Bone._TmpQuat;
      Quaternion.RotationAxisToRef(axis, angle, quat);
      this.setRotationQuaternion(quat, space, tNode);
      return;
    }
    const rotMatInv = _Bone._TmpMats[0];
    if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
      return;
    }
    const rotMat = _Bone._TmpMats[1];
    Matrix.RotationAxisToRef(axis, angle, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, tNode);
  }
  /**
   * Set the euler rotation of the bone in local or world space
   * @param rotation The euler rotation that the bone should be set to
   * @param space The space that the rotation is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setRotation(rotation, space = Space.LOCAL, tNode) {
    this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);
  }
  /**
   * Set the quaternion rotation of the bone in local or world space
   * @param quat The quaternion rotation that the bone should be set to
   * @param space The space that the rotation is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setRotationQuaternion(quat, space = Space.LOCAL, tNode) {
    if (space === Space.LOCAL) {
      this._decompose();
      this._localRotation.copyFrom(quat);
      this._markAsDirtyAndCompose();
      return;
    }
    const rotMatInv = _Bone._TmpMats[0];
    if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
      return;
    }
    const rotMat = _Bone._TmpMats[1];
    Matrix.FromQuaternionToRef(quat, rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat);
    this._rotateWithMatrix(rotMat, space, tNode);
  }
  /**
   * Set the rotation matrix of the bone in local or world space
   * @param rotMat The rotation matrix that the bone should be set to
   * @param space The space that the rotation is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   */
  setRotationMatrix(rotMat, space = Space.LOCAL, tNode) {
    if (space === Space.LOCAL) {
      const quat = _Bone._TmpQuat;
      Quaternion.FromRotationMatrixToRef(rotMat, quat);
      this.setRotationQuaternion(quat, space, tNode);
      return;
    }
    const rotMatInv = _Bone._TmpMats[0];
    if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
      return;
    }
    const rotMat2 = _Bone._TmpMats[1];
    rotMat2.copyFrom(rotMat);
    rotMatInv.multiplyToRef(rotMat, rotMat2);
    this._rotateWithMatrix(rotMat2, space, tNode);
  }
  _rotateWithMatrix(rmat, space = Space.LOCAL, tNode) {
    const lmat = this.getLocalMatrix();
    const lx = lmat.m[12];
    const ly = lmat.m[13];
    const lz = lmat.m[14];
    const parent = this.getParent();
    const parentScale = _Bone._TmpMats[3];
    const parentScaleInv = _Bone._TmpMats[4];
    if (parent && space == Space.WORLD) {
      if (tNode) {
        parentScale.copyFrom(tNode.getWorldMatrix());
        parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);
      } else {
        parentScale.copyFrom(parent.getAbsoluteMatrix());
      }
      parentScaleInv.copyFrom(parentScale);
      parentScaleInv.invert();
      lmat.multiplyToRef(parentScale, lmat);
      lmat.multiplyToRef(rmat, lmat);
      lmat.multiplyToRef(parentScaleInv, lmat);
    } else {
      if (space == Space.WORLD && tNode) {
        parentScale.copyFrom(tNode.getWorldMatrix());
        parentScaleInv.copyFrom(parentScale);
        parentScaleInv.invert();
        lmat.multiplyToRef(parentScale, lmat);
        lmat.multiplyToRef(rmat, lmat);
        lmat.multiplyToRef(parentScaleInv, lmat);
      } else {
        lmat.multiplyToRef(rmat, lmat);
      }
    }
    lmat.setTranslationFromFloats(lx, ly, lz);
    this.computeAbsoluteMatrices();
    this._markAsDirtyAndDecompose();
  }
  _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode) {
    const scaleMatrix = _Bone._TmpMats[2];
    rotMatInv.copyFrom(this.getAbsoluteMatrix());
    if (tNode) {
      rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);
      Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);
    } else {
      Matrix.IdentityToRef(scaleMatrix);
    }
    rotMatInv.invert();
    if (isNaN(rotMatInv.m[0])) {
      return false;
    }
    scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);
    rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);
    return true;
  }
  /**
   * Get the position of the bone in local or world space
   * @param space The space that the returned position is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The position of the bone
   */
  getPosition(space = Space.LOCAL, tNode = null) {
    const pos = Vector3.Zero();
    this.getPositionToRef(space, tNode, pos);
    return pos;
  }
  /**
   * Copy the position of the bone to a vector3 in local or world space
   * @param space The space that the returned position is in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 to copy the position to
   */
  getPositionToRef(space = Space.LOCAL, tNode, result) {
    if (space == Space.LOCAL) {
      const lm = this.getLocalMatrix();
      result.x = lm.m[12];
      result.y = lm.m[13];
      result.z = lm.m[14];
    } else {
      let wm = null;
      if (tNode) {
        wm = tNode.getWorldMatrix();
      }
      this._skeleton.computeAbsoluteMatrices();
      let tmat = _Bone._TmpMats[0];
      if (tNode && wm) {
        tmat.copyFrom(this.getAbsoluteMatrix());
        tmat.multiplyToRef(wm, tmat);
      } else {
        tmat = this.getAbsoluteMatrix();
      }
      result.x = tmat.m[12];
      result.y = tmat.m[13];
      result.z = tmat.m[14];
    }
  }
  /**
   * Get the absolute position of the bone (world space)
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The absolute position of the bone
   */
  getAbsolutePosition(tNode = null) {
    const pos = Vector3.Zero();
    this.getPositionToRef(Space.WORLD, tNode, pos);
    return pos;
  }
  /**
   * Copy the absolute position of the bone (world space) to the result param
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 to copy the absolute position to
   */
  getAbsolutePositionToRef(tNode, result) {
    this.getPositionToRef(Space.WORLD, tNode, result);
  }
  /**
   * Compute the absolute matrices of this bone and its children
   */
  computeAbsoluteMatrices() {
    this._compose();
    if (this.parent) {
      this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);
    } else {
      this._absoluteMatrix.copyFrom(this._localMatrix);
      const poseMatrix = this._skeleton.getPoseMatrix();
      if (poseMatrix) {
        this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);
      }
    }
    const children = this.children;
    const len = children.length;
    for (let i = 0; i < len; i++) {
      children[i].computeAbsoluteMatrices();
    }
  }
  /**
   * Compute the absolute matrices of this bone and its children
   * @deprecated Please use computeAbsoluteMatrices instead
   */
  computeAbsoluteTransforms() {
    this.computeAbsoluteMatrices();
  }
  /**
   * Get the world direction from an axis that is in the local space of the bone
   * @param localAxis The local direction that is used to compute the world direction
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The world direction
   */
  getDirection(localAxis, tNode = null) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, tNode, result);
    return result;
  }
  /**
   * Copy the world direction to a vector3 from an axis that is in the local space of the bone
   * @param localAxis The local direction that is used to compute the world direction
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 that the world direction will be copied to
   */
  getDirectionToRef(localAxis, tNode = null, result) {
    let wm = null;
    if (tNode) {
      wm = tNode.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteMatrices();
    const mat = _Bone._TmpMats[0];
    mat.copyFrom(this.getAbsoluteMatrix());
    if (tNode && wm) {
      mat.multiplyToRef(wm, mat);
    }
    Vector3.TransformNormalToRef(localAxis, mat, result);
    result.normalize();
  }
  /**
   * Get the euler rotation of the bone in local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The euler rotation
   */
  getRotation(space = Space.LOCAL, tNode = null) {
    const result = Vector3.Zero();
    this.getRotationToRef(space, tNode, result);
    return result;
  }
  /**
   * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 that the rotation should be copied to
   */
  getRotationToRef(space = Space.LOCAL, tNode = null, result) {
    const quat = _Bone._TmpQuat;
    this.getRotationQuaternionToRef(space, tNode, quat);
    quat.toEulerAnglesToRef(result);
  }
  /**
   * Get the quaternion rotation of the bone in either local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The quaternion rotation
   */
  getRotationQuaternion(space = Space.LOCAL, tNode = null) {
    const result = Quaternion.Identity();
    this.getRotationQuaternionToRef(space, tNode, result);
    return result;
  }
  /**
   * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The quaternion that the rotation should be copied to
   */
  getRotationQuaternionToRef(space = Space.LOCAL, tNode = null, result) {
    if (space == Space.LOCAL) {
      this._decompose();
      result.copyFrom(this._localRotation);
    } else {
      const mat = _Bone._TmpMats[0];
      const amat = this.getAbsoluteMatrix();
      if (tNode) {
        amat.multiplyToRef(tNode.getWorldMatrix(), mat);
      } else {
        mat.copyFrom(amat);
      }
      mat.multiplyAtIndex(0, this._scalingDeterminant);
      mat.multiplyAtIndex(1, this._scalingDeterminant);
      mat.multiplyAtIndex(2, this._scalingDeterminant);
      mat.decompose(void 0, result, void 0);
    }
  }
  /**
   * Get the rotation matrix of the bone in local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The rotation matrix
   */
  getRotationMatrix(space = Space.LOCAL, tNode) {
    const result = Matrix.Identity();
    this.getRotationMatrixToRef(space, tNode, result);
    return result;
  }
  /**
   * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space
   * @param space The space that the rotation should be in
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The quaternion that the rotation should be copied to
   */
  getRotationMatrixToRef(space = Space.LOCAL, tNode, result) {
    if (space == Space.LOCAL) {
      this.getLocalMatrix().getRotationMatrixToRef(result);
    } else {
      const mat = _Bone._TmpMats[0];
      const amat = this.getAbsoluteMatrix();
      if (tNode) {
        amat.multiplyToRef(tNode.getWorldMatrix(), mat);
      } else {
        mat.copyFrom(amat);
      }
      mat.multiplyAtIndex(0, this._scalingDeterminant);
      mat.multiplyAtIndex(1, this._scalingDeterminant);
      mat.multiplyAtIndex(2, this._scalingDeterminant);
      mat.getRotationMatrixToRef(result);
    }
  }
  /**
   * Get the world position of a point that is in the local space of the bone
   * @param position The local position
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The world position
   */
  getAbsolutePositionFromLocal(position, tNode = null) {
    const result = Vector3.Zero();
    this.getAbsolutePositionFromLocalToRef(position, tNode, result);
    return result;
  }
  /**
   * Get the world position of a point that is in the local space of the bone and copy it to the result param
   * @param position The local position
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 that the world position should be copied to
   */
  getAbsolutePositionFromLocalToRef(position, tNode = null, result) {
    let wm = null;
    if (tNode) {
      wm = tNode.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteMatrices();
    const tmat = _Bone._TmpMats[0];
    tmat.copyFrom(this.getAbsoluteMatrix());
    if (tNode && wm) {
      tmat.multiplyToRef(wm, tmat);
    }
    Vector3.TransformCoordinatesToRef(position, tmat, result);
  }
  /**
   * Get the local position of a point that is in world space
   * @param position The world position
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @returns The local position
   */
  getLocalPositionFromAbsolute(position, tNode = null) {
    const result = Vector3.Zero();
    this.getLocalPositionFromAbsoluteToRef(position, tNode, result);
    return result;
  }
  /**
   * Get the local position of a point that is in world space and copy it to the result param
   * @param position The world position
   * @param tNode A TransformNode whose world matrix is to be applied to the calculated absolute matrix. In most cases, you'll want to pass the mesh associated with the skeleton from which this bone comes. Used only when space=Space.WORLD
   * @param result The vector3 that the local position should be copied to
   */
  getLocalPositionFromAbsoluteToRef(position, tNode = null, result) {
    let wm = null;
    if (tNode) {
      wm = tNode.getWorldMatrix();
    }
    this._skeleton.computeAbsoluteMatrices();
    const tmat = _Bone._TmpMats[0];
    tmat.copyFrom(this.getAbsoluteMatrix());
    if (tNode && wm) {
      tmat.multiplyToRef(wm, tmat);
    }
    tmat.invert();
    Vector3.TransformCoordinatesToRef(position, tmat, result);
  }
  /**
   * Set the current local matrix as the restMatrix for this bone.
   */
  setCurrentPoseAsRest() {
    this.setRestMatrix(this.getLocalMatrix());
  }
};
Bone._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);
Bone._TmpQuat = Quaternion.Identity();
Bone._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);

// node_modules/@babylonjs/core/Animations/animationEvent.js
var AnimationEvent = class _AnimationEvent {
  /**
   * Initializes the animation event
   * @param frame The frame for which the event is triggered
   * @param action The event to perform when triggered
   * @param onlyOnce Specifies if the event should be triggered only once
   */
  constructor(frame, action, onlyOnce) {
    this.frame = frame;
    this.action = action;
    this.onlyOnce = onlyOnce;
    this.isDone = false;
  }
  /** @internal */
  _clone() {
    return new _AnimationEvent(this.frame, this.action, this.onlyOnce);
  }
};

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
Mesh._instancedMeshFactory = (name50, mesh) => {
  const instance = new InstancedMesh(name50, mesh);
  if (mesh.instancedBuffers) {
    instance.instancedBuffers = {};
    for (const key in mesh.instancedBuffers) {
      instance.instancedBuffers[key] = mesh.instancedBuffers[key];
    }
  }
  return instance;
};
var InstancedMesh = class extends AbstractMesh {
  /**
   * Creates a new InstancedMesh object from the mesh source.
   * @param name defines the name of the instance
   * @param source the mesh to create the instance from
   */
  constructor(name50, source) {
    super(name50, source.getScene());
    this._indexInSourceMeshInstanceArray = -1;
    this._distanceToCamera = 0;
    source.addInstance(this);
    this._sourceMesh = source;
    this._unIndexed = source._unIndexed;
    this.position.copyFrom(source.position);
    this.rotation.copyFrom(source.rotation);
    this.scaling.copyFrom(source.scaling);
    if (source.rotationQuaternion) {
      this.rotationQuaternion = source.rotationQuaternion.clone();
    }
    this.animations = source.animations.slice();
    for (const range of source.getAnimationRanges()) {
      if (range != null) {
        this.createAnimationRange(range.name, range.from, range.to);
      }
    }
    this.infiniteDistance = source.infiniteDistance;
    this.setPivotMatrix(source.getPivotMatrix());
    this.refreshBoundingInfo(true, true);
    this._syncSubMeshes();
  }
  /**
   * @returns the string "InstancedMesh".
   */
  getClassName() {
    return "InstancedMesh";
  }
  /** Gets the list of lights affecting that mesh */
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  // Methods
  /**
   * If the source mesh receives shadows
   */
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  set receiveShadows(_value) {
    var _a;
    if (((_a = this._sourceMesh) == null ? void 0 : _a.receiveShadows) !== _value) {
      Tools.Warn("Setting receiveShadows on an instanced mesh has no effect");
    }
  }
  /**
   * The material of the source mesh
   */
  get material() {
    return this._sourceMesh.material;
  }
  set material(_value) {
    var _a;
    if (((_a = this._sourceMesh) == null ? void 0 : _a.material) !== _value) {
      Tools.Warn("Setting material on an instanced mesh has no effect");
    }
  }
  /**
   * Visibility of the source mesh
   */
  get visibility() {
    return this._sourceMesh.visibility;
  }
  set visibility(_value) {
    var _a;
    if (((_a = this._sourceMesh) == null ? void 0 : _a.visibility) !== _value) {
      Tools.Warn("Setting visibility on an instanced mesh has no effect");
    }
  }
  /**
   * Skeleton of the source mesh
   */
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  set skeleton(_value) {
    var _a;
    if (((_a = this._sourceMesh) == null ? void 0 : _a.skeleton) !== _value) {
      Tools.Warn("Setting skeleton on an instanced mesh has no effect");
    }
  }
  /**
   * Rendering ground id of the source mesh
   */
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(value) {
    if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
      return;
    }
    Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  /**
   * @returns the total number of vertices (integer).
   */
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  /**
   * Returns a positive integer : the total number of indices in this mesh geometry.
   * @returns the number of indices or zero if the mesh has no geometry.
   */
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  /**
   * The source mesh of the instance
   */
  get sourceMesh() {
    return this._sourceMesh;
  }
  /**
   * Creates a new InstancedMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedMesh
   */
  createInstance(name50) {
    return this._sourceMesh.createInstance(name50);
  }
  /**
   * Is this node ready to be used/rendered
   * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
   * @returns {boolean} is it ready
   */
  isReady(completeCheck = false) {
    return this._sourceMesh.isReady(completeCheck, true);
  }
  /**
   * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
   * @param kind kind of verticies to retrieve (eg. positions, normals, uvs, etc.)
   * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
   * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is
   * @returns a float array or a Float32Array of the requested kind of data : positions, normals, uvs, etc.
   */
  getVerticesData(kind, copyWhenShared, forceCopy) {
    return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
  }
  /**
   * Sets the vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
   * The `data` are either a numeric array either a Float32Array.
   * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initially none) or updater.
   * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
   * Note that a new underlying VertexBuffer object is created each call.
   * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind defines vertex data kind
   * @param data defines the data source
   * @param updatable defines if the data must be flagged as updatable (false as default)
   * @param stride defines the vertex stride (optional)
   * @returns the current mesh
   */
  setVerticesData(kind, data, updatable, stride) {
    if (this.sourceMesh) {
      this.sourceMesh.setVerticesData(kind, data, updatable, stride);
    }
    return this.sourceMesh;
  }
  /**
   * Updates the existing vertex data of the mesh geometry for the requested `kind`.
   * If the mesh has no geometry, it is simply returned as it is.
   * The `data` are either a numeric array either a Float32Array.
   * No new underlying VertexBuffer object is created.
   * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
   * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
   *
   * Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   *
   * Returns the Mesh.
   * @param kind defines vertex data kind
   * @param data defines the data source
   * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for "position" kind
   * @param makeItUnique defines it the updated vertex buffer must be flagged as unique (false by default)
   * @returns the source mesh
   */
  updateVerticesData(kind, data, updateExtends, makeItUnique) {
    if (this.sourceMesh) {
      this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
    }
    return this.sourceMesh;
  }
  /**
   * Sets the mesh indices.
   * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
   * If the mesh has no geometry, a new Geometry object is created and set to the mesh.
   * This method creates a new index buffer each call.
   * Returns the Mesh.
   * @param indices the source data
   * @param totalVertices defines the total number of vertices referenced by indices (could be null)
   * @returns source mesh
   */
  setIndices(indices, totalVertices = null) {
    if (this.sourceMesh) {
      this.sourceMesh.setIndices(indices, totalVertices);
    }
    return this.sourceMesh;
  }
  /**
   * Boolean : True if the mesh owns the requested kind of data.
   * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :
   * - VertexBuffer.PositionKind
   * - VertexBuffer.UVKind
   * - VertexBuffer.UV2Kind
   * - VertexBuffer.UV3Kind
   * - VertexBuffer.UV4Kind
   * - VertexBuffer.UV5Kind
   * - VertexBuffer.UV6Kind
   * - VertexBuffer.ColorKind
   * - VertexBuffer.MatricesIndicesKind
   * - VertexBuffer.MatricesIndicesExtraKind
   * - VertexBuffer.MatricesWeightsKind
   * - VertexBuffer.MatricesWeightsExtraKind
   * @returns true if data kind is present
   */
  isVerticesDataPresent(kind) {
    return this._sourceMesh.isVerticesDataPresent(kind);
  }
  /**
   * @returns an array of indices (IndicesArray).
   */
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  /**
   * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
   * This means the mesh underlying bounding box and sphere are recomputed.
   * @param applySkeleton defines whether to apply the skeleton before computing the bounding info
   * @param applyMorph  defines whether to apply the morph target before computing the bounding info
   * @returns the current mesh
   */
  refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  }
  /** @internal */
  _preActivate() {
    if (this._currentLOD) {
      this._currentLOD._preActivate();
    }
    return this;
  }
  /**
   * @internal
   */
  _activate(renderId, intermediateRendering) {
    super._activate(renderId, intermediateRendering);
    if (!this._sourceMesh.subMeshes) {
      Logger.Warn("Instances should only be created for meshes with geometry.");
    }
    if (this._currentLOD) {
      const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
      if (differentSign) {
        this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
        return true;
      }
      this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
      this._currentLOD._registerInstanceForRenderId(this, renderId);
      if (intermediateRendering) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
          return true;
        }
      } else {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
          this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
          return true;
        }
      }
    }
    return false;
  }
  /** @internal */
  _postActivate() {
    if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
      this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
    } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
      this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
    }
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      if (!this._billboardWorldMatrix) {
        this._billboardWorldMatrix = new Matrix();
      }
      const tempMaster = this._currentLOD._masterMesh;
      this._currentLOD._masterMesh = this;
      TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
      this._currentLOD.position.set(0, 0, 0);
      this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
      this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
      this._currentLOD._masterMesh = tempMaster;
      return this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return true;
  }
  /**
   * Returns the current associated LOD AbstractMesh.
   * @param camera defines the camera to use to pick the LOD level
   * @returns a Mesh or `null` if no LOD is associated with the AbstractMesh
   */
  getLOD(camera) {
    if (!camera) {
      return this;
    }
    const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
    if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
      this._currentLOD = this.sourceMesh;
    } else {
      const boundingInfo = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
    }
    return this._currentLOD;
  }
  /**
   * @internal
   */
  _preActivateForIntermediateRendering(renderId) {
    return this.sourceMesh._preActivateForIntermediateRendering(renderId);
  }
  /** @internal */
  _syncSubMeshes() {
    this.releaseSubMeshes();
    if (this._sourceMesh.subMeshes) {
      for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
        this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
      }
    }
    return this;
  }
  /** @internal */
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  /** @internal */
  _updateBoundingInfo() {
    if (this.hasBoundingInfo) {
      this.getBoundingInfo().update(this.worldMatrixFromCache);
    } else {
      this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  }
  /**
   * Creates a new InstancedMesh from the current mesh.
   *
   * Returns the clone.
   * @param name the cloned mesh name
   * @param newParent the optional Node to parent the clone to.
   * @param doNotCloneChildren if `true` the model children aren't cloned.
   * @param newSourceMesh if set this mesh will be used as the source mesh instead of ths instance's one
   * @returns the clone
   */
  clone(name50, newParent = null, doNotCloneChildren, newSourceMesh) {
    const result = (newSourceMesh || this._sourceMesh).createInstance(name50);
    DeepCopier.DeepCopy(this, result, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []);
    this.refreshBoundingInfo();
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      for (let index = 0; index < this.getScene().meshes.length; index++) {
        const mesh = this.getScene().meshes[index];
        if (mesh.parent === this) {
          mesh.clone(mesh.name, result);
        }
      }
    }
    result.computeWorldMatrix(true);
    this.onClonedObservable.notifyObservers(result);
    return result;
  }
  /**
   * Disposes the InstancedMesh.
   * Returns nothing.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._sourceMesh.removeInstance(this);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * @internal
   */
  _serializeAsParent(serializationObject) {
    super._serializeAsParent(serializationObject);
    serializationObject.parentId = this._sourceMesh.uniqueId;
    serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  /**
   * Instantiate (when possible) or clone that node with its hierarchy
   * @param newParent defines the new parent to use for the instance (or clone)
   * @param options defines options to configure how copy is done
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param options.newSourcedMesh newSourcedMesh the new source mesh for the instance (or clone)
   * @param onNewNodeCreated defines an option callback to call when a clone or an instance is created
   * @returns an instance (or a clone) of the current node with its hierarchy
   */
  instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
    const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (const child of this.getChildTransformNodes(true)) {
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  }
};
Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
  var _a, _b;
  (_b = (_a = this._userInstancedBuffersStorage) == null ? void 0 : _a.vertexBuffers[kind]) == null ? void 0 : _b.dispose();
  if (!this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const instance of this.instances) {
      instance.instancedBuffers = {};
    }
  }
  if (!this._userInstancedBuffersStorage) {
    this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    };
  }
  this.instancedBuffers[kind] = null;
  this._userInstancedBuffersStorage.strides[kind] = stride;
  this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
  this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
  this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
  for (const instance of this.instances) {
    instance.instancedBuffers[kind] = null;
  }
  this._invalidateInstanceVertexArrayObject();
  this._markSubMeshesAsAttributesDirty();
};
Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  const instanceCount = visibleInstances ? visibleInstances.length : 0;
  for (const kind in this.instancedBuffers) {
    let size = this._userInstancedBuffersStorage.sizes[kind];
    const stride = this._userInstancedBuffersStorage.strides[kind];
    const expectedSize = (instanceCount + 1) * stride;
    while (size < expectedSize) {
      size *= 2;
    }
    if (this._userInstancedBuffersStorage.data[kind].length != size) {
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
      this._userInstancedBuffersStorage.sizes[kind] = size;
      if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
        this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
      }
    }
    const data = this._userInstancedBuffersStorage.data[kind];
    let offset = 0;
    if (renderSelf) {
      const value = this.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
      const instance = visibleInstances[instanceIndex];
      const value = instance.instancedBuffers[kind];
      if (value.toArray) {
        value.toArray(data, offset);
      } else if (value.copyToArray) {
        value.copyToArray(data, offset);
      } else {
        data[offset] = value;
      }
      offset += stride;
    }
    if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      this._invalidateInstanceVertexArrayObject();
    } else {
      this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
    }
  }
};
Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
    return;
  }
  for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
  }
  this._userInstancedBuffersStorage.vertexArrayObjects = {};
};
Mesh.prototype._disposeInstanceSpecificData = function() {
  if (this._instanceDataStorage.instancesBuffer) {
    this._instanceDataStorage.instancesBuffer.dispose();
    this._instanceDataStorage.instancesBuffer = null;
  }
  while (this.instances.length) {
    this.instances[0].dispose();
  }
  for (const kind in this.instancedBuffers) {
    if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
      this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
    }
  }
  this._invalidateInstanceVertexArrayObject();
  this.instancedBuffers = {};
};
RegisterClass("BABYLON.InstancedMesh", InstancedMesh);

// node_modules/@babylonjs/core/assetContainer.js
var KeepAssets = class extends AbstractScene {
};
var InstantiatedEntries = class {
  constructor() {
    this.rootNodes = [];
    this.skeletons = [];
    this.animationGroups = [];
  }
  /**
   * Disposes the instantiated entries from the scene
   */
  dispose() {
    this.rootNodes.slice(0).forEach((o) => {
      o.dispose();
    });
    this.rootNodes.length = 0;
    this.skeletons.slice(0).forEach((o) => {
      o.dispose();
    });
    this.skeletons.length = 0;
    this.animationGroups.slice(0).forEach((o) => {
      o.dispose();
    });
    this.animationGroups.length = 0;
  }
};
var AssetContainer = class extends AbstractScene {
  /**
   * Instantiates an AssetContainer.
   * @param scene The scene the AssetContainer belongs to.
   */
  constructor(scene) {
    super();
    this._wasAddedToScene = false;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scene = scene;
    this["sounds"] = [];
    this["effectLayers"] = [];
    this["layers"] = [];
    this["lensFlareSystems"] = [];
    this["proceduralTextures"] = [];
    this["reflectionProbes"] = [];
    scene.onDisposeObservable.add(() => {
      if (!this._wasAddedToScene) {
        this.dispose();
      }
    });
    this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {
      for (const geometry of this.geometries) {
        geometry._rebuild();
      }
      for (const mesh of this.meshes) {
        mesh._rebuild();
      }
      for (const system of this.particleSystems) {
        system.rebuild();
      }
      for (const texture of this.textures) {
        texture._rebuild();
      }
    });
  }
  /**
   * Given a list of nodes, return a topological sorting of them.
   * @param nodes
   * @returns a sorted array of nodes
   */
  _topologicalSort(nodes) {
    const nodesUidMap = /* @__PURE__ */ new Map();
    for (const node of nodes) {
      nodesUidMap.set(node.uniqueId, node);
    }
    const dependencyGraph = {
      dependsOn: /* @__PURE__ */ new Map(),
      dependedBy: /* @__PURE__ */ new Map()
      // given a node id, what are the ids of the nodes that depend on it
    };
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      dependencyGraph.dependsOn.set(nodeId, /* @__PURE__ */ new Set());
      dependencyGraph.dependedBy.set(nodeId, /* @__PURE__ */ new Set());
    }
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      const dependsOn = dependencyGraph.dependsOn.get(nodeId);
      if (node instanceof InstancedMesh) {
        const masterMesh = node.sourceMesh;
        if (nodesUidMap.has(masterMesh.uniqueId)) {
          dependsOn.add(masterMesh.uniqueId);
          dependencyGraph.dependedBy.get(masterMesh.uniqueId).add(nodeId);
        }
      }
      const dependedBy = dependencyGraph.dependedBy.get(nodeId);
      for (const child of node.getDescendants()) {
        const childId = child.uniqueId;
        if (nodesUidMap.has(childId)) {
          dependedBy.add(childId);
          const childDependsOn = dependencyGraph.dependsOn.get(childId);
          childDependsOn.add(nodeId);
        }
      }
    }
    const sortedNodes = [];
    const leaves = [];
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      if (dependencyGraph.dependsOn.get(nodeId).size === 0) {
        leaves.push(node);
        nodesUidMap.delete(nodeId);
      }
    }
    const visitList = leaves;
    while (visitList.length > 0) {
      const nodeToVisit = visitList.shift();
      sortedNodes.push(nodeToVisit);
      const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId);
      for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {
        const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId);
        dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);
        if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {
          visitList.push(nodesUidMap.get(dependedByVisitedNodeId));
          nodesUidMap.delete(dependedByVisitedNodeId);
        }
      }
    }
    if (nodesUidMap.size > 0) {
      Logger.Error("SceneSerializer._topologicalSort: There were unvisited nodes:");
      nodesUidMap.forEach((node) => Logger.Error(node.name));
    }
    return sortedNodes;
  }
  _addNodeAndDescendantsToList(list, addedIds, rootNode, predicate) {
    if (!rootNode || predicate && !predicate(rootNode) || addedIds.has(rootNode.uniqueId)) {
      return;
    }
    list.push(rootNode);
    addedIds.add(rootNode.uniqueId);
    for (const child of rootNode.getDescendants(true)) {
      this._addNodeAndDescendantsToList(list, addedIds, child, predicate);
    }
  }
  /**
   * Check if a specific node is contained in this asset container.
   * @param node the node to check
   * @returns true if the node is contained in this container, otherwise false.
   */
  _isNodeInContainer(node) {
    if (node instanceof AbstractMesh && this.meshes.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof Light && this.lights.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {
      return true;
    }
    return false;
  }
  /**
   * For every node in the scene, check if its parent node is also in the scene.
   * @returns true if every node's parent is also in the scene, otherwise false.
   */
  _isValidHierarchy() {
    for (const node of this.meshes) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.transformNodes) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.lights) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.cameras) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    return true;
  }
  /**
   * Instantiate or clone all meshes and add the new ones to the scene.
   * Skeletons and animation groups will all be cloned
   * @param nameFunction defines an optional function used to get new names for clones
   * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
   * @param options defines an optional list of options to control how to instantiate / clone models
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone
   * @returns a list of rootNodes, skeletons and animation groups that were duplicated
   */
  instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
    }
    const conversionMap = {};
    const storeMap = {};
    const result = new InstantiatedEntries();
    const alreadySwappedSkeletons = [];
    const alreadySwappedMaterials = [];
    const localOptions = {
      doNotInstantiate: true,
      ...options
    };
    const onClone = (source, clone) => {
      conversionMap[source.uniqueId] = clone.uniqueId;
      storeMap[clone.uniqueId] = clone;
      if (nameFunction) {
        clone.name = nameFunction(source.name);
      }
      if (clone instanceof Mesh) {
        const clonedMesh = clone;
        if (clonedMesh.morphTargetManager) {
          const oldMorphTargetManager = source.morphTargetManager;
          clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
          for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {
            const oldTarget = oldMorphTargetManager.getTarget(index);
            const newTarget = clonedMesh.morphTargetManager.getTarget(index);
            conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;
            storeMap[newTarget.uniqueId] = newTarget;
          }
        }
      }
    };
    const nodesToSort = [];
    const idsOnSortList = /* @__PURE__ */ new Set();
    for (const transformNode of this.transformNodes) {
      if (transformNode.parent === null) {
        this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);
      }
    }
    for (const mesh of this.meshes) {
      if (mesh.parent === null) {
        this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);
      }
    }
    const sortedNodes = this._topologicalSort(nodesToSort);
    const onNewCreated = (source, clone) => {
      onClone(source, clone);
      if (source.parent) {
        const replicatedParentId = conversionMap[source.parent.uniqueId];
        const replicatedParent = storeMap[replicatedParentId];
        if (replicatedParent) {
          clone.parent = replicatedParent;
        } else {
          clone.parent = source.parent;
        }
      }
      if (clone.position && source.position) {
        clone.position.copyFrom(source.position);
      }
      if (clone.rotationQuaternion && source.rotationQuaternion) {
        clone.rotationQuaternion.copyFrom(source.rotationQuaternion);
      }
      if (clone.rotation && source.rotation) {
        clone.rotation.copyFrom(source.rotation);
      }
      if (clone.scaling && source.scaling) {
        clone.scaling.copyFrom(source.scaling);
      }
      if (clone.material) {
        const mesh = clone;
        if (mesh.material) {
          if (cloneMaterials) {
            const sourceMaterial = source.material;
            if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
              let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
              alreadySwappedMaterials.push(sourceMaterial);
              conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;
              storeMap[swap.uniqueId] = swap;
              if (sourceMaterial.getClassName() === "MultiMaterial") {
                const multi = sourceMaterial;
                for (const material of multi.subMaterials) {
                  if (!material) {
                    continue;
                  }
                  swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                  alreadySwappedMaterials.push(material);
                  conversionMap[material.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                }
                multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);
              }
            }
            if (mesh.getClassName() !== "InstancedMesh") {
              mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];
            }
          } else {
            if (mesh.material.getClassName() === "MultiMaterial") {
              if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                this.scene.addMultiMaterial(mesh.material);
              }
            } else {
              if (this.scene.materials.indexOf(mesh.material) === -1) {
                this.scene.addMaterial(mesh.material);
              }
            }
          }
        }
      }
      if (clone.parent === null) {
        result.rootNodes.push(clone);
      }
    };
    sortedNodes.forEach((node) => {
      if (node.getClassName() === "InstancedMesh") {
        const instancedNode = node;
        const sourceMesh = instancedNode.sourceMesh;
        const replicatedSourceId = conversionMap[sourceMesh.uniqueId];
        const replicatedSource = typeof replicatedSourceId === "number" ? storeMap[replicatedSourceId] : sourceMesh;
        const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);
        onNewCreated(instancedNode, replicatedInstancedNode);
      } else {
        let canInstance = true;
        if (node.getClassName() === "TransformNode" || node.getClassName() === "Node" || node.skeleton || !node.getTotalVertices || node.getTotalVertices() === 0) {
          canInstance = false;
        } else if (localOptions.doNotInstantiate) {
          if (typeof localOptions.doNotInstantiate === "function") {
            canInstance = !localOptions.doNotInstantiate(node);
          } else {
            canInstance = !localOptions.doNotInstantiate;
          }
        }
        const replicatedNode = canInstance ? node.createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);
        if (!replicatedNode) {
          throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);
        }
        onNewCreated(node, replicatedNode);
      }
    });
    this.skeletons.forEach((s) => {
      if (localOptions.predicate && !localOptions.predicate(s)) {
        return;
      }
      const clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
      for (const m of this.meshes) {
        if (m.skeleton === s && !m.isAnInstance) {
          const copy = storeMap[conversionMap[m.uniqueId]];
          if (!copy || copy.isAnInstance) {
            continue;
          }
          copy.skeleton = clone;
          if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
            continue;
          }
          alreadySwappedSkeletons.push(clone);
          for (const bone of clone.bones) {
            if (bone._linkedTransformNode) {
              bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];
            }
          }
        }
      }
      result.skeletons.push(clone);
    });
    this.animationGroups.forEach((o) => {
      if (localOptions.predicate && !localOptions.predicate(o)) {
        return;
      }
      const clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, (oldTarget) => {
        const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];
        return newTarget || oldTarget;
      });
      result.animationGroups.push(clone);
    });
    return result;
  }
  /**
   * Adds all the assets from the container to the scene.
   */
  addAllToScene() {
    if (this._wasAddedToScene) {
      return;
    }
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.");
    }
    this._wasAddedToScene = true;
    this.addToScene(null);
    if (this.environmentTexture) {
      this.scene.environmentTexture = this.environmentTexture;
    }
    for (const component of this.scene._serializableComponents) {
      component.addFromContainer(this);
    }
    this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
    this._onContextRestoredObserver = null;
  }
  /**
   * Adds assets from the container to the scene.
   * @param predicate defines a predicate used to select which entity will be added (can be null)
   */
  addToScene(predicate = null) {
    const addedNodes = [];
    this.cameras.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addCamera(o);
      addedNodes.push(o);
    });
    this.lights.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addLight(o);
      addedNodes.push(o);
    });
    this.meshes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addMesh(o);
      addedNodes.push(o);
    });
    this.skeletons.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addSkeleton(o);
    });
    this.animations.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addAnimation(o);
    });
    this.animationGroups.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addAnimationGroup(o);
    });
    this.multiMaterials.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addMultiMaterial(o);
    });
    this.materials.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addMaterial(o);
    });
    this.morphTargetManagers.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addMorphTargetManager(o);
    });
    this.geometries.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addGeometry(o);
    });
    this.transformNodes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addTransformNode(o);
      addedNodes.push(o);
    });
    this.actionManagers.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addActionManager(o);
    });
    this.textures.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addTexture(o);
    });
    this.reflectionProbes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.addReflectionProbe(o);
    });
    for (const addedNode of addedNodes) {
      if (addedNode.parent && this.scene.getNodes().indexOf(addedNode.parent) === -1) {
        if (addedNode.setParent) {
          addedNode.setParent(null);
        } else {
          addedNode.parent = null;
        }
      }
    }
  }
  /**
   * Removes all the assets in the container from the scene
   */
  removeAllFromScene() {
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.");
    }
    this._wasAddedToScene = false;
    this.removeFromScene(null);
    if (this.environmentTexture === this.scene.environmentTexture) {
      this.scene.environmentTexture = null;
    }
    for (const component of this.scene._serializableComponents) {
      component.removeFromContainer(this);
    }
  }
  /**
   * Removes assets in the container from the scene
   * @param predicate defines a predicate used to select which entity will be added (can be null)
   */
  removeFromScene(predicate = null) {
    this.cameras.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeCamera(o);
    });
    this.lights.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeLight(o);
    });
    this.meshes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeMesh(o, true);
    });
    this.skeletons.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeSkeleton(o);
    });
    this.animations.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeAnimation(o);
    });
    this.animationGroups.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeAnimationGroup(o);
    });
    this.multiMaterials.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeMultiMaterial(o);
    });
    this.materials.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeMaterial(o);
    });
    this.morphTargetManagers.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeMorphTargetManager(o);
    });
    this.geometries.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeGeometry(o);
    });
    this.transformNodes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeTransformNode(o);
    });
    this.actionManagers.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeActionManager(o);
    });
    this.textures.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeTexture(o);
    });
    this.reflectionProbes.forEach((o) => {
      if (predicate && !predicate(o)) {
        return;
      }
      this.scene.removeReflectionProbe(o);
    });
  }
  /**
   * Disposes all the assets in the container
   */
  dispose() {
    this.cameras.slice(0).forEach((o) => {
      o.dispose();
    });
    this.cameras.length = 0;
    this.lights.slice(0).forEach((o) => {
      o.dispose();
    });
    this.lights.length = 0;
    this.meshes.slice(0).forEach((o) => {
      o.dispose();
    });
    this.meshes.length = 0;
    this.skeletons.slice(0).forEach((o) => {
      o.dispose();
    });
    this.skeletons.length = 0;
    this.animationGroups.slice(0).forEach((o) => {
      o.dispose();
    });
    this.animationGroups.length = 0;
    this.multiMaterials.slice(0).forEach((o) => {
      o.dispose();
    });
    this.multiMaterials.length = 0;
    this.materials.slice(0).forEach((o) => {
      o.dispose();
    });
    this.materials.length = 0;
    this.geometries.slice(0).forEach((o) => {
      o.dispose();
    });
    this.geometries.length = 0;
    this.transformNodes.slice(0).forEach((o) => {
      o.dispose();
    });
    this.transformNodes.length = 0;
    this.actionManagers.slice(0).forEach((o) => {
      o.dispose();
    });
    this.actionManagers.length = 0;
    this.textures.slice(0).forEach((o) => {
      o.dispose();
    });
    this.textures.length = 0;
    this.reflectionProbes.slice(0).forEach((o) => {
      o.dispose();
    });
    this.reflectionProbes.length = 0;
    this.morphTargetManagers.slice(0).forEach((o) => {
      o.dispose();
    });
    this.morphTargetManagers.length = 0;
    if (this.environmentTexture) {
      this.environmentTexture.dispose();
      this.environmentTexture = null;
    }
    for (const component of this.scene._serializableComponents) {
      component.removeFromContainer(this, true);
    }
    if (this._onContextRestoredObserver) {
      this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
  _moveAssets(sourceAssets, targetAssets, keepAssets) {
    if (!sourceAssets || !targetAssets) {
      return;
    }
    for (const asset of sourceAssets) {
      let move = true;
      if (keepAssets) {
        for (const keepAsset of keepAssets) {
          if (asset === keepAsset) {
            move = false;
            break;
          }
        }
      }
      if (move) {
        targetAssets.push(asset);
        asset._parentContainer = this;
      }
    }
  }
  /**
   * Removes all the assets contained in the scene and adds them to the container.
   * @param keepAssets Set of assets to keep in the scene. (default: empty)
   */
  moveAllFromScene(keepAssets) {
    this._wasAddedToScene = false;
    if (keepAssets === void 0) {
      keepAssets = new KeepAssets();
    }
    for (const key in this) {
      if (Object.prototype.hasOwnProperty.call(this, key)) {
        this[key] = this[key] || (key === "_environmentTexture" ? null : []);
        this._moveAssets(this.scene[key], this[key], keepAssets[key]);
      }
    }
    this.environmentTexture = this.scene.environmentTexture;
    this.removeAllFromScene();
  }
  /**
   * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
   * @returns the root mesh
   */
  createRootMesh() {
    const rootMesh = new Mesh("assetContainerRootMesh", this.scene);
    this.meshes.forEach((m) => {
      if (!m.parent) {
        rootMesh.addChild(m);
      }
    });
    this.meshes.unshift(rootMesh);
    return rootMesh;
  }
  /**
   * Merge animations (direct and animation groups) from this asset container into a scene
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param animatables set of animatables to retarget to a node from the scene
   * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
   * @returns an array of the new AnimationGroup added to the scene (empty array if none)
   */
  mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {
    if (!scene) {
      Logger.Error("No scene available to merge animations to");
      return [];
    }
    const _targetConverter = targetConverter ? targetConverter : (target) => {
      let node = null;
      const targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
      const name50 = target.name.split(".").join("").split("_primitive")[0];
      switch (targetProperty) {
        case "position":
        case "rotationQuaternion":
          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name50);
          break;
        case "influence":
          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name50);
          break;
        default:
          node = scene.getNodeByName(target.name) || scene.getNodeByName(name50);
      }
      return node;
    };
    const nodesInAC = this.getNodes();
    nodesInAC.forEach((nodeInAC) => {
      const nodeInScene = _targetConverter(nodeInAC);
      if (nodeInScene !== null) {
        for (const animationInAC of nodeInAC.animations) {
          const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {
            return animationInScene.targetProperty === animationInAC.targetProperty;
          });
          for (const animationWithSameProperty of animationsWithSameProperty) {
            const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
            if (index > -1) {
              nodeInScene.animations.splice(index, 1);
            }
          }
        }
        nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
      }
    });
    const newAnimationGroups = [];
    this.animationGroups.slice().forEach((animationGroupInAC) => {
      newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
      animationGroupInAC.animatables.forEach((animatable) => {
        animatable.stop();
      });
    });
    animatables.forEach((animatable) => {
      const target = _targetConverter(animatable.target);
      if (target) {
        scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
        scene.stopAnimation(animatable.target);
      }
    });
    return newAnimationGroups;
  }
  /**
   * @since 6.15.0
   * This method checks for any node that has no parent
   * and is not in the rootNodes array, and adds the node
   * there, if so.
   */
  populateRootNodes() {
    this.rootNodes.length = 0;
    this.meshes.forEach((m) => {
      if (!m.parent && this.rootNodes.indexOf(m) === -1) {
        this.rootNodes.push(m);
      }
    });
    this.transformNodes.forEach((t) => {
      if (!t.parent && this.rootNodes.indexOf(t) === -1) {
        this.rootNodes.push(t);
      }
    });
    this.lights.forEach((l) => {
      if (!l.parent && this.rootNodes.indexOf(l) === -1) {
        this.rootNodes.push(l);
      }
    });
    this.cameras.forEach((c) => {
      if (!c.parent && this.rootNodes.indexOf(c) === -1) {
        this.rootNodes.push(c);
      }
    });
  }
  /**
   * @since 6.26.0
   * Given a root asset, this method will traverse its hierarchy and add it, its children and any materials/skeletons/animation groups to the container.
   * @param root root node
   */
  addAllAssetsToContainer(root) {
    if (!root) {
      return;
    }
    const nodesToVisit = [];
    const visitedNodes = /* @__PURE__ */ new Set();
    nodesToVisit.push(root);
    while (nodesToVisit.length > 0) {
      const nodeToVisit = nodesToVisit.pop();
      if (nodeToVisit instanceof Mesh) {
        if (nodeToVisit.geometry && this.geometries.indexOf(nodeToVisit.geometry) === -1) {
          this.geometries.push(nodeToVisit.geometry);
        }
        this.meshes.push(nodeToVisit);
      } else if (nodeToVisit instanceof TransformNode) {
        this.transformNodes.push(nodeToVisit);
      } else if (nodeToVisit instanceof Light) {
        this.lights.push(nodeToVisit);
      } else if (nodeToVisit instanceof Camera) {
        this.cameras.push(nodeToVisit);
      }
      if (nodeToVisit instanceof AbstractMesh) {
        if (nodeToVisit.material && this.materials.indexOf(nodeToVisit.material) === -1) {
          this.materials.push(nodeToVisit.material);
          for (const texture of nodeToVisit.material.getActiveTextures()) {
            if (this.textures.indexOf(texture) === -1) {
              this.textures.push(texture);
            }
          }
        }
        if (nodeToVisit.skeleton && this.skeletons.indexOf(nodeToVisit.skeleton) === -1) {
          this.skeletons.push(nodeToVisit.skeleton);
        }
        if (nodeToVisit.morphTargetManager && this.morphTargetManagers.indexOf(nodeToVisit.morphTargetManager) === -1) {
          this.morphTargetManagers.push(nodeToVisit.morphTargetManager);
        }
      }
      for (const child of nodeToVisit.getChildren()) {
        if (!visitedNodes.has(child)) {
          nodesToVisit.push(child);
        }
      }
      visitedNodes.add(nodeToVisit);
    }
    this.populateRootNodes();
  }
};

// node_modules/@babylonjs/core/Audio/sound.js
var Sound = class _Sound {
  /**
   * Does the sound loop after it finishes playing once.
   */
  get loop() {
    return this._loop;
  }
  set loop(value) {
    if (value === this._loop) {
      return;
    }
    this._loop = value;
    this.updateOptions({ loop: value });
  }
  /**
   * Gets the current time for the sound.
   */
  get currentTime() {
    var _a;
    if (this._htmlAudioElement) {
      return this._htmlAudioElement.currentTime;
    }
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext) && (this.isPlaying || this.isPaused)) {
      const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;
      return this._currentTime + timeSinceLastStart;
    }
    return 0;
  }
  /**
   * Does this sound enables spatial sound.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
   */
  get spatialSound() {
    return this._spatialSound;
  }
  /**
   * Does this sound enables spatial sound.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
   */
  set spatialSound(newValue) {
    if (newValue == this._spatialSound) {
      return;
    }
    const wasPlaying = this.isPlaying;
    this.pause();
    if (newValue) {
      this._spatialSound = newValue;
      this._updateSpatialParameters();
    } else {
      this._disableSpatialSound();
    }
    if (wasPlaying) {
      this.play();
    }
  }
  /**
   * Create a sound and attach it to a scene
   * @param name Name of your sound
   * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers
   * @param scene defines the scene the sound belongs to
   * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played
   * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming
   */
  constructor(name50, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {
    var _a;
    this.autoplay = false;
    this._loop = false;
    this.useCustomAttenuation = false;
    this.isPlaying = false;
    this.isPaused = false;
    this.refDistance = 1;
    this.rolloffFactor = 1;
    this.maxDistance = 100;
    this.distanceModel = "linear";
    this.metadata = null;
    this.onEndedObservable = new Observable();
    this._spatialSound = false;
    this._panningModel = "equalpower";
    this._playbackRate = 1;
    this._streaming = false;
    this._startTime = 0;
    this._currentTime = 0;
    this._position = Vector3.Zero();
    this._localDirection = new Vector3(1, 0, 0);
    this._volume = 1;
    this._isReadyToPlay = false;
    this._isDirectional = false;
    this._coneInnerAngle = 360;
    this._coneOuterAngle = 360;
    this._coneOuterGain = 0;
    this._isOutputConnected = false;
    this._urlType = "Unknown";
    this.name = name50;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this._scene = scene;
    _Sound._SceneComponentInitialization(scene);
    this._readyToPlayCallback = readyToPlayCallback;
    this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {
      if (currentDistance < maxDistance) {
        return currentVolume * (1 - currentDistance / maxDistance);
      } else {
        return 0;
      }
    };
    if (options) {
      this.autoplay = options.autoplay || false;
      this._loop = options.loop || false;
      if (options.volume !== void 0) {
        this._volume = options.volume;
      }
      this._spatialSound = options.spatialSound ?? false;
      this.maxDistance = options.maxDistance ?? 100;
      this.useCustomAttenuation = options.useCustomAttenuation ?? false;
      this.rolloffFactor = options.rolloffFactor || 1;
      this.refDistance = options.refDistance || 1;
      this.distanceModel = options.distanceModel || "linear";
      this._playbackRate = options.playbackRate || 1;
      this._streaming = options.streaming ?? false;
      this._length = options.length;
      this._offset = options.offset;
    }
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
      this._soundGain = Engine.audioEngine.audioContext.createGain();
      this._soundGain.gain.value = this._volume;
      this._inputAudioNode = this._soundGain;
      this._outputAudioNode = this._soundGain;
      if (this._spatialSound) {
        this._createSpatialParameters();
      }
      this._scene.mainSoundTrack.addSound(this);
      let validParameter = true;
      if (urlOrArrayBuffer) {
        try {
          if (typeof urlOrArrayBuffer === "string") {
            this._urlType = "String";
            this._url = urlOrArrayBuffer;
          } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
            this._urlType = "ArrayBuffer";
          } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {
            this._urlType = "MediaElement";
          } else if (urlOrArrayBuffer instanceof MediaStream) {
            this._urlType = "MediaStream";
          } else if (urlOrArrayBuffer instanceof AudioBuffer) {
            this._urlType = "AudioBuffer";
          } else if (Array.isArray(urlOrArrayBuffer)) {
            this._urlType = "Array";
          }
          let urls = [];
          let codecSupportedFound = false;
          switch (this._urlType) {
            case "MediaElement":
              this._streaming = true;
              this._isReadyToPlay = true;
              this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);
              if (this.autoplay) {
                this.play(0, this._offset, this._length);
              }
              if (this._readyToPlayCallback) {
                this._readyToPlayCallback();
              }
              break;
            case "MediaStream":
              this._streaming = true;
              this._isReadyToPlay = true;
              this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);
              if (this.autoplay) {
                this.play(0, this._offset, this._length);
              }
              if (this._readyToPlayCallback) {
                this._readyToPlayCallback();
              }
              break;
            case "ArrayBuffer":
              if (urlOrArrayBuffer.byteLength > 0) {
                codecSupportedFound = true;
                this._soundLoaded(urlOrArrayBuffer);
              }
              break;
            case "AudioBuffer":
              this._audioBufferLoaded(urlOrArrayBuffer);
              break;
            case "String":
              urls.push(urlOrArrayBuffer);
            case "Array":
              if (urls.length === 0) {
                urls = urlOrArrayBuffer;
              }
              for (let i = 0; i < urls.length; i++) {
                const url = urls[i];
                codecSupportedFound = options && options.skipCodecCheck || url.indexOf(".mp3", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(".ogg", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(".wav", url.length - 4) !== -1 || url.indexOf(".m4a", url.length - 4) !== -1 || url.indexOf(".mp4", url.length - 4) !== -1 || url.indexOf("blob:") !== -1;
                if (codecSupportedFound) {
                  if (!this._streaming) {
                    this._scene._loadFile(url, (data) => {
                      this._soundLoaded(data);
                    }, void 0, true, true, (exception) => {
                      if (exception) {
                        Logger.Error("XHR " + exception.status + " error on: " + url + ".");
                      }
                      Logger.Error("Sound creation aborted.");
                      this._scene.mainSoundTrack.removeSound(this);
                    });
                  } else {
                    this._htmlAudioElement = new Audio(url);
                    this._htmlAudioElement.controls = false;
                    this._htmlAudioElement.loop = this.loop;
                    Tools.SetCorsBehavior(url, this._htmlAudioElement);
                    this._htmlAudioElement.preload = "auto";
                    this._htmlAudioElement.addEventListener("canplaythrough", () => {
                      this._isReadyToPlay = true;
                      if (this.autoplay) {
                        this.play(0, this._offset, this._length);
                      }
                      if (this._readyToPlayCallback) {
                        this._readyToPlayCallback();
                      }
                    });
                    document.body.appendChild(this._htmlAudioElement);
                    this._htmlAudioElement.load();
                  }
                  break;
                }
              }
              break;
            default:
              validParameter = false;
              break;
          }
          if (!validParameter) {
            Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
          } else {
            if (!codecSupportedFound) {
              this._isReadyToPlay = true;
              if (this._readyToPlayCallback) {
                setTimeout(() => {
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                }, 1e3);
              }
            }
          }
        } catch (ex) {
          Logger.Error("Unexpected error. Sound creation aborted.");
          this._scene.mainSoundTrack.removeSound(this);
        }
      }
    } else {
      this._scene.mainSoundTrack.addSound(this);
      if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {
        Logger.Error("Web Audio is not supported by your browser.");
        Engine.audioEngine.WarnedWebAudioUnsupported = true;
      }
      if (this._readyToPlayCallback) {
        setTimeout(() => {
          if (this._readyToPlayCallback) {
            this._readyToPlayCallback();
          }
        }, 1e3);
      }
    }
  }
  /**
   * Release the sound and its associated resources
   */
  dispose() {
    var _a;
    if ((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
      if (this.isPlaying) {
        this.stop();
      }
      this._isReadyToPlay = false;
      if (this.soundTrackId === -1) {
        this._scene.mainSoundTrack.removeSound(this);
      } else if (this._scene.soundTracks) {
        this._scene.soundTracks[this.soundTrackId].removeSound(this);
      }
      if (this._soundGain) {
        this._soundGain.disconnect();
        this._soundGain = null;
      }
      if (this._soundPanner) {
        this._soundPanner.disconnect();
        this._soundPanner = null;
      }
      if (this._soundSource) {
        this._soundSource.disconnect();
        this._soundSource = null;
      }
      this._audioBuffer = null;
      if (this._htmlAudioElement) {
        this._htmlAudioElement.pause();
        this._htmlAudioElement.src = "";
        document.body.removeChild(this._htmlAudioElement);
      }
      if (this._streamingSource) {
        this._streamingSource.disconnect();
      }
      if (this._connectedTransformNode && this._registerFunc) {
        this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
        this._connectedTransformNode = null;
      }
      this._clearTimeoutsAndObservers();
    }
  }
  /**
   * Gets if the sounds is ready to be played or not.
   * @returns true if ready, otherwise false
   */
  isReady() {
    return this._isReadyToPlay;
  }
  /**
   * Get the current class name.
   * @returns current class name
   */
  getClassName() {
    return "Sound";
  }
  _audioBufferLoaded(buffer) {
    var _a;
    if (!((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext)) {
      return;
    }
    this._audioBuffer = buffer;
    this._isReadyToPlay = true;
    if (this.autoplay) {
      this.play(0, this._offset, this._length);
    }
    if (this._readyToPlayCallback) {
      this._readyToPlayCallback();
    }
  }
  _soundLoaded(audioData) {
    var _a;
    if (!((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext)) {
      return;
    }
    Engine.audioEngine.audioContext.decodeAudioData(audioData, (buffer) => {
      this._audioBufferLoaded(buffer);
    }, (err) => {
      Logger.Error("Error while decoding audio data for: " + this.name + " / Error: " + err);
    });
  }
  /**
   * Sets the data of the sound from an audiobuffer
   * @param audioBuffer The audioBuffer containing the data
   */
  setAudioBuffer(audioBuffer) {
    var _a;
    if ((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) {
      this._audioBuffer = audioBuffer;
      this._isReadyToPlay = true;
    }
  }
  /**
   * Updates the current sounds options such as maxdistance, loop...
   * @param options A JSON object containing values named as the object properties
   */
  updateOptions(options) {
    if (options) {
      this.loop = options.loop ?? this.loop;
      this.maxDistance = options.maxDistance ?? this.maxDistance;
      this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;
      this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;
      this.refDistance = options.refDistance ?? this.refDistance;
      this.distanceModel = options.distanceModel ?? this.distanceModel;
      this._playbackRate = options.playbackRate ?? this._playbackRate;
      this._length = options.length ?? void 0;
      this.spatialSound = options.spatialSound ?? this._spatialSound;
      this._setOffset(options.offset ?? void 0);
      this.setVolume(options.volume ?? this._volume);
      this._updateSpatialParameters();
      if (this.isPlaying) {
        if (this._streaming && this._htmlAudioElement) {
          this._htmlAudioElement.playbackRate = this._playbackRate;
          if (this._htmlAudioElement.loop !== this.loop) {
            this._htmlAudioElement.loop = this.loop;
          }
        } else {
          if (this._soundSource) {
            this._soundSource.playbackRate.value = this._playbackRate;
            if (this._soundSource.loop !== this.loop) {
              this._soundSource.loop = this.loop;
            }
            if (this._offset !== void 0 && this._soundSource.loopStart !== this._offset) {
              this._soundSource.loopStart = this._offset;
            }
            if (this._length !== void 0 && this._length !== this._soundSource.loopEnd) {
              this._soundSource.loopEnd = (this._offset | 0) + this._length;
            }
          }
        }
      }
    }
  }
  _createSpatialParameters() {
    var _a;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
      if (this._scene.headphone) {
        this._panningModel = "HRTF";
      }
      this._soundPanner = this._soundPanner ?? Engine.audioEngine.audioContext.createPanner();
      if (this._soundPanner && this._outputAudioNode) {
        this._updateSpatialParameters();
        this._soundPanner.connect(this._outputAudioNode);
        this._inputAudioNode = this._soundPanner;
      }
    }
  }
  _disableSpatialSound() {
    var _a;
    if (!this._spatialSound) {
      return;
    }
    this._inputAudioNode = this._soundGain;
    (_a = this._soundPanner) == null ? void 0 : _a.disconnect();
    this._soundPanner = null;
    this._spatialSound = false;
  }
  _updateSpatialParameters() {
    if (!this._spatialSound) {
      return;
    }
    if (this._soundPanner) {
      if (this.useCustomAttenuation) {
        this._soundPanner.distanceModel = "linear";
        this._soundPanner.maxDistance = Number.MAX_VALUE;
        this._soundPanner.refDistance = 1;
        this._soundPanner.rolloffFactor = 1;
        this._soundPanner.panningModel = this._panningModel;
      } else {
        this._soundPanner.distanceModel = this.distanceModel;
        this._soundPanner.maxDistance = this.maxDistance;
        this._soundPanner.refDistance = this.refDistance;
        this._soundPanner.rolloffFactor = this.rolloffFactor;
        this._soundPanner.panningModel = this._panningModel;
      }
    } else {
      this._createSpatialParameters();
    }
  }
  /**
   * Switch the panning model to HRTF:
   * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
   */
  switchPanningModelToHRTF() {
    this._panningModel = "HRTF";
    this._switchPanningModel();
  }
  /**
   * Switch the panning model to Equal Power:
   * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound
   */
  switchPanningModelToEqualPower() {
    this._panningModel = "equalpower";
    this._switchPanningModel();
  }
  _switchPanningModel() {
    var _a;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
      this._soundPanner.panningModel = this._panningModel;
    }
  }
  /**
   * Connect this sound to a sound track audio node like gain...
   * @param soundTrackAudioNode the sound track audio node to connect to
   */
  connectToSoundTrackAudioNode(soundTrackAudioNode) {
    var _a;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
      if (this._isOutputConnected) {
        this._outputAudioNode.disconnect();
      }
      this._outputAudioNode.connect(soundTrackAudioNode);
      this._isOutputConnected = true;
    }
  }
  /**
   * Transform this sound into a directional source
   * @param coneInnerAngle Size of the inner cone in degree
   * @param coneOuterAngle Size of the outer cone in degree
   * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)
   */
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    if (coneOuterAngle < coneInnerAngle) {
      Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
      return;
    }
    this._coneInnerAngle = coneInnerAngle;
    this._coneOuterAngle = coneOuterAngle;
    this._coneOuterGain = coneOuterGain;
    this._isDirectional = true;
    if (this.isPlaying && this.loop) {
      this.stop();
      this.play(0, this._offset, this._length);
    }
  }
  /**
   * Gets or sets the inner angle for the directional cone.
   */
  get directionalConeInnerAngle() {
    return this._coneInnerAngle;
  }
  /**
   * Gets or sets the inner angle for the directional cone.
   */
  set directionalConeInnerAngle(value) {
    var _a;
    if (value != this._coneInnerAngle) {
      if (this._coneOuterAngle < value) {
        Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
        return;
      }
      this._coneInnerAngle = value;
      if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
        this._soundPanner.coneInnerAngle = this._coneInnerAngle;
      }
    }
  }
  /**
   * Gets or sets the outer angle for the directional cone.
   */
  get directionalConeOuterAngle() {
    return this._coneOuterAngle;
  }
  /**
   * Gets or sets the outer angle for the directional cone.
   */
  set directionalConeOuterAngle(value) {
    var _a;
    if (value != this._coneOuterAngle) {
      if (value < this._coneInnerAngle) {
        Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
        return;
      }
      this._coneOuterAngle = value;
      if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
        this._soundPanner.coneOuterAngle = this._coneOuterAngle;
      }
    }
  }
  /**
   * Sets the position of the emitter if spatial sound is enabled
   * @param newPosition Defines the new position
   */
  setPosition(newPosition) {
    var _a;
    if (newPosition.equals(this._position)) {
      return;
    }
    this._position.copyFrom(newPosition);
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
      this._soundPanner.positionX.value = this._position.x;
      this._soundPanner.positionY.value = this._position.y;
      this._soundPanner.positionZ.value = this._position.z;
    }
  }
  /**
   * Sets the local direction of the emitter if spatial sound is enabled
   * @param newLocalDirection Defines the new local direction
   */
  setLocalDirectionToMesh(newLocalDirection) {
    var _a;
    this._localDirection = newLocalDirection;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {
      this._updateDirection();
    }
  }
  _updateDirection() {
    if (!this._connectedTransformNode || !this._soundPanner) {
      return;
    }
    const mat = this._connectedTransformNode.getWorldMatrix();
    const direction = Vector3.TransformNormal(this._localDirection, mat);
    direction.normalize();
    this._soundPanner.orientationX.value = direction.x;
    this._soundPanner.orientationY.value = direction.y;
    this._soundPanner.orientationZ.value = direction.z;
  }
  /** @internal */
  updateDistanceFromListener() {
    var _a;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
      const distance = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
      this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
    }
  }
  /**
   * Sets a new custom attenuation function for the sound.
   * @param callback Defines the function used for the attenuation
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function
   */
  setAttenuationFunction(callback) {
    this._customAttenuationFunction = callback;
  }
  /**
   * Play the sound
   * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.
   * @param offset (optional) Start the sound at a specific time in seconds
   * @param length (optional) Sound duration (in seconds)
   */
  play(time, offset, length) {
    var _a, _b, _c, _d;
    if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext)) {
      try {
        this._clearTimeoutsAndObservers();
        let startTime = time ? ((_b = Engine.audioEngine) == null ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) == null ? void 0 : _c.audioContext.currentTime;
        if (!this._soundSource || !this._streamingSource) {
          if (this._spatialSound && this._soundPanner) {
            if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
              this._soundPanner.positionX.value = this._position.x;
              this._soundPanner.positionY.value = this._position.y;
              this._soundPanner.positionZ.value = this._position.z;
            }
            if (this._isDirectional) {
              this._soundPanner.coneInnerAngle = this._coneInnerAngle;
              this._soundPanner.coneOuterAngle = this._coneOuterAngle;
              this._soundPanner.coneOuterGain = this._coneOuterGain;
              if (this._connectedTransformNode) {
                this._updateDirection();
              } else {
                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);
              }
            }
          }
        }
        if (this._streaming) {
          if (!this._streamingSource) {
            this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);
            this._htmlAudioElement.onended = () => {
              this._onended();
            };
            this._htmlAudioElement.playbackRate = this._playbackRate;
          }
          this._streamingSource.disconnect();
          if (this._inputAudioNode) {
            this._streamingSource.connect(this._inputAudioNode);
          }
          if (this._htmlAudioElement) {
            const tryToPlay = () => {
              var _a2, _b2;
              if ((_a2 = Engine.audioEngine) == null ? void 0 : _a2.unlocked) {
                const playPromise = this._htmlAudioElement.play();
                if (playPromise !== void 0) {
                  playPromise.catch(() => {
                    var _a3, _b3;
                    (_a3 = Engine.audioEngine) == null ? void 0 : _a3.lock();
                    if (this.loop || this.autoplay) {
                      this._audioUnlockedObserver = (_b3 = Engine.audioEngine) == null ? void 0 : _b3.onAudioUnlockedObservable.addOnce(() => {
                        tryToPlay();
                      });
                    }
                  });
                }
              } else {
                if (this.loop || this.autoplay) {
                  this._audioUnlockedObserver = (_b2 = Engine.audioEngine) == null ? void 0 : _b2.onAudioUnlockedObservable.addOnce(() => {
                    tryToPlay();
                  });
                }
              }
            };
            tryToPlay();
          }
        } else {
          const tryToPlay = () => {
            var _a2, _b2, _c2;
            if ((_a2 = Engine.audioEngine) == null ? void 0 : _a2.audioContext) {
              length = length || this._length;
              if (offset !== void 0) {
                this._setOffset(offset);
              }
              if (this._soundSource) {
                const oldSource = this._soundSource;
                oldSource.onended = () => {
                  oldSource.disconnect();
                };
              }
              this._soundSource = (_b2 = Engine.audioEngine) == null ? void 0 : _b2.audioContext.createBufferSource();
              if (this._soundSource && this._inputAudioNode) {
                this._soundSource.buffer = this._audioBuffer;
                this._soundSource.connect(this._inputAudioNode);
                this._soundSource.loop = this.loop;
                if (offset !== void 0) {
                  this._soundSource.loopStart = offset;
                }
                if (length !== void 0) {
                  this._soundSource.loopEnd = (offset | 0) + length;
                }
                this._soundSource.playbackRate.value = this._playbackRate;
                this._soundSource.onended = () => {
                  this._onended();
                };
                startTime = time ? ((_c2 = Engine.audioEngine) == null ? void 0 : _c2.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;
                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer.duration;
                this._soundSource.start(startTime, actualOffset, this.loop ? void 0 : length);
              }
            }
          };
          if (((_d = Engine.audioEngine) == null ? void 0 : _d.audioContext.state) === "suspended") {
            this._tryToPlayTimeout = setTimeout(() => {
              var _a2;
              if (((_a2 = Engine.audioEngine) == null ? void 0 : _a2.audioContext.state) === "suspended") {
                Engine.audioEngine.lock();
                if (this.loop || this.autoplay) {
                  this._audioUnlockedObserver = Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {
                    tryToPlay();
                  });
                }
              } else {
                tryToPlay();
              }
            }, 500);
          } else {
            tryToPlay();
          }
        }
        this._startTime = startTime;
        this.isPlaying = true;
        this.isPaused = false;
      } catch (ex) {
        Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
      }
    }
  }
  _onended() {
    this.isPlaying = false;
    this._startTime = 0;
    this._currentTime = 0;
    if (this.onended) {
      this.onended();
    }
    this.onEndedObservable.notifyObservers(this);
  }
  /**
   * Stop the sound
   * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.
   */
  stop(time) {
    var _a;
    if (this.isPlaying) {
      this._clearTimeoutsAndObservers();
      if (this._streaming) {
        if (this._htmlAudioElement) {
          this._htmlAudioElement.pause();
          if (this._htmlAudioElement.currentTime > 0) {
            this._htmlAudioElement.currentTime = 0;
          }
        } else {
          this._streamingSource.disconnect();
        }
        this.isPlaying = false;
      } else if (((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext) && this._soundSource) {
        const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : void 0;
        this._soundSource.onended = () => {
          this.isPlaying = false;
          this.isPaused = false;
          this._startTime = 0;
          this._currentTime = 0;
          if (this._soundSource) {
            this._soundSource.onended = () => void 0;
          }
          this._onended();
        };
        this._soundSource.stop(stopTime);
      } else {
        this.isPlaying = false;
      }
    } else if (this.isPaused) {
      this.isPaused = false;
      this._startTime = 0;
      this._currentTime = 0;
    }
  }
  /**
   * Put the sound in pause
   */
  pause() {
    var _a;
    if (this.isPlaying) {
      this._clearTimeoutsAndObservers();
      if (this._streaming) {
        if (this._htmlAudioElement) {
          this._htmlAudioElement.pause();
        } else {
          this._streamingSource.disconnect();
        }
        this.isPlaying = false;
        this.isPaused = true;
      } else if (((_a = Engine.audioEngine) == null ? void 0 : _a.audioContext) && this._soundSource) {
        this._soundSource.onended = () => void 0;
        this._soundSource.stop();
        this.isPlaying = false;
        this.isPaused = true;
        this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;
      }
    }
  }
  /**
   * Sets a dedicated volume for this sounds
   * @param newVolume Define the new volume of the sound
   * @param time Define time for gradual change to new volume
   */
  setVolume(newVolume, time) {
    var _a;
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._soundGain) {
      if (time && Engine.audioEngine.audioContext) {
        this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);
        this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);
        this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);
      } else {
        this._soundGain.gain.value = newVolume;
      }
    }
    this._volume = newVolume;
  }
  /**
   * Set the sound play back rate
   * @param newPlaybackRate Define the playback rate the sound should be played at
   */
  setPlaybackRate(newPlaybackRate) {
    this._playbackRate = newPlaybackRate;
    if (this.isPlaying) {
      if (this._streaming && this._htmlAudioElement) {
        this._htmlAudioElement.playbackRate = this._playbackRate;
      } else if (this._soundSource) {
        this._soundSource.playbackRate.value = this._playbackRate;
      }
    }
  }
  /**
   * Gets the sound play back rate.
   * @returns the  play back rate of the sound
   */
  getPlaybackRate() {
    return this._playbackRate;
  }
  /**
   * Gets the volume of the sound.
   * @returns the volume of the sound
   */
  getVolume() {
    return this._volume;
  }
  /**
   * Attach the sound to a dedicated mesh
   * @param transformNode The transform node to connect the sound with
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh
   */
  attachToMesh(transformNode) {
    if (this._connectedTransformNode && this._registerFunc) {
      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
      this._registerFunc = null;
    }
    this._connectedTransformNode = transformNode;
    if (!this._spatialSound) {
      this._spatialSound = true;
      this._createSpatialParameters();
      if (this.isPlaying && this.loop) {
        this.stop();
        this.play(0, this._offset, this._length);
      }
    }
    this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
    this._registerFunc = (transformNode2) => this._onRegisterAfterWorldMatrixUpdate(transformNode2);
    this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
  }
  /**
   * Detach the sound from the previously attached mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh
   */
  detachFromMesh() {
    if (this._connectedTransformNode && this._registerFunc) {
      this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
      this._registerFunc = null;
      this._connectedTransformNode = null;
    }
  }
  _onRegisterAfterWorldMatrixUpdate(node) {
    var _a;
    if (!node.getBoundingInfo) {
      this.setPosition(node.absolutePosition);
    } else {
      const mesh = node;
      const boundingInfo = mesh.getBoundingInfo();
      this.setPosition(boundingInfo.boundingSphere.centerWorld);
    }
    if (((_a = Engine.audioEngine) == null ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {
      this._updateDirection();
    }
  }
  /**
   * Clone the current sound in the scene.
   * @returns the new sound clone
   */
  clone() {
    if (!this._streaming) {
      const setBufferAndRun = () => {
        if (this._isReadyToPlay) {
          clonedSound._audioBuffer = this.getAudioBuffer();
          clonedSound._isReadyToPlay = true;
          if (clonedSound.autoplay) {
            clonedSound.play(0, this._offset, this._length);
          }
        } else {
          setTimeout(setBufferAndRun, 300);
        }
      };
      const currentOptions = {
        autoplay: this.autoplay,
        loop: this.loop,
        volume: this._volume,
        spatialSound: this._spatialSound,
        maxDistance: this.maxDistance,
        useCustomAttenuation: this.useCustomAttenuation,
        rolloffFactor: this.rolloffFactor,
        refDistance: this.refDistance,
        distanceModel: this.distanceModel
      };
      const clonedSound = new _Sound(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, currentOptions);
      if (this.useCustomAttenuation) {
        clonedSound.setAttenuationFunction(this._customAttenuationFunction);
      }
      clonedSound.setPosition(this._position);
      clonedSound.setPlaybackRate(this._playbackRate);
      setBufferAndRun();
      return clonedSound;
    } else {
      return null;
    }
  }
  /**
   * Gets the current underlying audio buffer containing the data
   * @returns the audio buffer
   */
  getAudioBuffer() {
    return this._audioBuffer;
  }
  /**
   * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.
   * @returns the source node
   */
  getSoundSource() {
    return this._soundSource;
  }
  /**
   * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.
   * @returns the gain node
   */
  getSoundGain() {
    return this._soundGain;
  }
  /**
   * Serializes the Sound in a JSON representation
   * @returns the JSON representation of the sound
   */
  serialize() {
    const serializationObject = {
      name: this.name,
      url: this._url,
      autoplay: this.autoplay,
      loop: this.loop,
      volume: this._volume,
      spatialSound: this._spatialSound,
      maxDistance: this.maxDistance,
      rolloffFactor: this.rolloffFactor,
      refDistance: this.refDistance,
      distanceModel: this.distanceModel,
      playbackRate: this._playbackRate,
      panningModel: this._panningModel,
      soundTrackId: this.soundTrackId,
      metadata: this.metadata
    };
    if (this._spatialSound) {
      if (this._connectedTransformNode) {
        serializationObject.connectedMeshId = this._connectedTransformNode.id;
      }
      serializationObject.position = this._position.asArray();
      serializationObject.refDistance = this.refDistance;
      serializationObject.distanceModel = this.distanceModel;
      serializationObject.isDirectional = this._isDirectional;
      serializationObject.localDirectionToMesh = this._localDirection.asArray();
      serializationObject.coneInnerAngle = this._coneInnerAngle;
      serializationObject.coneOuterAngle = this._coneOuterAngle;
      serializationObject.coneOuterGain = this._coneOuterGain;
    }
    return serializationObject;
  }
  /**
   * Parse a JSON representation of a sound to instantiate in a given scene
   * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)
   * @param scene Define the scene the new parsed sound should be created in
   * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies
   * @param sourceSound Define a sound place holder if do not need to instantiate a new one
   * @returns the newly parsed sound
   */
  static Parse(parsedSound, scene, rootUrl, sourceSound) {
    const soundName = parsedSound.name;
    let soundUrl;
    if (parsedSound.url) {
      soundUrl = rootUrl + parsedSound.url;
    } else {
      soundUrl = rootUrl + soundName;
    }
    const options = {
      autoplay: parsedSound.autoplay,
      loop: parsedSound.loop,
      volume: parsedSound.volume,
      spatialSound: parsedSound.spatialSound,
      maxDistance: parsedSound.maxDistance,
      rolloffFactor: parsedSound.rolloffFactor,
      refDistance: parsedSound.refDistance,
      distanceModel: parsedSound.distanceModel,
      playbackRate: parsedSound.playbackRate
    };
    let newSound;
    if (!sourceSound) {
      newSound = new _Sound(soundName, soundUrl, scene, () => {
        scene.removePendingData(newSound);
      }, options);
      scene.addPendingData(newSound);
    } else {
      const setBufferAndRun = () => {
        if (sourceSound._isReadyToPlay) {
          newSound._audioBuffer = sourceSound.getAudioBuffer();
          newSound._isReadyToPlay = true;
          if (newSound.autoplay) {
            newSound.play(0, newSound._offset, newSound._length);
          }
        } else {
          setTimeout(setBufferAndRun, 300);
        }
      };
      newSound = new _Sound(soundName, new ArrayBuffer(0), scene, null, options);
      setBufferAndRun();
    }
    if (parsedSound.position) {
      const soundPosition = Vector3.FromArray(parsedSound.position);
      newSound.setPosition(soundPosition);
    }
    if (parsedSound.isDirectional) {
      newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
      if (parsedSound.localDirectionToMesh) {
        const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
        newSound.setLocalDirectionToMesh(localDirectionToMesh);
      }
    }
    if (parsedSound.connectedMeshId) {
      const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);
      if (connectedMesh) {
        newSound.attachToMesh(connectedMesh);
      }
    }
    if (parsedSound.metadata) {
      newSound.metadata = parsedSound.metadata;
    }
    return newSound;
  }
  _setOffset(value) {
    if (this._offset === value) {
      return;
    }
    if (this.isPaused) {
      this.stop();
      this.isPaused = false;
    }
    this._offset = value;
  }
  _clearTimeoutsAndObservers() {
    var _a;
    if (this._tryToPlayTimeout) {
      clearTimeout(this._tryToPlayTimeout);
      this._tryToPlayTimeout = null;
    }
    if (this._audioUnlockedObserver) {
      (_a = Engine.audioEngine) == null ? void 0 : _a.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);
      this._audioUnlockedObserver = null;
    }
  }
};
Sound._SceneComponentInitialization = (_) => {
  throw _WarnImport("AudioSceneComponent");
};
RegisterClass("BABYLON.Sound", Sound);

// node_modules/@babylonjs/core/Audio/weightedsound.js
var WeightedSound = class {
  /**
   * Creates a new WeightedSound from the list of sounds given.
   * @param loop When true a Sound will be selected and played when the current playing Sound completes.
   * @param sounds Array of Sounds that will be selected from.
   * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1
   */
  constructor(loop, sounds, weights) {
    this.loop = false;
    this._coneInnerAngle = 360;
    this._coneOuterAngle = 360;
    this._volume = 1;
    this.isPlaying = false;
    this.isPaused = false;
    this._sounds = [];
    this._weights = [];
    if (sounds.length !== weights.length) {
      throw new Error("Sounds length does not equal weights length");
    }
    this.loop = loop;
    this._weights = weights;
    let weightSum = 0;
    for (const weight of weights) {
      weightSum += weight;
    }
    const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;
    for (let i = 0; i < this._weights.length; i++) {
      this._weights[i] *= invWeightSum;
    }
    this._sounds = sounds;
    for (const sound of this._sounds) {
      sound.onEndedObservable.add(() => {
        this._onended();
      });
    }
  }
  /**
   * The size of cone in degrees for a directional sound in which there will be no attenuation.
   */
  get directionalConeInnerAngle() {
    return this._coneInnerAngle;
  }
  /**
   * The size of cone in degrees for a directional sound in which there will be no attenuation.
   */
  set directionalConeInnerAngle(value) {
    if (value !== this._coneInnerAngle) {
      if (this._coneOuterAngle < value) {
        Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
        return;
      }
      this._coneInnerAngle = value;
      for (const sound of this._sounds) {
        sound.directionalConeInnerAngle = value;
      }
    }
  }
  /**
   * Size of cone in degrees for a directional sound outside of which there will be no sound.
   * Listener angles between innerAngle and outerAngle will falloff linearly.
   */
  get directionalConeOuterAngle() {
    return this._coneOuterAngle;
  }
  /**
   * Size of cone in degrees for a directional sound outside of which there will be no sound.
   * Listener angles between innerAngle and outerAngle will falloff linearly.
   */
  set directionalConeOuterAngle(value) {
    if (value !== this._coneOuterAngle) {
      if (value < this._coneInnerAngle) {
        Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
        return;
      }
      this._coneOuterAngle = value;
      for (const sound of this._sounds) {
        sound.directionalConeOuterAngle = value;
      }
    }
  }
  /**
   * Playback volume.
   */
  get volume() {
    return this._volume;
  }
  /**
   * Playback volume.
   */
  set volume(value) {
    if (value !== this._volume) {
      for (const sound of this._sounds) {
        sound.setVolume(value);
      }
    }
  }
  _onended() {
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].autoplay = false;
    }
    if (this.loop && this.isPlaying) {
      this.play();
    } else {
      this.isPlaying = false;
    }
  }
  /**
   * Suspend playback
   */
  pause() {
    this.isPaused = true;
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].pause();
    }
  }
  /**
   * Stop playback
   */
  stop() {
    this.isPlaying = false;
    if (this._currentIndex !== void 0) {
      this._sounds[this._currentIndex].stop();
    }
  }
  /**
   * Start playback.
   * @param startOffset Position the clip head at a specific time in seconds.
   */
  play(startOffset) {
    if (!this.isPaused) {
      this.stop();
      const randomValue = Math.random();
      let total = 0;
      for (let i = 0; i < this._weights.length; i++) {
        total += this._weights[i];
        if (randomValue <= total) {
          this._currentIndex = i;
          break;
        }
      }
    }
    const sound = this._sounds[this._currentIndex];
    if (sound.isReady()) {
      sound.play(0, this.isPaused ? void 0 : startOffset);
    } else {
      sound.autoplay = true;
    }
    this.isPlaying = true;
    this.isPaused = false;
  }
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
  if (!texture) {
    return;
  }
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
  const internalFormat = this._getInternalFormat(format);
  const textureType = this._getWebGLTextureType(type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (texture.width % 4 !== 0) {
    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
  }
  if (compression && data) {
    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
  } else {
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
  }
  if (texture.generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
  const texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
  if (generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
  const gl = this._gl;
  const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  texture.isCube = true;
  texture.format = format;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
  }
  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  const width = size;
  const height = width;
  texture.width = width;
  texture.height = height;
  texture.invertY = invertY;
  texture._compression = compression;
  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);
  if (!isPot) {
    generateMipMaps = false;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  } else {
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
    const level = 0;
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      if (compression) {
        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, void 0);
      } else {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);
      }
    }
    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
  if (data && generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.isReady = true;
  return texture;
};
ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression = null, level = 0) {
  texture._bufferViewArray = data;
  texture.format = format;
  texture.type = type;
  texture.invertY = invertY;
  texture._compression = compression;
  const gl = this._gl;
  const textureType = this._getWebGLTextureType(type);
  let internalFormat = this._getInternalFormat(format);
  const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
  let needConversion = false;
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
    needConversion = true;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (texture.width % 4 !== 0) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
    let faceData = data[faceIndex];
    if (compression) {
      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
    } else {
      if (needConversion) {
        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
      }
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
    }
  }
  const isPot = !this.needPOTTextures || IsExponentOfTwo(texture.width) && IsExponentOfTwo(texture.height);
  if (isPot && texture.generateMipMaps && level === 0) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
  const gl = this._gl;
  const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene == null ? void 0 : scene.addPendingData(texture);
  texture.url = url;
  texture.isReady = false;
  this._internalTexturesCache.push(texture);
  const onerror = (request, exception) => {
    scene == null ? void 0 : scene.removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  const internalCallback = (data) => {
    const width = texture.width;
    const faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      const textureType = this._getWebGLTextureType(type);
      let internalFormat = this._getInternalFormat(format);
      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
      let needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      this._unpackFlipY(false);
      const mipData = mipmapGenerator(faceDataArrays);
      for (let level = 0; level < mipData.length; level++) {
        const mipSize = width >> level;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          let mipFaceData = mipData[level][faceIndex];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
        }
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    } else {
      this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene == null ? void 0 : scene.removePendingData(texture);
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, (data) => {
    internalCallback(data);
  }, void 0, scene == null ? void 0 : scene.offlineProvider, true, onerror);
  return texture;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    const texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const internalType = this._getWebGLTextureType(textureType);
    const internalFormat = this._getInternalFormat(format);
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture = class _RawTexture extends Texture {
  /**
   * Instantiates a new RawTexture.
   * Raw texture can help creating a texture directly from an array of data.
   * This can be super useful if you either get the data from an uncompressed source or
   * if you wish to create your texture pixel by pixel.
   * @param data define the array of data to use to create the texture (null to create an empty texture)
   * @param width define the width of the texture
   * @param height define the height of the texture
   * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps define whether mip maps should be generated or not
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   */
  constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {
    super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
    this.format = format;
    if (!this._engine) {
      return;
    }
    if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
      samplingMode = 1;
    }
    if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
      samplingMode = 1;
    }
    this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);
    this.wrapU = Texture.CLAMP_ADDRESSMODE;
    this.wrapV = Texture.CLAMP_ADDRESSMODE;
  }
  /**
   * Updates the texture underlying data.
   * @param data Define the new data of the texture
   */
  update(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
  }
  /**
   * Creates a luminance texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance texture
   */
  static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a luminance alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the luminance alpha texture
   */
  static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates an alpha texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @returns the alpha texture
   */
  static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
    return new _RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  }
  /**
   * Creates a RGB texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGB alpha texture
   */
  static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  }
  /**
   * Creates a RGBA storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the RGBA texture
   */
  static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
    return new _RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
  }
  /**
   * Creates a R texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  }
  /**
   * Creates a R storage texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param sceneOrEngine defines the scene or engine the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the R texture
   */
  static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
    return new _RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
  }
};

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton = class _Skeleton {
  /**
   * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).
   * Please note that this option is not available if the hardware does not support it
   */
  get useTextureToStoreBoneMatrices() {
    return this._useTextureToStoreBoneMatrices;
  }
  set useTextureToStoreBoneMatrices(value) {
    this._useTextureToStoreBoneMatrices = value;
    this._markAsDirty();
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    if (!this._animationPropertiesOverride) {
      return this._scene.animationPropertiesOverride;
    }
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /**
   * Gets a boolean indicating that the skeleton effectively stores matrices into a texture
   */
  get isUsingTextureForMatrices() {
    return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
  }
  /**
   * Gets the unique ID of this skeleton
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Creates a new skeleton
   * @param name defines the skeleton name
   * @param id defines the skeleton Id
   * @param scene defines the hosting scene
   */
  constructor(name50, id, scene) {
    this.name = name50;
    this.id = id;
    this.bones = [];
    this.needInitialSkinMatrix = false;
    this._isDirty = true;
    this._meshesWithPoseMatrix = new Array();
    this._identity = Matrix.Identity();
    this._currentRenderId = -1;
    this._ranges = {};
    this._absoluteTransformIsDirty = true;
    this._canUseTextureForBones = false;
    this._uniqueId = 0;
    this._numBonesWithLinkedTransformNode = 0;
    this._hasWaitingData = null;
    this._parentContainer = null;
    this.doNotSerialize = false;
    this._useTextureToStoreBoneMatrices = true;
    this._animationPropertiesOverride = null;
    this.onBeforeComputeObservable = new Observable();
    this.bones = [];
    this._scene = scene || EngineStore.LastCreatedScene;
    this._uniqueId = this._scene.getUniqueId();
    this._scene.addSkeleton(this);
    this._isDirty = true;
    const engineCaps = this._scene.getEngine().getCaps();
    this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "Skeleton";
  }
  /**
   * Returns an array containing the root bones
   * @returns an array containing the root bones
   */
  getChildren() {
    return this.bones.filter((b) => !b.getParent());
  }
  // Members
  /**
   * Gets the list of transform matrices to send to shaders (one matrix per bone)
   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
   * @returns a Float32Array containing matrices data
   */
  getTransformMatrices(mesh) {
    if (this.needInitialSkinMatrix) {
      if (!mesh) {
        throw new Error("getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided");
      }
      if (!mesh._bonesTransformMatrices) {
        this.prepare(true);
      }
      return mesh._bonesTransformMatrices;
    }
    if (!this._transformMatrices || this._isDirty) {
      this.prepare(!this._transformMatrices);
    }
    return this._transformMatrices;
  }
  /**
   * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)
   * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)
   * @returns a raw texture containing the data
   */
  getTransformMatrixTexture(mesh) {
    if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
      return mesh._transformMatrixTexture;
    }
    return this._transformMatrixTexture;
  }
  /**
   * Gets the current hosting scene
   * @returns a scene object
   */
  getScene() {
    return this._scene;
  }
  // Methods
  /**
   * Gets a string representing the current skeleton data
   * @param fullDetails defines a boolean indicating if we want a verbose version
   * @returns a string representing the current skeleton data
   */
  toString(fullDetails) {
    let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;
    ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : "none"}`;
    if (fullDetails) {
      ret += ", Ranges: {";
      let first = true;
      for (const name50 in this._ranges) {
        if (first) {
          ret += ", ";
          first = false;
        }
        ret += name50;
      }
      ret += "}";
    }
    return ret;
  }
  /**
   * Get bone's index searching by name
   * @param name defines bone's name to search for
   * @returns the indice of the bone. Returns -1 if not found
   */
  getBoneIndexByName(name50) {
    for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
      if (this.bones[boneIndex].name === name50) {
        return boneIndex;
      }
    }
    return -1;
  }
  /**
   * Create a new animation range
   * @param name defines the name of the range
   * @param from defines the start key
   * @param to defines the end key
   */
  createAnimationRange(name50, from, to) {
    if (!this._ranges[name50]) {
      this._ranges[name50] = new AnimationRange(name50, from, to);
      for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
        if (this.bones[i].animations[0]) {
          this.bones[i].animations[0].createRange(name50, from, to);
        }
      }
    }
  }
  /**
   * Delete a specific animation range
   * @param name defines the name of the range
   * @param deleteFrames defines if frames must be removed as well
   */
  deleteAnimationRange(name50, deleteFrames = true) {
    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
      if (this.bones[i].animations[0]) {
        this.bones[i].animations[0].deleteRange(name50, deleteFrames);
      }
    }
    this._ranges[name50] = null;
  }
  /**
   * Gets a specific animation range
   * @param name defines the name of the range to look for
   * @returns the requested animation range or null if not found
   */
  getAnimationRange(name50) {
    return this._ranges[name50] || null;
  }
  /**
   * Gets the list of all animation ranges defined on this skeleton
   * @returns an array
   */
  getAnimationRanges() {
    const animationRanges = [];
    let name50;
    for (name50 in this._ranges) {
      animationRanges.push(this._ranges[name50]);
    }
    return animationRanges;
  }
  /**
   * Copy animation range from a source skeleton.
   * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
   * @param source defines the source skeleton
   * @param name defines the name of the range to copy
   * @param rescaleAsRequired defines if rescaling must be applied if required
   * @returns true if operation was successful
   */
  copyAnimationRange(source, name50, rescaleAsRequired = false) {
    if (this._ranges[name50] || !source.getAnimationRange(name50)) {
      return false;
    }
    let ret = true;
    const frameOffset = this._getHighestAnimationFrame() + 1;
    const boneDict = {};
    const sourceBones = source.bones;
    let nBones;
    let i;
    for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
      boneDict[sourceBones[i].name] = sourceBones[i];
    }
    if (this.bones.length !== sourceBones.length) {
      Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);
      ret = false;
    }
    const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
    for (i = 0, nBones = this.bones.length; i < nBones; i++) {
      const boneName = this.bones[i].name;
      const sourceBone = boneDict[boneName];
      if (sourceBone) {
        ret = ret && this.bones[i].copyAnimationRange(sourceBone, name50, frameOffset, rescaleAsRequired, skelDimensionsRatio);
      } else {
        Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
        ret = false;
      }
    }
    const range = source.getAnimationRange(name50);
    if (range) {
      this._ranges[name50] = new AnimationRange(name50, range.from + frameOffset, range.to + frameOffset);
    }
    return ret;
  }
  /**
   * Forces the skeleton to go to rest pose
   */
  returnToRest() {
    for (const bone of this.bones) {
      if (bone._index !== -1) {
        bone.returnToRest();
      }
    }
  }
  _getHighestAnimationFrame() {
    let ret = 0;
    for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
      if (this.bones[i].animations[0]) {
        const highest = this.bones[i].animations[0].getHighestFrame();
        if (ret < highest) {
          ret = highest;
        }
      }
    }
    return ret;
  }
  /**
   * Begin a specific animation range
   * @param name defines the name of the range to start
   * @param loop defines if looping must be turned on (false by default)
   * @param speedRatio defines the speed ratio to apply (1 by default)
   * @param onAnimationEnd defines a callback which will be called when animation will end
   * @returns a new animatable
   */
  beginAnimation(name50, loop, speedRatio, onAnimationEnd) {
    const range = this.getAnimationRange(name50);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  }
  /**
   * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.
   * @param skeleton defines the Skeleton containing the animation range to convert
   * @param referenceFrame defines the frame that keyframes in the range will be relative to
   * @param range defines the name of the AnimationRange belonging to the Skeleton to convert
   * @returns the original skeleton
   */
  static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {
    const rangeValue = skeleton.getAnimationRange(range);
    if (!rangeValue) {
      return null;
    }
    const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
    let rangeAnimatable = null;
    for (let index = 0; index < sceneAnimatables.length; index++) {
      const sceneAnimatable = sceneAnimatables[index];
      if (sceneAnimatable.fromFrame === (rangeValue == null ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue == null ? void 0 : rangeValue.to)) {
        rangeAnimatable = sceneAnimatable;
        break;
      }
    }
    const animatables = skeleton.getAnimatables();
    for (let index = 0; index < animatables.length; index++) {
      const animatable = animatables[index];
      const animations = animatable.animations;
      if (!animations) {
        continue;
      }
      for (let animIndex = 0; animIndex < animations.length; animIndex++) {
        Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
      }
    }
    if (rangeAnimatable) {
      rangeAnimatable.isAdditive = true;
    }
    return skeleton;
  }
  /** @internal */
  _markAsDirty() {
    this._isDirty = true;
    this._absoluteTransformIsDirty = true;
  }
  /**
   * @internal
   */
  _registerMeshWithPoseMatrix(mesh) {
    this._meshesWithPoseMatrix.push(mesh);
  }
  /**
   * @internal
   */
  _unregisterMeshWithPoseMatrix(mesh) {
    const index = this._meshesWithPoseMatrix.indexOf(mesh);
    if (index > -1) {
      this._meshesWithPoseMatrix.splice(index, 1);
    }
  }
  _computeTransformMatrices(targetMatrix, initialSkinMatrix) {
    this.onBeforeComputeObservable.notifyObservers(this);
    for (let index = 0; index < this.bones.length; index++) {
      const bone = this.bones[index];
      bone._childUpdateId++;
      const parentBone = bone.getParent();
      if (parentBone) {
        bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());
      } else {
        if (initialSkinMatrix) {
          bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());
        } else {
          bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());
        }
      }
      if (bone._index !== -1) {
        const mappedIndex = bone._index === null ? index : bone._index;
        bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);
      }
    }
    this._identity.copyToArray(targetMatrix, this.bones.length * 16);
  }
  /**
   * Build all resources required to render a skeleton
   * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)
   */
  prepare(dontCheckFrameId = false) {
    if (!dontCheckFrameId) {
      const currentRenderId = this.getScene().getRenderId();
      if (this._currentRenderId === currentRenderId) {
        return;
      }
      this._currentRenderId = currentRenderId;
    }
    if (this._numBonesWithLinkedTransformNode > 0) {
      for (const bone of this.bones) {
        if (bone._linkedTransformNode) {
          const node = bone._linkedTransformNode;
          bone.position = node.position;
          if (node.rotationQuaternion) {
            bone.rotationQuaternion = node.rotationQuaternion;
          } else {
            bone.rotation = node.rotation;
          }
          bone.scaling = node.scaling;
        }
      }
    }
    if (this.needInitialSkinMatrix) {
      for (const mesh of this._meshesWithPoseMatrix) {
        const poseMatrix = mesh.getPoseMatrix();
        let needsUpdate = this._isDirty;
        if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
          mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
          needsUpdate = true;
        }
        if (!needsUpdate) {
          continue;
        }
        if (this._synchronizedWithMesh !== mesh) {
          this._synchronizedWithMesh = mesh;
          for (const bone of this.bones) {
            if (!bone.getParent()) {
              const matrix = bone.getBindMatrix();
              matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
              bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);
            }
          }
          if (this.isUsingTextureForMatrices) {
            const textureWidth = (this.bones.length + 1) * 4;
            if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
              if (mesh._transformMatrixTexture) {
                mesh._transformMatrixTexture.dispose();
              }
              mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
        }
        this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
        if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
          mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
        }
      }
    } else {
      if (!this._isDirty) {
        return;
      }
      if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
        this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
        if (this.isUsingTextureForMatrices) {
          if (this._transformMatrixTexture) {
            this._transformMatrixTexture.dispose();
          }
          this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
        }
      }
      this._computeTransformMatrices(this._transformMatrices, null);
      if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
        this._transformMatrixTexture.update(this._transformMatrices);
      }
    }
    this._isDirty = false;
  }
  /**
   * Gets the list of animatables currently running for this skeleton
   * @returns an array of animatables
   */
  getAnimatables() {
    if (!this._animatables || this._animatables.length !== this.bones.length) {
      this._animatables = [];
      for (let index = 0; index < this.bones.length; index++) {
        this._animatables.push(this.bones[index]);
      }
    }
    return this._animatables;
  }
  /**
   * Clone the current skeleton
   * @param name defines the name of the new skeleton
   * @param id defines the id of the new skeleton
   * @returns the new skeleton
   */
  clone(name50, id) {
    const result = new _Skeleton(name50, id || name50, this._scene);
    result.needInitialSkinMatrix = this.needInitialSkinMatrix;
    for (let index = 0; index < this.bones.length; index++) {
      const source = this.bones[index];
      let parentBone = null;
      const parent = source.getParent();
      if (parent) {
        const parentIndex = this.bones.indexOf(parent);
        parentBone = result.bones[parentIndex];
      }
      const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());
      bone._index = source._index;
      if (source._linkedTransformNode) {
        bone.linkTransformNode(source._linkedTransformNode);
      }
      DeepCopier.DeepCopy(source.animations, bone.animations);
    }
    if (this._ranges) {
      result._ranges = {};
      for (const rangeName in this._ranges) {
        const range = this._ranges[rangeName];
        if (range) {
          result._ranges[rangeName] = range.clone();
        }
      }
    }
    this._isDirty = true;
    result.prepare(true);
    return result;
  }
  /**
   * Enable animation blending for this skeleton
   * @param blendingSpeed defines the blending speed to apply
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending
   */
  enableBlending(blendingSpeed = 0.01) {
    this.bones.forEach((bone) => {
      bone.animations.forEach((animation) => {
        animation.enableBlending = true;
        animation.blendingSpeed = blendingSpeed;
      });
    });
  }
  /**
   * Releases all resources associated with the current skeleton
   */
  dispose() {
    this._meshesWithPoseMatrix.length = 0;
    this.getScene().stopAnimation(this);
    this.getScene().removeSkeleton(this);
    if (this._parentContainer) {
      const index = this._parentContainer.skeletons.indexOf(this);
      if (index > -1) {
        this._parentContainer.skeletons.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
  }
  /**
   * Serialize the skeleton in a JSON object
   * @returns a JSON object
   */
  serialize() {
    var _a;
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    if (this.dimensionsAtRest) {
      serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
    }
    serializationObject.bones = [];
    serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
    for (let index = 0; index < this.bones.length; index++) {
      const bone = this.bones[index];
      const parent = bone.getParent();
      const serializedBone = {
        parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,
        index: bone.getIndex(),
        name: bone.name,
        id: bone.id,
        matrix: bone.getBindMatrix().asArray(),
        rest: bone.getRestMatrix().asArray(),
        linkedTransformNodeId: (_a = bone.getTransformNode()) == null ? void 0 : _a.id
      };
      serializationObject.bones.push(serializedBone);
      if (bone.length) {
        serializedBone.length = bone.length;
      }
      if (bone.metadata) {
        serializedBone.metadata = bone.metadata;
      }
      if (bone.animations && bone.animations.length > 0) {
        serializedBone.animation = bone.animations[0].serialize();
      }
      serializationObject.ranges = [];
      for (const name50 in this._ranges) {
        const source = this._ranges[name50];
        if (!source) {
          continue;
        }
        const range = {};
        range.name = name50;
        range.from = source.from;
        range.to = source.to;
        serializationObject.ranges.push(range);
      }
    }
    return serializationObject;
  }
  /**
   * Creates a new skeleton from serialized data
   * @param parsedSkeleton defines the serialized data
   * @param scene defines the hosting scene
   * @returns a new skeleton
   */
  static Parse(parsedSkeleton, scene) {
    const skeleton = new _Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);
    if (parsedSkeleton.dimensionsAtRest) {
      skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
    }
    skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
    let index;
    for (index = 0; index < parsedSkeleton.bones.length; index++) {
      const parsedBone = parsedSkeleton.bones[index];
      const parsedBoneIndex = parsedSkeleton.bones[index].index;
      let parentBone = null;
      if (parsedBone.parentBoneIndex > -1) {
        parentBone = skeleton.bones[parsedBone.parentBoneIndex];
      }
      const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
      const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
      if (parsedBone.id !== void 0 && parsedBone.id !== null) {
        bone.id = parsedBone.id;
      }
      if (parsedBone.length) {
        bone.length = parsedBone.length;
      }
      if (parsedBone.metadata) {
        bone.metadata = parsedBone.metadata;
      }
      if (parsedBone.animation) {
        bone.animations.push(Animation.Parse(parsedBone.animation));
      }
      if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
        skeleton._hasWaitingData = true;
        bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
      }
    }
    if (parsedSkeleton.ranges) {
      for (index = 0; index < parsedSkeleton.ranges.length; index++) {
        const data = parsedSkeleton.ranges[index];
        skeleton.createAnimationRange(data.name, data.from, data.to);
      }
    }
    return skeleton;
  }
  /**
   * Compute all node absolute matrices
   * @param forceUpdate defines if computation must be done even if cache is up to date
   */
  computeAbsoluteMatrices(forceUpdate = false) {
    if (this._absoluteTransformIsDirty || forceUpdate) {
      this.bones[0].computeAbsoluteMatrices();
      this._absoluteTransformIsDirty = false;
    }
  }
  /**
   * Compute all node absolute matrices
   * @param forceUpdate defines if computation must be done even if cache is up to date
   * @deprecated Please use computeAbsoluteMatrices instead
   */
  computeAbsoluteTransforms(forceUpdate = false) {
    this.computeAbsoluteMatrices(forceUpdate);
  }
  /**
   * Gets the root pose matrix
   * @returns a matrix
   */
  getPoseMatrix() {
    let poseMatrix = null;
    if (this._meshesWithPoseMatrix.length > 0) {
      poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
    }
    return poseMatrix;
  }
  /**
   * Sorts bones per internal index
   */
  sortBones() {
    const bones = [];
    const visited = new Array(this.bones.length);
    for (let index = 0; index < this.bones.length; index++) {
      this._sortBones(index, bones, visited);
    }
    this.bones = bones;
  }
  _sortBones(index, bones, visited) {
    if (visited[index]) {
      return;
    }
    visited[index] = true;
    const bone = this.bones[index];
    if (!bone)
      return;
    if (bone._index === void 0) {
      bone._index = index;
    }
    const parentBone = bone.getParent();
    if (parentBone) {
      this._sortBones(this.bones.indexOf(parentBone), bones, visited);
    }
    bones.push(bone);
  }
  /**
   * Set the current local matrix as the restPose for all bones in the skeleton.
   */
  setCurrentPoseAsRest() {
    this.bones.forEach((b) => {
      b.setCurrentPoseAsRest();
    });
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput = class {
  constructor() {
    this.wheelPrecisionX = 3;
    this.wheelPrecisionY = 3;
    this.wheelPrecisionZ = 3;
    this.onChangedObservable = new Observable();
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
    this._ffMultiplier = 12;
    this._normalize = 120;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls
   *   should call preventdefault().
   *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this._wheel = (pointer) => {
      if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
        return;
      }
      const event = pointer.event;
      const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1;
      this._wheelDeltaX += this.wheelPrecisionX * platformScale * event.deltaX / this._normalize;
      this._wheelDeltaY -= this.wheelPrecisionY * platformScale * event.deltaY / this._normalize;
      this._wheelDeltaZ += this.wheelPrecisionZ * platformScale * event.deltaZ / this._normalize;
      if (event.preventDefault) {
        if (!noPreventDefault) {
          event.preventDefault();
        }
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      this._observer = null;
      this._wheel = null;
    }
    if (this.onChangedObservable) {
      this.onChangedObservable.clear();
    }
  }
  /**
   * Called for each rendered frame.
   */
  checkInputs() {
    this.onChangedObservable.notifyObservers({
      wheelDeltaX: this._wheelDeltaX,
      wheelDeltaY: this._wheelDeltaY,
      wheelDeltaZ: this._wheelDeltaZ
    });
    this._wheelDeltaX = 0;
    this._wheelDeltaY = 0;
    this._wheelDeltaZ = 0;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "BaseCameraMouseWheelInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mousewheel";
  }
};
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionX", void 0);
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionY", void 0);
__decorate([
  serialize()
], BaseCameraMouseWheelInput.prototype, "wheelPrecisionZ", void 0);

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes = {};
var CameraInputsManager = class {
  /**
   * Instantiate a new Camera Input Manager.
   * @param camera Defines the camera the input manager belongs to
   */
  constructor(camera) {
    this.attachedToElement = false;
    this.attached = {};
    this.camera = camera;
    this.checkInputs = () => {
    };
  }
  /**
   * Add an input method to a camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param input Camera input method
   */
  add(input) {
    const type = input.getSimpleName();
    if (this.attached[type]) {
      Logger.Warn("camera input of type " + type + " already exists on camera");
      return;
    }
    this.attached[type] = input;
    input.camera = this.camera;
    if (input.checkInputs) {
      this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
    }
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Remove a specific input method from a camera
   * example: camera.inputs.remove(camera.inputs.attached.mouse);
   * @param inputToRemove camera input method
   */
  remove(inputToRemove) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input === inputToRemove) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
        return;
      }
    }
  }
  /**
   * Remove a specific input type from a camera
   * example: camera.inputs.remove("ArcRotateCameraGamepadInput");
   * @param inputType the type of the input to remove
   */
  removeByType(inputType) {
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.getClassName() === inputType) {
        input.detachControl();
        input.camera = null;
        delete this.attached[cam];
        this.rebuildInputCheck();
      }
    }
  }
  _addCheckInputs(fn) {
    const current = this.checkInputs;
    return () => {
      current();
      fn();
    };
  }
  /**
   * Attach the input controls to the currently attached dom element to listen the events from.
   * @param input Defines the input to attach
   */
  attachInput(input) {
    if (this.attachedToElement) {
      input.attachControl(this.noPreventDefault);
    }
  }
  /**
   * Attach the current manager inputs controls to a specific dom element to listen the events from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachElement(noPreventDefault = false) {
    if (this.attachedToElement) {
      return;
    }
    noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
    this.attachedToElement = true;
    this.noPreventDefault = noPreventDefault;
    for (const cam in this.attached) {
      this.attached[cam].attachControl(noPreventDefault);
    }
  }
  /**
   * Detach the current manager inputs controls from a specific dom element.
   * @param disconnect Defines whether the input should be removed from the current list of attached inputs
   */
  detachElement(disconnect = false) {
    for (const cam in this.attached) {
      this.attached[cam].detachControl();
      if (disconnect) {
        this.attached[cam].camera = null;
      }
    }
    this.attachedToElement = false;
  }
  /**
   * Rebuild the dynamic inputCheck function from the current list of
   * defined inputs in the manager.
   */
  rebuildInputCheck() {
    this.checkInputs = () => {
    };
    for (const cam in this.attached) {
      const input = this.attached[cam];
      if (input.checkInputs) {
        this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
      }
    }
  }
  /**
   * Remove all attached input methods from a camera
   */
  clear() {
    if (this.attachedToElement) {
      this.detachElement(true);
    }
    this.attached = {};
    this.attachedToElement = false;
    this.checkInputs = () => {
    };
  }
  /**
   * Serialize the current input manager attached to a camera.
   * This ensures than once parsed,
   * the input associated to the camera will be identical to the current ones
   * @param serializedCamera Defines the camera serialization JSON the input serialization should write to
   */
  serialize(serializedCamera) {
    const inputs = {};
    for (const cam in this.attached) {
      const input = this.attached[cam];
      const res = SerializationHelper.Serialize(input);
      inputs[input.getClassName()] = res;
    }
    serializedCamera.inputsmgr = inputs;
  }
  /**
   * Parses an input manager serialized JSON to restore the previous list of inputs
   * and states associated to a camera.
   * @param parsedCamera Defines the JSON to parse
   */
  parse(parsedCamera) {
    const parsedInputs = parsedCamera.inputsmgr;
    if (parsedInputs) {
      this.clear();
      for (const n in parsedInputs) {
        const construct = CameraInputTypes[n];
        if (construct) {
          const parsedinput = parsedInputs[n];
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedinput, null);
          this.add(input);
        }
      }
    } else {
      for (const n in this.attached) {
        const construct = CameraInputTypes[this.attached[n].getClassName()];
        if (construct) {
          const input = SerializationHelper.Parse(() => {
            return new construct();
          }, parsedCamera, null);
          this.remove(this.attached[n]);
          this.add(input);
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput = class {
  constructor() {
    this.keysUp = [38];
    this.keysUpward = [33];
    this.keysDown = [40];
    this.keysDownward = [34];
    this.keysLeft = [37];
    this.keysRight = [39];
    this.rotationSpeed = 0.5;
    this.keysRotateLeft = [];
    this.keysRotateRight = [];
    this.keysRotateUp = [];
    this.keysRotateDown = [];
    this._keys = new Array();
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    if (this._onCanvasBlurObserver) {
      return;
    }
    this._scene = this.camera.getScene();
    this._engine = this._scene.getEngine();
    this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
      this._keys.length = 0;
    });
    this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
      const evt = info.event;
      if (!evt.metaKey) {
        if (info.type === KeyboardEventTypes.KEYDOWN) {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index === -1) {
              this._keys.push(evt.keyCode);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        } else {
          if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
            const index = this._keys.indexOf(evt.keyCode);
            if (index >= 0) {
              this._keys.splice(index, 1);
            }
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        }
      }
    });
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._scene) {
      if (this._onKeyboardObserver) {
        this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
      }
      if (this._onCanvasBlurObserver) {
        this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
      }
      this._onKeyboardObserver = null;
      this._onCanvasBlurObserver = null;
    }
    this._keys.length = 0;
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this._onKeyboardObserver) {
      const camera = this.camera;
      for (let index = 0; index < this._keys.length; index++) {
        const keyCode = this._keys[index];
        const speed = camera._computeLocalCameraSpeed();
        if (this.keysLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(-speed, 0, 0);
        } else if (this.keysUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, speed);
        } else if (this.keysRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(speed, 0, 0);
        } else if (this.keysDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, -speed);
        } else if (this.keysUpward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, speed, 0);
        } else if (this.keysDownward.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, -speed, 0);
        } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.y -= this._getLocalRotation();
        } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.y += this._getLocalRotation();
        } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.x -= this._getLocalRotation();
        } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {
          camera._localDirection.copyFromFloats(0, 0, 0);
          camera.cameraRotation.x += this._getLocalRotation();
        }
        if (camera.getScene().useRightHandedSystem) {
          camera._localDirection.z *= -1;
        }
        camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
        Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
        camera.cameraDirection.addInPlace(camera._transformedDirection);
      }
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraKeyboardMoveInput";
  }
  /** @internal */
  _onLostFocus() {
    this._keys.length = 0;
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "keyboard";
  }
  _getLocalRotation() {
    const handednessMultiplier = this.camera._calculateHandednessMultiplier();
    const rotation = this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * handednessMultiplier;
    return rotation;
  }
};
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysUp", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysUpward", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysDown", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysDownward", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRight", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "rotationSpeed", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateLeft", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateRight", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateUp", void 0);
__decorate([
  serialize()
], FreeCameraKeyboardMoveInput.prototype, "keysRotateDown", void 0);
CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput = class {
  /**
   * Manage the mouse inputs to control the movement of a free camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param touchEnabled Defines if touch is enabled or not
   */
  constructor(touchEnabled = true) {
    this.touchEnabled = touchEnabled;
    this.buttons = [0, 1, 2];
    this.angularSensibility = 2e3;
    this._previousPosition = null;
    this.onPointerMovedObservable = new Observable();
    this._allowCameraRotation = true;
    this._currentActiveButton = -1;
    this._activePointerId = -1;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    const engine = this.camera.getEngine();
    const element = engine.getInputElement();
    if (!this._pointerInput) {
      this._pointerInput = (p) => {
        const evt = p.event;
        const isTouch = evt.pointerType === "touch";
        if (!this.touchEnabled && isTouch) {
          return;
        }
        if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
          return;
        }
        const srcElement = evt.target;
        if (p.type === PointerEventTypes.POINTERDOWN) {
          if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {
            return;
          }
          this._activePointerId = evt.pointerId;
          try {
            srcElement == null ? void 0 : srcElement.setPointerCapture(evt.pointerId);
          } catch (e) {
          }
          if (this._currentActiveButton === -1) {
            this._currentActiveButton = evt.button;
          }
          this._previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
          if (!noPreventDefault) {
            evt.preventDefault();
            element && element.focus();
          }
          if (engine.isPointerLock && this._onMouseMove) {
            this._onMouseMove(p.event);
          }
        } else if (p.type === PointerEventTypes.POINTERUP) {
          if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {
            return;
          }
          try {
            srcElement == null ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
          } catch (e) {
          }
          this._currentActiveButton = -1;
          this._previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          this._activePointerId = -1;
        } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {
          if (engine.isPointerLock && this._onMouseMove) {
            this._onMouseMove(p.event);
          } else if (this._previousPosition) {
            const handednessMultiplier = this.camera._calculateHandednessMultiplier();
            const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;
            const offsetY = evt.clientY - this._previousPosition.y;
            if (this._allowCameraRotation) {
              this.camera.cameraRotation.y += offsetX / this.angularSensibility;
              this.camera.cameraRotation.x += offsetY / this.angularSensibility;
            }
            this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
            this._previousPosition = {
              x: evt.clientX,
              y: evt.clientY
            };
            if (!noPreventDefault) {
              evt.preventDefault();
            }
          }
        }
      };
    }
    this._onMouseMove = (evt) => {
      if (!engine.isPointerLock) {
        return;
      }
      const handednessMultiplier = this.camera._calculateHandednessMultiplier();
      const offsetX = evt.movementX * handednessMultiplier;
      this.camera.cameraRotation.y += offsetX / this.angularSensibility;
      const offsetY = evt.movementY;
      this.camera.cameraRotation.x += offsetY / this.angularSensibility;
      this._previousPosition = null;
      if (!noPreventDefault) {
        evt.preventDefault();
      }
    };
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    if (element) {
      this._contextMenuBind = (evt) => this.onContextMenu(evt);
      element.addEventListener("contextmenu", this._contextMenuBind, false);
    }
  }
  /**
   * Called on JS contextmenu event.
   * Override this method to provide functionality.
   * @param evt the context menu event
   */
  onContextMenu(evt) {
    evt.preventDefault();
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._observer) {
      this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
      if (this._contextMenuBind) {
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        element && element.removeEventListener("contextmenu", this._contextMenuBind);
      }
      if (this.onPointerMovedObservable) {
        this.onPointerMovedObservable.clear();
      }
      this._observer = null;
      this._onMouseMove = null;
      this._previousPosition = null;
    }
    this._activePointerId = -1;
    this._currentActiveButton = -1;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraMouseInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "mouse";
  }
};
__decorate([
  serialize()
], FreeCameraMouseInput.prototype, "buttons", void 0);
__decorate([
  serialize()
], FreeCameraMouseInput.prototype, "angularSensibility", void 0);
CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty;
(function(_CameraProperty2) {
  _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
  _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
  _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
})(_CameraProperty || (_CameraProperty = {}));
var FreeCameraMouseWheelInput = class extends BaseCameraMouseWheelInput {
  constructor() {
    super(...arguments);
    this._moveRelative = Vector3.Zero();
    this._rotateRelative = Vector3.Zero();
    this._moveScene = Vector3.Zero();
    this._wheelXAction = _CameraProperty.MoveRelative;
    this._wheelXActionCoordinate = Coordinate.X;
    this._wheelYAction = _CameraProperty.MoveRelative;
    this._wheelYActionCoordinate = Coordinate.Z;
    this._wheelZAction = null;
    this._wheelZActionCoordinate = null;
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraMouseWheelInput";
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's X axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXMoveRelative(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelXAction = _CameraProperty.MoveRelative;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXMoveRelative() {
    if (this._wheelXAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's Y axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYMoveRelative(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelYAction = _CameraProperty.MoveRelative;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYMoveRelative() {
    if (this._wheelYAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which movement axis (relative to camera's orientation) the mouse
   * wheel's Z axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZMoveRelative(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
      return;
    }
    this._wheelZAction = _CameraProperty.MoveRelative;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to camera's orientation) the
   * mouse wheel's Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZMoveRelative() {
    if (this._wheelZAction !== _CameraProperty.MoveRelative) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's X axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXRotateRelative(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelXAction = _CameraProperty.RotateRelative;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXRotateRelative() {
    if (this._wheelXAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's Y axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYRotateRelative(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelYAction = _CameraProperty.RotateRelative;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYRotateRelative() {
    if (this._wheelYAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which rotation axis (relative to camera's orientation) the mouse
   * wheel's Z axis controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZRotateRelative(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
      return;
    }
    this._wheelZAction = _CameraProperty.RotateRelative;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured rotation axis (relative to camera's orientation) the
   * mouse wheel's Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZRotateRelative() {
    if (this._wheelZAction !== _CameraProperty.RotateRelative) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's X axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelXMoveScene(axis) {
    if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelXAction = _CameraProperty.MoveScene;
    this._wheelXActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * X axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelXMoveScene() {
    if (this._wheelXAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelXActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's Y axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelYMoveScene(axis) {
    if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelYAction = _CameraProperty.MoveScene;
    this._wheelYActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * Y axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelYMoveScene() {
    if (this._wheelYAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelYActionCoordinate;
  }
  /**
   * Set which movement axis (relative to the scene) the mouse wheel's Z axis
   * controls.
   * @param axis The axis to be moved. Set null to clear.
   */
  set wheelZMoveScene(axis) {
    if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
      return;
    }
    this._wheelZAction = _CameraProperty.MoveScene;
    this._wheelZActionCoordinate = axis;
  }
  /**
   * Get the configured movement axis (relative to the scene) the mouse wheel's
   * Z axis controls.
   * @returns The configured axis or null if none.
   */
  get wheelZMoveScene() {
    if (this._wheelZAction !== _CameraProperty.MoveScene) {
      return null;
    }
    return this._wheelZActionCoordinate;
  }
  /**
   * Called for each rendered frame.
   */
  checkInputs() {
    if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
      return;
    }
    this._moveRelative.setAll(0);
    this._rotateRelative.setAll(0);
    this._moveScene.setAll(0);
    this._updateCamera();
    if (this.camera.getScene().useRightHandedSystem) {
      this._moveRelative.z *= -1;
    }
    const cameraTransformMatrix = Matrix.Zero();
    this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
    const transformedDirection = Vector3.Zero();
    Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
    this.camera.cameraRotation.x += this._rotateRelative.x / 200;
    this.camera.cameraRotation.y += this._rotateRelative.y / 200;
    this.camera.cameraDirection.addInPlace(transformedDirection);
    this.camera.cameraDirection.addInPlace(this._moveScene);
    super.checkInputs();
  }
  /**
   * Update the camera according to any configured properties for the 3
   * mouse-wheel axis.
   */
  _updateCamera() {
    this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
    this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
    this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
  }
  /**
   * Update one property of the camera.
   * @param value
   * @param cameraProperty
   * @param coordinate
   */
  _updateCameraProperty(value, cameraProperty, coordinate) {
    if (value === 0) {
      return;
    }
    if (cameraProperty === null || coordinate === null) {
      return;
    }
    let action = null;
    switch (cameraProperty) {
      case _CameraProperty.MoveRelative:
        action = this._moveRelative;
        break;
      case _CameraProperty.RotateRelative:
        action = this._rotateRelative;
        break;
      case _CameraProperty.MoveScene:
        action = this._moveScene;
        break;
    }
    switch (coordinate) {
      case Coordinate.X:
        action.set(value, 0, 0);
        break;
      case Coordinate.Y:
        action.set(0, value, 0);
        break;
      case Coordinate.Z:
        action.set(0, 0, value);
        break;
    }
  }
};
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZMoveRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZRotateRelative", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelXMoveScene", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelYMoveScene", null);
__decorate([
  serialize()
], FreeCameraMouseWheelInput.prototype, "wheelZMoveScene", null);
CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput = class {
  /**
   * Manage the touch inputs to control the movement of a free camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs
   * @param allowMouse Defines if mouse events can be treated as touch events
   */
  constructor(allowMouse = false) {
    this.allowMouse = allowMouse;
    this.touchAngularSensibility = 2e5;
    this.touchMoveSensibility = 250;
    this.singleFingerRotate = false;
    this._offsetX = null;
    this._offsetY = null;
    this._pointerPressed = new Array();
    this._isSafari = Tools.IsSafari();
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    let previousPosition = null;
    if (this._pointerInput === void 0) {
      this._onLostFocus = () => {
        this._offsetX = null;
        this._offsetY = null;
      };
      this._pointerInput = (p) => {
        const evt = p.event;
        const isMouseEvent = evt.pointerType === "mouse" || this._isSafari && typeof evt.pointerType === "undefined";
        if (!this.allowMouse && isMouseEvent) {
          return;
        }
        if (p.type === PointerEventTypes.POINTERDOWN) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          this._pointerPressed.push(evt.pointerId);
          if (this._pointerPressed.length !== 1) {
            return;
          }
          previousPosition = {
            x: evt.clientX,
            y: evt.clientY
          };
        } else if (p.type === PointerEventTypes.POINTERUP) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          const index = this._pointerPressed.indexOf(evt.pointerId);
          if (index === -1) {
            return;
          }
          this._pointerPressed.splice(index, 1);
          if (index != 0) {
            return;
          }
          previousPosition = null;
          this._offsetX = null;
          this._offsetY = null;
        } else if (p.type === PointerEventTypes.POINTERMOVE) {
          if (!noPreventDefault) {
            evt.preventDefault();
          }
          if (!previousPosition) {
            return;
          }
          const index = this._pointerPressed.indexOf(evt.pointerId);
          if (index != 0) {
            return;
          }
          this._offsetX = evt.clientX - previousPosition.x;
          this._offsetY = -(evt.clientY - previousPosition.y);
        }
      };
    }
    this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
    if (this._onLostFocus) {
      const engine = this.camera.getEngine();
      const element = engine.getInputElement();
      element && element.addEventListener("blur", this._onLostFocus);
    }
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    if (this._pointerInput) {
      if (this._observer) {
        this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
        this._observer = null;
      }
      if (this._onLostFocus) {
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        element && element.removeEventListener("blur", this._onLostFocus);
        this._onLostFocus = null;
      }
      this._pointerPressed.length = 0;
      this._offsetX = null;
      this._offsetY = null;
    }
  }
  /**
   * Update the current camera state depending on the inputs that have been used this frame.
   * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.
   */
  checkInputs() {
    if (this._offsetX === null || this._offsetY === null) {
      return;
    }
    if (this._offsetX === 0 && this._offsetY === 0) {
      return;
    }
    const camera = this.camera;
    const handednessMultiplier = camera._calculateHandednessMultiplier();
    camera.cameraRotation.y = handednessMultiplier * this._offsetX / this.touchAngularSensibility;
    const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;
    if (rotateCamera) {
      camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
    } else {
      const speed = camera._computeLocalCameraSpeed();
      const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);
      Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
      camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
    }
  }
  /**
   * Gets the class name of the current input.
   * @returns the class name
   */
  getClassName() {
    return "FreeCameraTouchInput";
  }
  /**
   * Get the friendly name associated with the input class.
   * @returns the input friendly name
   */
  getSimpleName() {
    return "touch";
  }
};
__decorate([
  serialize()
], FreeCameraTouchInput.prototype, "touchAngularSensibility", void 0);
__decorate([
  serialize()
], FreeCameraTouchInput.prototype, "touchMoveSensibility", void 0);
CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;

// node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager = class extends CameraInputsManager {
  /**
   * Instantiates a new FreeCameraInputsManager.
   * @param camera Defines the camera the inputs belong to
   */
  constructor(camera) {
    super(camera);
    this._mouseInput = null;
    this._mouseWheelInput = null;
  }
  /**
   * Add keyboard input support to the input manager.
   * @returns the current input manager
   */
  addKeyboard() {
    this.add(new FreeCameraKeyboardMoveInput());
    return this;
  }
  /**
   * Add mouse input support to the input manager.
   * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)
   * @returns the current input manager
   */
  addMouse(touchEnabled = true) {
    if (!this._mouseInput) {
      this._mouseInput = new FreeCameraMouseInput(touchEnabled);
      this.add(this._mouseInput);
    }
    return this;
  }
  /**
   * Removes the mouse input support from the manager
   * @returns the current input manager
   */
  removeMouse() {
    if (this._mouseInput) {
      this.remove(this._mouseInput);
    }
    return this;
  }
  /**
   * Add mouse wheel input support to the input manager.
   * @returns the current input manager
   */
  addMouseWheel() {
    if (!this._mouseWheelInput) {
      this._mouseWheelInput = new FreeCameraMouseWheelInput();
      this.add(this._mouseWheelInput);
    }
    return this;
  }
  /**
   * Removes the mouse wheel input support from the manager
   * @returns the current input manager
   */
  removeMouseWheel() {
    if (this._mouseWheelInput) {
      this.remove(this._mouseWheelInput);
    }
    return this;
  }
  /**
   * Add touch input support to the input manager.
   * @returns the current input manager
   */
  addTouch() {
    this.add(new FreeCameraTouchInput());
    return this;
  }
  /**
   * Remove all attached input methods from a camera
   */
  clear() {
    super.clear();
    this._mouseInput = null;
  }
};

// node_modules/@babylonjs/core/Cameras/targetCamera.js
Node.AddNodeConstructor("TargetCamera", (name50, scene) => {
  return () => new TargetCamera(name50, Vector3.Zero(), scene);
});
var TargetCamera = class _TargetCamera extends Camera {
  /**
   * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.
   * This is the base of the follow, arc rotate cameras and Free camera
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the start position of the camera in the scene
   * @param scene Defines the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name50, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name50, position, scene, setActiveOnSceneIfNoneActive);
    this._tmpUpVector = Vector3.Zero();
    this._tmpTargetVector = Vector3.Zero();
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
    this.ignoreParentScaling = false;
    this.updateUpVectorFromRotation = false;
    this._tmpQuaternion = new Quaternion();
    this.rotation = new Vector3(0, 0, 0);
    this.speed = 2;
    this.noRotationConstraint = false;
    this.invertRotation = false;
    this.inverseRotationSpeed = 0.2;
    this.lockedTarget = null;
    this._currentTarget = Vector3.Zero();
    this._initialFocalDistance = 1;
    this._viewMatrix = Matrix.Zero();
    this._camMatrix = Matrix.Zero();
    this._cameraTransformMatrix = Matrix.Zero();
    this._cameraRotationMatrix = Matrix.Zero();
    this._referencePoint = new Vector3(0, 0, 1);
    this._transformedReferencePoint = Vector3.Zero();
    this._deferredPositionUpdate = new Vector3();
    this._deferredRotationQuaternionUpdate = new Quaternion();
    this._deferredRotationUpdate = new Vector3();
    this._deferredUpdated = false;
    this._deferOnly = false;
    this._defaultUp = Vector3.Up();
    this._cachedRotationZ = 0;
    this._cachedQuaternionRotationZ = 0;
  }
  /**
   * Gets the position in front of the camera at a given distance.
   * @param distance The distance from the camera we want the position to be
   * @returns the position
   */
  getFrontPosition(distance) {
    this.getWorldMatrix();
    const direction = this.getTarget().subtract(this.position);
    direction.normalize();
    direction.scaleInPlace(distance);
    return this.globalPosition.add(direction);
  }
  /** @internal */
  _getLockedTargetPosition() {
    if (!this.lockedTarget) {
      return null;
    }
    if (this.lockedTarget.absolutePosition) {
      const lockedTarget = this.lockedTarget;
      const m = lockedTarget.computeWorldMatrix();
      m.getTranslationToRef(lockedTarget.absolutePosition);
    }
    return this.lockedTarget.absolutePosition || this.lockedTarget;
  }
  /**
   * Store current camera state of the camera (fov, position, rotation, etc..)
   * @returns the camera
   */
  storeState() {
    this._storedPosition = this.position.clone();
    this._storedRotation = this.rotation.clone();
    if (this.rotationQuaternion) {
      this._storedRotationQuaternion = this.rotationQuaternion.clone();
    }
    return super.storeState();
  }
  /**
   * Restored camera state. You must call storeState() first
   * @returns whether it was successful or not
   * @internal
   */
  _restoreStateValues() {
    if (!super._restoreStateValues()) {
      return false;
    }
    this.position = this._storedPosition.clone();
    this.rotation = this._storedRotation.clone();
    if (this.rotationQuaternion) {
      this.rotationQuaternion = this._storedRotationQuaternion.clone();
    }
    this.cameraDirection.copyFromFloats(0, 0, 0);
    this.cameraRotation.copyFromFloats(0, 0);
    return true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    if (!lockedTargetPosition) {
      this._cache.lockedTarget = null;
    } else {
      if (!this._cache.lockedTarget) {
        this._cache.lockedTarget = lockedTargetPosition.clone();
      } else {
        this._cache.lockedTarget.copyFrom(lockedTargetPosition);
      }
    }
    this._cache.rotation.copyFrom(this.rotation);
    if (this.rotationQuaternion) {
      this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
    }
  }
  // Synchronized
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix()) {
      return false;
    }
    const lockedTargetPosition = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }
  // Methods
  /** @internal */
  _computeLocalCameraSpeed() {
    const engine = this.getEngine();
    return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
  }
  // Target
  /**
   * Defines the target the camera should look at.
   * @param target Defines the new target as a Vector
   */
  setTarget(target) {
    this.upVector.normalize();
    this._initialFocalDistance = target.subtract(this.position).length();
    if (this.position.z === target.z) {
      this.position.z += Epsilon;
    }
    this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
    Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
    this._camMatrix.invert();
    this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    const vDir = target.subtract(this.position);
    if (vDir.x >= 0) {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
    } else {
      this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
    }
    this.rotation.z = 0;
    if (isNaN(this.rotation.x)) {
      this.rotation.x = 0;
    }
    if (isNaN(this.rotation.y)) {
      this.rotation.y = 0;
    }
    if (isNaN(this.rotation.z)) {
      this.rotation.z = 0;
    }
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
    }
  }
  /**
   * Defines the target point of the camera.
   * The camera looks towards it form the radius distance.
   */
  get target() {
    return this.getTarget();
  }
  set target(value) {
    this.setTarget(value);
  }
  /**
   * Return the current target position of the camera. This value is expressed in local space.
   * @returns the target position
   */
  getTarget() {
    return this._currentTarget;
  }
  /** @internal */
  _decideIfNeedsToMove() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  /** @internal */
  _updatePosition() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
      this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);
      if (!this._deferOnly) {
        this.position.copyFrom(this._deferredPositionUpdate);
      } else {
        this._deferredUpdated = true;
      }
      return;
    }
    this._deferredPositionUpdate.addInPlace(this.cameraDirection);
    if (!this._deferOnly) {
      this.position.copyFrom(this._deferredPositionUpdate);
    } else {
      this._deferredUpdated = true;
    }
  }
  /** @internal */
  _checkInputs() {
    const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
    const needToMove = this._decideIfNeedsToMove();
    const needToRotate = this.cameraRotation.x || this.cameraRotation.y;
    this._deferredUpdated = false;
    this._deferredRotationUpdate.copyFrom(this.rotation);
    this._deferredPositionUpdate.copyFrom(this.position);
    if (this.rotationQuaternion) {
      this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);
    }
    if (needToMove) {
      this._updatePosition();
    }
    if (needToRotate) {
      if (this.rotationQuaternion) {
        this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);
      }
      this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;
      this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;
      if (!this.noRotationConstraint) {
        const limit = 1.570796;
        if (this._deferredRotationUpdate.x > limit) {
          this._deferredRotationUpdate.x = limit;
        }
        if (this._deferredRotationUpdate.x < -limit) {
          this._deferredRotationUpdate.x = -limit;
        }
      }
      if (!this._deferOnly) {
        this.rotation.copyFrom(this._deferredRotationUpdate);
      } else {
        this._deferredUpdated = true;
      }
      if (this.rotationQuaternion) {
        const len = this._deferredRotationUpdate.lengthSquared();
        if (len) {
          Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);
          if (!this._deferOnly) {
            this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
          } else {
            this._deferredUpdated = true;
          }
        }
      }
    }
    if (needToMove) {
      if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
        this.cameraDirection.x = 0;
      }
      if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
        this.cameraDirection.y = 0;
      }
      if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
        this.cameraDirection.z = 0;
      }
      this.cameraDirection.scaleInPlace(this.inertia);
    }
    if (needToRotate) {
      if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
        this.cameraRotation.x = 0;
      }
      if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
        this.cameraRotation.y = 0;
      }
      this.cameraRotation.scaleInPlace(this.inertia);
    }
    super._checkInputs();
  }
  _updateCameraRotationMatrix() {
    if (this.rotationQuaternion) {
      this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
    } else {
      Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
    }
  }
  /**
   * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)
   * @returns the current camera
   */
  _rotateUpVectorWithCameraRotationMatrix() {
    Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
    return this;
  }
  /** @internal */
  _getViewMatrix() {
    if (this.lockedTarget) {
      this.setTarget(this._getLockedTargetPosition());
    }
    this._updateCameraRotationMatrix();
    if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
    } else if (this._cachedRotationZ !== this.rotation.z) {
      this._rotateUpVectorWithCameraRotationMatrix();
      this._cachedRotationZ = this.rotation.z;
    }
    Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
    this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
    if (this.updateUpVectorFromRotation) {
      if (this.rotationQuaternion) {
        Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
      } else {
        Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
        Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
      }
    }
    this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
    return this._viewMatrix;
  }
  _computeViewMatrix(position, target, up) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        const parentWorldMatrix = this.parent.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
        Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
        Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
        this._markSyncedWithParent();
      } else {
        this._globalPosition.copyFrom(position);
        this._tmpTargetVector.copyFrom(target);
        this._tmpUpVector.copyFrom(up);
      }
      if (this.getScene().useRightHandedSystem) {
        Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      } else {
        Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      }
      return;
    }
    if (this.getScene().useRightHandedSystem) {
      Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
    } else {
      Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
    }
    if (this.parent) {
      const parentWorldMatrix = this.parent.getWorldMatrix();
      this._viewMatrix.invert();
      this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
      this._viewMatrix.getTranslationToRef(this._globalPosition);
      this._viewMatrix.invert();
      this._markSyncedWithParent();
    } else {
      this._globalPosition.copyFrom(position);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name50, cameraIndex) {
    if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
      const rigCamera = new _TargetCamera(name50, this.position.clone(), this.getScene());
      rigCamera.isRigCamera = true;
      rigCamera.rigParent = this;
      if (this.cameraRigMode === Camera.RIG_MODE_VR) {
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = new Quaternion();
        }
        rigCamera._cameraRigParams = {};
        rigCamera.rotationQuaternion = new Quaternion();
      }
      rigCamera.mode = this.mode;
      rigCamera.orthoLeft = this.orthoLeft;
      rigCamera.orthoRight = this.orthoRight;
      rigCamera.orthoTop = this.orthoTop;
      rigCamera.orthoBottom = this.orthoBottom;
      return rigCamera;
    }
    return null;
  }
  /**
   * @internal
   */
  _updateRigCameras() {
    const camLeft = this._rigCameras[0];
    const camRight = this._rigCameras[1];
    this.computeWorldMatrix();
    switch (this.cameraRigMode) {
      case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
        const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
        break;
      }
      case Camera.RIG_MODE_VR:
        if (camLeft.rotationQuaternion) {
          camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
          camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
        } else {
          camLeft.rotation.copyFrom(this.rotation);
          camRight.rotation.copyFrom(this.rotation);
        }
        camLeft.position.copyFrom(this.position);
        camRight.position.copyFrom(this.position);
        break;
    }
    super._updateRigCameras();
  }
  _getRigCamPositionAndTarget(halfSpace, rigCamera) {
    const target = this.getTarget();
    target.subtractToRef(this.position, _TargetCamera._TargetFocalPoint);
    _TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    const newFocalTarget = _TargetCamera._TargetFocalPoint.addInPlace(this.position);
    Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), _TargetCamera._RigCamTransformMatrix);
    Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, _TargetCamera._TargetTransformMatrix);
    _TargetCamera._RigCamTransformMatrix.multiplyToRef(_TargetCamera._TargetTransformMatrix, _TargetCamera._RigCamTransformMatrix);
    Vector3.TransformCoordinatesToRef(this.position, _TargetCamera._RigCamTransformMatrix, rigCamera.position);
    rigCamera.setTarget(newFocalTarget);
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "TargetCamera";
  }
};
TargetCamera._RigCamTransformMatrix = new Matrix();
TargetCamera._TargetTransformMatrix = new Matrix();
TargetCamera._TargetFocalPoint = new Vector3();
__decorate([
  serializeAsVector3()
], TargetCamera.prototype, "rotation", void 0);
__decorate([
  serialize()
], TargetCamera.prototype, "speed", void 0);
__decorate([
  serializeAsMeshReference("lockedTargetId")
], TargetCamera.prototype, "lockedTarget", void 0);

// node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera = class extends TargetCamera {
  /**
   * Gets the input sensibility for a mouse input. (default is 2000.0)
   * Higher values reduce sensitivity.
   */
  get angularSensibility() {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      return mouse.angularSensibility;
    }
    return 0;
  }
  /**
   * Sets the input sensibility for a mouse input. (default is 2000.0)
   * Higher values reduce sensitivity.
   */
  set angularSensibility(value) {
    const mouse = this.inputs.attached["mouse"];
    if (mouse) {
      mouse.angularSensibility = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the forward move of the camera.
   */
  get keysUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUp;
    }
    return [];
  }
  set keysUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the upward move of the camera.
   */
  get keysUpward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysUpward;
    }
    return [];
  }
  set keysUpward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysUpward = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the backward move of the camera.
   */
  get keysDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDown;
    }
    return [];
  }
  set keysDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDown = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the downward move of the camera.
   */
  get keysDownward() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysDownward;
    }
    return [];
  }
  set keysDownward(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysDownward = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.
   */
  get keysLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysLeft;
    }
    return [];
  }
  set keysLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.
   */
  get keysRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRight;
    }
    return [];
  }
  set keysRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRight = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.
   */
  get keysRotateLeft() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateLeft;
    }
    return [];
  }
  set keysRotateLeft(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateLeft = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.
   */
  get keysRotateRight() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateRight;
    }
    return [];
  }
  set keysRotateRight(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateRight = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.
   */
  get keysRotateUp() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateUp;
    }
    return [];
  }
  set keysRotateUp(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateUp = value;
    }
  }
  /**
   * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.
   */
  get keysRotateDown() {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      return keyboard.keysRotateDown;
    }
    return [];
  }
  set keysRotateDown(value) {
    const keyboard = this.inputs.attached["keyboard"];
    if (keyboard) {
      keyboard.keysRotateDown = value;
    }
  }
  /**
   * Instantiates a Free Camera.
   * This represents a free type of camera. It can be useful in First Person Shooter game for instance.
   * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera
   * @param name Define the name of the camera in the scene
   * @param position Define the start position of the camera in the scene
   * @param scene Define the scene the camera belongs to
   * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined
   */
  constructor(name50, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name50, position, scene, setActiveOnSceneIfNoneActive);
    this.ellipsoid = new Vector3(0.5, 1, 0.5);
    this.ellipsoidOffset = new Vector3(0, 0, 0);
    this.checkCollisions = false;
    this.applyGravity = false;
    this._needMoveForGravity = false;
    this._oldPosition = Vector3.Zero();
    this._diffPosition = Vector3.Zero();
    this._newPosition = Vector3.Zero();
    this._collisionMask = -1;
    this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
      this._newPosition.copyFrom(newPosition);
      this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
      if (this._diffPosition.length() > Engine.CollisionsEpsilon) {
        this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);
        if (!this._deferOnly) {
          this.position.copyFrom(this._deferredPositionUpdate);
        } else {
          this._deferredUpdated = true;
        }
        if (this.onCollide && collidedMesh) {
          this.onCollide(collidedMesh);
        }
      }
    };
    this.inputs = new FreeCameraInputsManager(this);
    this.inputs.addKeyboard().addMouse();
  }
  /**
   * Attached controls to the current camera.
   * @param ignored defines an ignored parameter kept for backward compatibility.
   * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(ignored, noPreventDefault) {
    noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
    this.inputs.attachElement(noPreventDefault);
  }
  /**
   * Detach the current controls from the specified dom element.
   */
  detachControl() {
    this.inputs.detachElement();
    this.cameraDirection = new Vector3(0, 0, 0);
    this.cameraRotation = new Vector2(0, 0);
  }
  /**
   * Define a collision mask to limit the list of object the camera can collide with
   */
  get collisionMask() {
    return this._collisionMask;
  }
  set collisionMask(mask) {
    this._collisionMask = !isNaN(mask) ? mask : -1;
  }
  /**
   * @internal
   */
  _collideWithWorld(displacement) {
    let globalPosition;
    if (this.parent) {
      globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
    } else {
      globalPosition = this.position;
    }
    globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
    this._oldPosition.addInPlace(this.ellipsoidOffset);
    const coordinator = this.getScene().collisionCoordinator;
    if (!this._collider) {
      this._collider = coordinator.createCollider();
    }
    this._collider._radius = this.ellipsoid;
    this._collider.collisionMask = this._collisionMask;
    let actualDisplacement = displacement;
    if (this.applyGravity) {
      actualDisplacement = displacement.add(this.getScene().gravity);
    }
    coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
  }
  /** @internal */
  _checkInputs() {
    if (!this._localDirection) {
      this._localDirection = Vector3.Zero();
      this._transformedDirection = Vector3.Zero();
    }
    this.inputs.checkInputs();
    super._checkInputs();
  }
  /**
   * Enable movement without a user input. This allows gravity to always be applied.
   */
  set needMoveForGravity(value) {
    this._needMoveForGravity = value;
  }
  /**
   * When true, gravity is applied whether there is user input or not.
   */
  get needMoveForGravity() {
    return this._needMoveForGravity;
  }
  /** @internal */
  _decideIfNeedsToMove() {
    return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  /** @internal */
  _updatePosition() {
    if (this.checkCollisions && this.getScene().collisionsEnabled) {
      this._collideWithWorld(this.cameraDirection);
    } else {
      super._updatePosition();
    }
  }
  /**
   * Destroy the camera and release the current resources hold by it.
   */
  dispose() {
    this.inputs.clear();
    super.dispose();
  }
  /**
   * Gets the current object class name.
   * @returns the class name
   */
  getClassName() {
    return "FreeCamera";
  }
};
__decorate([
  serializeAsVector3()
], FreeCamera.prototype, "ellipsoid", void 0);
__decorate([
  serializeAsVector3()
], FreeCamera.prototype, "ellipsoidOffset", void 0);
__decorate([
  serialize()
], FreeCamera.prototype, "checkCollisions", void 0);
__decorate([
  serialize()
], FreeCamera.prototype, "applyGravity", void 0);
RegisterClass("BABYLON.FreeCamera", FreeCamera);

// node_modules/@babylonjs/core/Shaders/passCube.fragment.js
var name = "passCubePixelShader";
var shader = `varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;
ShaderStore.ShadersStore[name] = shader;

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess = class _PassPostProcess extends PostProcess {
  /**
   * Gets a string identifying the name of the class
   * @returns "PassPostProcess" string
   */
  getClassName() {
    return "PassPostProcess";
  }
  /**
   * Creates the PassPostProcess
   * @param name The name of the effect.
   * @param options The required width/height ratio to downsize to before computing the render pass.
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType The type of texture to be used when performing the post processing.
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   */
  constructor(name50, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name50, "pass", null, null, options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation);
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _PassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
RegisterClass("BABYLON.PassPostProcess", PassPostProcess);
var PassCubePostProcess = class _PassCubePostProcess extends PostProcess {
  /**
   * Gets or sets the cube face to display.
   *  * 0 is +X
   *  * 1 is -X
   *  * 2 is +Y
   *  * 3 is -Y
   *  * 4 is +Z
   *  * 5 is -Z
   */
  get face() {
    return this._face;
  }
  set face(value) {
    if (value < 0 || value > 5) {
      return;
    }
    this._face = value;
    switch (this._face) {
      case 0:
        this.updateEffect("#define POSITIVEX");
        break;
      case 1:
        this.updateEffect("#define NEGATIVEX");
        break;
      case 2:
        this.updateEffect("#define POSITIVEY");
        break;
      case 3:
        this.updateEffect("#define NEGATIVEY");
        break;
      case 4:
        this.updateEffect("#define POSITIVEZ");
        break;
      case 5:
        this.updateEffect("#define NEGATIVEZ");
        break;
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "PassCubePostProcess" string
   */
  getClassName() {
    return "PassCubePostProcess";
  }
  /**
   * Creates the PassCubePostProcess
   * @param name The name of the effect.
   * @param options The required width/height ratio to downsize to before computing the render pass.
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType The type of texture to be used when performing the post processing.
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   */
  constructor(name50, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    super(name50, "passCube", null, null, options, camera, samplingMode, engine, reusable, "#define POSITIVEX", textureType, void 0, null, blockCompilation);
    this._face = 0;
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _PassCubePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
AbstractEngine._RescalePostProcessFactory = (engine) => {
  return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
};

// node_modules/@babylonjs/core/Maths/sphericalPolynomial.js
var SH3ylmBasisConstants = [
  Math.sqrt(1 / (4 * Math.PI)),
  -Math.sqrt(3 / (4 * Math.PI)),
  Math.sqrt(3 / (4 * Math.PI)),
  -Math.sqrt(3 / (4 * Math.PI)),
  Math.sqrt(15 / (4 * Math.PI)),
  -Math.sqrt(15 / (4 * Math.PI)),
  Math.sqrt(5 / (16 * Math.PI)),
  -Math.sqrt(15 / (4 * Math.PI)),
  Math.sqrt(15 / (16 * Math.PI))
  // l22
];
var SH3ylmBasisTrigonometricTerms = [
  () => 1,
  (direction) => direction.y,
  (direction) => direction.z,
  (direction) => direction.x,
  (direction) => direction.x * direction.y,
  (direction) => direction.y * direction.z,
  (direction) => 3 * direction.z * direction.z - 1,
  (direction) => direction.x * direction.z,
  (direction) => direction.x * direction.x - direction.y * direction.y
  // l22
];
var applySH3 = (lm, direction) => {
  return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);
};
var SHCosKernelConvolution = [Math.PI, 2 * Math.PI / 3, 2 * Math.PI / 3, 2 * Math.PI / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];
var SphericalHarmonics = class _SphericalHarmonics {
  constructor() {
    this.preScaled = false;
    this.l00 = Vector3.Zero();
    this.l1_1 = Vector3.Zero();
    this.l10 = Vector3.Zero();
    this.l11 = Vector3.Zero();
    this.l2_2 = Vector3.Zero();
    this.l2_1 = Vector3.Zero();
    this.l20 = Vector3.Zero();
    this.l21 = Vector3.Zero();
    this.l22 = Vector3.Zero();
  }
  /**
   * Adds a light to the spherical harmonics
   * @param direction the direction of the light
   * @param color the color of the light
   * @param deltaSolidAngle the delta solid angle of the light
   */
  addLight(direction, color, deltaSolidAngle) {
    TmpVectors.Vector3[0].set(color.r, color.g, color.b);
    const colorVector = TmpVectors.Vector3[0];
    const c = TmpVectors.Vector3[1];
    colorVector.scaleToRef(deltaSolidAngle, c);
    c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);
    this.l00.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);
    this.l1_1.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);
    this.l10.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);
    this.l11.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);
    this.l2_2.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);
    this.l2_1.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);
    this.l20.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);
    this.l21.addInPlace(TmpVectors.Vector3[2]);
    c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);
    this.l22.addInPlace(TmpVectors.Vector3[2]);
  }
  /**
   * Scales the spherical harmonics by the given amount
   * @param scale the amount to scale
   */
  scaleInPlace(scale) {
    this.l00.scaleInPlace(scale);
    this.l1_1.scaleInPlace(scale);
    this.l10.scaleInPlace(scale);
    this.l11.scaleInPlace(scale);
    this.l2_2.scaleInPlace(scale);
    this.l2_1.scaleInPlace(scale);
    this.l20.scaleInPlace(scale);
    this.l21.scaleInPlace(scale);
    this.l22.scaleInPlace(scale);
  }
  /**
   * Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.
   *
   * ```
   * E_lm = A_l * L_lm
   * ```
   *
   * In spherical harmonics this convolution amounts to scaling factors for each frequency band.
   * This corresponds to equation 5 in "An Efficient Representation for Irradiance Environment Maps", where
   * the scaling factors are given in equation 9.
   */
  convertIncidentRadianceToIrradiance() {
    this.l00.scaleInPlace(SHCosKernelConvolution[0]);
    this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);
    this.l10.scaleInPlace(SHCosKernelConvolution[2]);
    this.l11.scaleInPlace(SHCosKernelConvolution[3]);
    this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);
    this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);
    this.l20.scaleInPlace(SHCosKernelConvolution[6]);
    this.l21.scaleInPlace(SHCosKernelConvolution[7]);
    this.l22.scaleInPlace(SHCosKernelConvolution[8]);
  }
  /**
   * Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.
   *
   * ```
   * L = (1/pi) * E * rho
   * ```
   *
   * This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.
   */
  convertIrradianceToLambertianRadiance() {
    this.scaleInPlace(1 / Math.PI);
  }
  /**
   * Integrates the reconstruction coefficients directly in to the SH preventing further
   * required operations at run time.
   *
   * This is simply done by scaling back the SH with Ylm constants parameter.
   * The trigonometric part being applied by the shader at run time.
   */
  preScaleForRendering() {
    this.preScaled = true;
    this.l00.scaleInPlace(SH3ylmBasisConstants[0]);
    this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);
    this.l10.scaleInPlace(SH3ylmBasisConstants[2]);
    this.l11.scaleInPlace(SH3ylmBasisConstants[3]);
    this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);
    this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);
    this.l20.scaleInPlace(SH3ylmBasisConstants[6]);
    this.l21.scaleInPlace(SH3ylmBasisConstants[7]);
    this.l22.scaleInPlace(SH3ylmBasisConstants[8]);
  }
  /**
   * update the spherical harmonics coefficients from the given array
   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
   * @returns the spherical harmonics (this)
   */
  updateFromArray(data) {
    Vector3.FromArrayToRef(data[0], 0, this.l00);
    Vector3.FromArrayToRef(data[1], 0, this.l1_1);
    Vector3.FromArrayToRef(data[2], 0, this.l10);
    Vector3.FromArrayToRef(data[3], 0, this.l11);
    Vector3.FromArrayToRef(data[4], 0, this.l2_2);
    Vector3.FromArrayToRef(data[5], 0, this.l2_1);
    Vector3.FromArrayToRef(data[6], 0, this.l20);
    Vector3.FromArrayToRef(data[7], 0, this.l21);
    Vector3.FromArrayToRef(data[8], 0, this.l22);
    return this;
  }
  /**
   * update the spherical harmonics coefficients from the given floats array
   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
   * @returns the spherical harmonics (this)
   */
  updateFromFloatsArray(data) {
    Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);
    Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);
    Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);
    Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);
    Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);
    Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);
    Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);
    Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);
    Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);
    return this;
  }
  /**
   * Constructs a spherical harmonics from an array.
   * @param data defines the 9x3 coefficients (l00, l1-1, l10, l11, l2-2, l2-1, l20, l21, l22)
   * @returns the spherical harmonics
   */
  static FromArray(data) {
    const sh = new _SphericalHarmonics();
    return sh.updateFromArray(data);
  }
  // Keep for references.
  /**
   * Gets the spherical harmonics from polynomial
   * @param polynomial the spherical polynomial
   * @returns the spherical harmonics
   */
  static FromPolynomial(polynomial) {
    const result = new _SphericalHarmonics();
    result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));
    result.l1_1 = polynomial.y.scale(0.977204);
    result.l10 = polynomial.z.scale(0.977204);
    result.l11 = polynomial.x.scale(0.977204);
    result.l2_2 = polynomial.xy.scale(1.16538);
    result.l2_1 = polynomial.yz.scale(1.16538);
    result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));
    result.l21 = polynomial.zx.scale(1.16538);
    result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));
    result.l1_1.scaleInPlace(-1);
    result.l11.scaleInPlace(-1);
    result.l2_1.scaleInPlace(-1);
    result.l21.scaleInPlace(-1);
    result.scaleInPlace(Math.PI);
    return result;
  }
};
var SphericalPolynomial = class _SphericalPolynomial {
  constructor() {
    this.x = Vector3.Zero();
    this.y = Vector3.Zero();
    this.z = Vector3.Zero();
    this.xx = Vector3.Zero();
    this.yy = Vector3.Zero();
    this.zz = Vector3.Zero();
    this.xy = Vector3.Zero();
    this.yz = Vector3.Zero();
    this.zx = Vector3.Zero();
  }
  /**
   * The spherical harmonics used to create the polynomials.
   */
  get preScaledHarmonics() {
    if (!this._harmonics) {
      this._harmonics = SphericalHarmonics.FromPolynomial(this);
    }
    if (!this._harmonics.preScaled) {
      this._harmonics.preScaleForRendering();
    }
    return this._harmonics;
  }
  /**
   * Adds an ambient color to the spherical polynomial
   * @param color the color to add
   */
  addAmbient(color) {
    TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);
    const colorVector = TmpVectors.Vector3[0];
    this.xx.addInPlace(colorVector);
    this.yy.addInPlace(colorVector);
    this.zz.addInPlace(colorVector);
  }
  /**
   * Scales the spherical polynomial by the given amount
   * @param scale the amount to scale
   */
  scaleInPlace(scale) {
    this.x.scaleInPlace(scale);
    this.y.scaleInPlace(scale);
    this.z.scaleInPlace(scale);
    this.xx.scaleInPlace(scale);
    this.yy.scaleInPlace(scale);
    this.zz.scaleInPlace(scale);
    this.yz.scaleInPlace(scale);
    this.zx.scaleInPlace(scale);
    this.xy.scaleInPlace(scale);
  }
  /**
   * Updates the spherical polynomial from harmonics
   * @param harmonics the spherical harmonics
   * @returns the spherical polynomial
   */
  updateFromHarmonics(harmonics) {
    this._harmonics = harmonics;
    this.x.copyFrom(harmonics.l11);
    this.x.scaleInPlace(1.02333).scaleInPlace(-1);
    this.y.copyFrom(harmonics.l1_1);
    this.y.scaleInPlace(1.02333).scaleInPlace(-1);
    this.z.copyFrom(harmonics.l10);
    this.z.scaleInPlace(1.02333);
    this.xx.copyFrom(harmonics.l00);
    TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);
    TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);
    this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);
    this.yy.copyFrom(harmonics.l00);
    this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);
    this.zz.copyFrom(harmonics.l00);
    TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);
    this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);
    this.yz.copyFrom(harmonics.l2_1);
    this.yz.scaleInPlace(0.858086).scaleInPlace(-1);
    this.zx.copyFrom(harmonics.l21);
    this.zx.scaleInPlace(0.858086).scaleInPlace(-1);
    this.xy.copyFrom(harmonics.l2_2);
    this.xy.scaleInPlace(0.858086);
    this.scaleInPlace(1 / Math.PI);
    return this;
  }
  /**
   * Gets the spherical polynomial from harmonics
   * @param harmonics the spherical harmonics
   * @returns the spherical polynomial
   */
  static FromHarmonics(harmonics) {
    const result = new _SphericalPolynomial();
    return result.updateFromHarmonics(harmonics);
  }
  /**
   * Constructs a spherical polynomial from an array.
   * @param data defines the 9x3 coefficients (x, y, z, xx, yy, zz, yz, zx, xy)
   * @returns the spherical polynomial
   */
  static FromArray(data) {
    const sp = new _SphericalPolynomial();
    Vector3.FromArrayToRef(data[0], 0, sp.x);
    Vector3.FromArrayToRef(data[1], 0, sp.y);
    Vector3.FromArrayToRef(data[2], 0, sp.z);
    Vector3.FromArrayToRef(data[3], 0, sp.xx);
    Vector3.FromArrayToRef(data[4], 0, sp.yy);
    Vector3.FromArrayToRef(data[5], 0, sp.zz);
    Vector3.FromArrayToRef(data[6], 0, sp.yz);
    Vector3.FromArrayToRef(data[7], 0, sp.zx);
    Vector3.FromArrayToRef(data[8], 0, sp.xy);
    return sp;
  }
};

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation = class {
  constructor(name50, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
    this.name = name50;
    this.worldAxisForNormal = worldAxisForNormal;
    this.worldAxisForFileX = worldAxisForFileX;
    this.worldAxisForFileY = worldAxisForFileY;
  }
};
var CubeMapToSphericalPolynomialTools = class {
  /**
   * Converts a texture to the according Spherical Polynomial data.
   * This extracts the first 3 orders only as they are the only one used in the lighting.
   *
   * @param texture The texture to extract the information from.
   * @returns The Spherical Polynomial data.
   */
  static ConvertCubeMapTextureToSphericalPolynomial(texture) {
    var _a;
    if (!texture.isCube) {
      return null;
    }
    (_a = texture.getScene()) == null ? void 0 : _a.getEngine().flushFramebuffer();
    const size = texture.getSize().width;
    const rightPromise = texture.readPixels(0, void 0, void 0, false);
    const leftPromise = texture.readPixels(1, void 0, void 0, false);
    let upPromise;
    let downPromise;
    if (texture.isRenderTarget) {
      upPromise = texture.readPixels(3, void 0, void 0, false);
      downPromise = texture.readPixels(2, void 0, void 0, false);
    } else {
      upPromise = texture.readPixels(2, void 0, void 0, false);
      downPromise = texture.readPixels(3, void 0, void 0, false);
    }
    const frontPromise = texture.readPixels(4, void 0, void 0, false);
    const backPromise = texture.readPixels(5, void 0, void 0, false);
    const gammaSpace = texture.gammaSpace;
    const format = 5;
    let type = 0;
    if (texture.textureType == 1 || texture.textureType == 2) {
      type = 1;
    }
    return new Promise((resolve) => {
      Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {
        const cubeInfo = {
          size,
          right,
          left,
          up,
          down,
          front,
          back,
          format,
          type,
          gammaSpace
        };
        resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
      });
    });
  }
  /**
   * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin
   * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/
   * @param x
   * @param y
   * @returns the area
   */
  static _AreaElement(x, y) {
    return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
  }
  /**
   * Converts a cubemap to the according Spherical Polynomial data.
   * This extracts the first 3 orders only as they are the only one used in the lighting.
   *
   * @param cubeInfo The Cube map to extract the information from.
   * @returns The Spherical Polynomial data.
   */
  static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
    const sphericalHarmonics = new SphericalHarmonics();
    let totalSolidAngle = 0;
    const du = 2 / cubeInfo.size;
    const dv = du;
    const halfTexel = 0.5 * du;
    const minUV = halfTexel - 1;
    for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
      const fileFace = this._FileFaces[faceIndex];
      const dataArray = cubeInfo[fileFace.name];
      let v = minUV;
      const stride = cubeInfo.format === 5 ? 4 : 3;
      for (let y = 0; y < cubeInfo.size; y++) {
        let u = minUV;
        for (let x = 0; x < cubeInfo.size; x++) {
          const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
          worldDirection.normalize();
          const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
          let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
          let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
          let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
          if (isNaN(r)) {
            r = 0;
          }
          if (isNaN(g)) {
            g = 0;
          }
          if (isNaN(b)) {
            b = 0;
          }
          if (cubeInfo.type === 0) {
            r /= 255;
            g /= 255;
            b /= 255;
          }
          if (cubeInfo.gammaSpace) {
            r = Math.pow(Scalar.Clamp(r), ToLinearSpace);
            g = Math.pow(Scalar.Clamp(g), ToLinearSpace);
            b = Math.pow(Scalar.Clamp(b), ToLinearSpace);
          }
          const max = this.MAX_HDRI_VALUE;
          if (this.PRESERVE_CLAMPED_COLORS) {
            const currentMax = Math.max(r, g, b);
            if (currentMax > max) {
              const factor = max / currentMax;
              r *= factor;
              g *= factor;
              b *= factor;
            }
          } else {
            r = Scalar.Clamp(r, 0, max);
            g = Scalar.Clamp(g, 0, max);
            b = Scalar.Clamp(b, 0, max);
          }
          const color = new Color3(r, g, b);
          sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
          totalSolidAngle += deltaSolidAngle;
          u += du;
        }
        v += dv;
      }
    }
    const sphereSolidAngle = 4 * Math.PI;
    const facesProcessed = 6;
    const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
    const correctionFactor = expectedSolidAngle / totalSolidAngle;
    sphericalHarmonics.scaleInPlace(correctionFactor);
    sphericalHarmonics.convertIncidentRadianceToIrradiance();
    sphericalHarmonics.convertIrradianceToLambertianRadiance();
    return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
  }
};
CubeMapToSphericalPolynomialTools._FileFaces = [
  new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
  new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
  new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
  new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
  new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
  new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
  // -Z bottom
];
CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;

// node_modules/@babylonjs/core/Shaders/lod.fragment.js
var name2 = "lodPixelShader";
var shader2 = `#extension GL_EXT_shader_texture_lod : enable
precision highp float;const float GammaEncodePowerApprox=1.0/2.2;varying vec2 vUV;uniform sampler2D textureSampler;uniform float lod;uniform vec2 texSize;uniform bool gamma;void main(void)
{gl_FragColor=textureLod(textureSampler,vUV,lod);if (!gamma) {gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(GammaEncodePowerApprox));}}
`;
ShaderStore.ShadersStore[name2] = shader2;

// node_modules/@babylonjs/core/Shaders/lodCube.fragment.js
var name3 = "lodCubePixelShader";
var shader3 = `precision highp float;const float GammaEncodePowerApprox=1.0/2.2;varying vec2 vUV;uniform samplerCube textureSampler;uniform float lod;uniform bool gamma;void main(void)
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x),lod);
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x),lod);
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x),lod);
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x),lod);
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001),lod);
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001),lod);
#endif
if (!gamma) {gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(GammaEncodePowerApprox));}}
`;
ShaderStore.ShadersStore[name3] = shader3;

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  const rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  const passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.getEffect().executeWhenCompiled(() => {
    passPostProcess.onApply = function(effect) {
      effect.setTexture("textureSampler", texture);
    };
    const internalTexture = rtt.renderTarget;
    if (internalTexture) {
      scene.postProcessManager.directRender([passPostProcess], internalTexture);
      engine.unBindFramebuffer(internalTexture);
      rtt.disposeFramebufferObjects();
      passPostProcess.dispose();
      rtt.getInternalTexture().isReady = true;
    }
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
  const engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode ?? internalTexture.samplingMode;
  type = type ?? internalTexture.type;
  format = format ?? internalTexture.format;
  width = width ?? internalTexture.width;
  height = height ?? internalTexture.height;
  if (type === -1) {
    type = 0;
  }
  return new Promise((resolve) => {
    const postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    const encodedTexture = engine.createRenderTargetTexture({ width, height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.getEffect().executeWhenCompiled(() => {
      postProcess.onApply = (effect) => {
        effect._bindTexture("textureSampler", internalTexture);
        effect.setFloat2("scale", 1, 1);
      };
      scene.postProcessManager.directRender([postProcess], encodedTexture, true);
      engine.restoreDefaultFramebuffer();
      engine._releaseTexture(internalTexture);
      if (postProcess) {
        postProcess.dispose();
      }
      encodedTexture._swapAndDie(internalTexture);
      internalTexture.type = type;
      internalTexture.format = 5;
      internalTexture.isReady = true;
      resolve(internalTexture);
    });
  });
}
var floatView;
var int32View;
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  const s = (value & 32768) >> 15;
  const e = (value & 31744) >> 10;
  const f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var ProcessAsync = async (texture, width, height, face, lod) => {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  let lodPostProcess;
  if (!texture.isCube) {
    lodPostProcess = new PostProcess("lod", "lod", ["lod", "gamma"], null, 1, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine);
  } else {
    const faceDefines = ["#define POSITIVEX", "#define NEGATIVEX", "#define POSITIVEY", "#define NEGATIVEY", "#define POSITIVEZ", "#define NEGATIVEZ"];
    lodPostProcess = new PostProcess("lodCube", "lodCube", ["lod", "gamma"], null, 1, null, Texture.NEAREST_NEAREST_MIPNEAREST, engine, false, faceDefines[face]);
  }
  await new Promise((resolve) => {
    lodPostProcess.getEffect().executeWhenCompiled(() => {
      resolve(0);
    });
  });
  const rtt = new RenderTargetTexture("temp", { width, height }, scene, false);
  lodPostProcess.onApply = function(effect) {
    effect.setTexture("textureSampler", texture);
    effect.setFloat("lod", lod);
    effect.setBool("gamma", texture.gammaSpace);
  };
  const internalTexture = texture.getInternalTexture();
  try {
    if (rtt.renderTarget && internalTexture) {
      const samplingMode = internalTexture.samplingMode;
      if (lod !== 0) {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);
      } else {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST);
      }
      scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);
      texture.updateSamplingMode(samplingMode);
      const bufferView = await engine.readPixels(0, 0, width, height);
      const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
      engine.unBindFramebuffer(rtt.renderTarget);
      return data;
    } else {
      throw Error("Render to texture failed.");
    }
  } finally {
    rtt.dispose();
    lodPostProcess.dispose();
  }
};
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
  if (!texture.isReady() && texture._texture) {
    await new Promise((resolve, reject) => {
      if (texture._texture === null) {
        reject(0);
        return;
      }
      texture._texture.onLoadedObservable.addOnce(() => {
        resolve(0);
      });
    });
  }
  return await ProcessAsync(texture, width, height, face, lod);
}
var TextureTools = {
  /**
   * Uses the GPU to create a copy texture rescaled at a given size
   * @param texture Texture to copy from
   * @param width defines the desired width
   * @param height defines the desired height
   * @param useBilinearMode defines if bilinear mode has to be used
   * @returns the generated texture
   */
  CreateResizedCopy,
  /**
   * Apply a post process to a texture
   * @param postProcessName name of the fragment post process
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param type type of the output texture. If not provided, use the one from internalTexture
   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
   * @param format format of the output texture. If not provided, use the one from internalTexture
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  ApplyPostProcess,
  /**
   * Converts a number to half float
   * @param value number to convert
   * @returns converted number
   */
  ToHalfFloat,
  /**
   * Converts a half float to a number
   * @param value half float to convert
   * @returns converted half float
   */
  FromHalfFloat,
  /**
   * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
   * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
   * @param texture the source texture
   * @param width the width of the result, which does not have to match the source texture width
   * @param height the height of the result, which does not have to match the source texture height
   * @param face if the texture has multiple faces, the face index to use for the source
   * @param channels a filter for which of the RGBA channels to return in the result
   * @param lod if the texture has multiple LODs, the lod index to use for the source
   * @returns the 8-bit texture data
   */
  GetTextureDataAsync
};

// node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js
AbstractEngine.prototype._partialLoadFile = function(url, index, loadedFiles, onfinish, onErrorCallBack = null) {
  const onload = (data) => {
    loadedFiles[index] = data;
    loadedFiles._internalCount++;
    if (loadedFiles._internalCount === 6) {
      onfinish(loadedFiles);
    }
  };
  const onerror = (request, exception) => {
    if (onErrorCallBack && request) {
      onErrorCallBack(request.status + " " + request.statusText, exception);
    }
  };
  this._loadFile(url, onload, void 0, void 0, true, onerror);
};
AbstractEngine.prototype._cascadeLoadFiles = function(scene, onfinish, files, onError = null) {
  const loadedFiles = [];
  loadedFiles._internalCount = 0;
  for (let index = 0; index < 6; index++) {
    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
  }
};
AbstractEngine.prototype._cascadeLoadImgs = function(scene, texture, onfinish, files, onError = null, mimeType) {
  const loadedImages = [];
  loadedImages._internalCount = 0;
  for (let index = 0; index < 6; index++) {
    this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);
  }
};
AbstractEngine.prototype._partialLoadImg = function(url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {
  const tokenPendingData = RandomGUID();
  const onload = (img) => {
    loadedImages[index] = img;
    loadedImages._internalCount++;
    if (scene) {
      scene.removePendingData(tokenPendingData);
    }
    if (loadedImages._internalCount === 6 && onfinish) {
      onfinish(texture, loadedImages);
    }
  };
  const onerror = (message, exception) => {
    if (scene) {
      scene.removePendingData(tokenPendingData);
    }
    if (onErrorCallBack) {
      onErrorCallBack(message, exception);
    }
  };
  LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
  if (scene) {
    scene.addPendingData(tokenPendingData);
  }
};
AbstractEngine.prototype.createCubeTextureBase = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false) {
  const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
  texture.isCube = true;
  texture.url = rootUrl;
  texture.generateMipMaps = !noMipmap;
  texture._lodGenerationScale = lodScale;
  texture._lodGenerationOffset = lodOffset;
  texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!noMipmap);
  if (texture !== fallback) {
    texture.label = rootUrl.substring(0, 60);
  }
  if (!this._doNotHandleContextLost) {
    texture._extension = forcedExtension;
    texture._files = files;
  }
  const originalRootUrl = rootUrl;
  if (this._transformTextureUrl && !fallback) {
    rootUrl = this._transformTextureUrl(rootUrl);
  }
  const rootUrlWithoutUriParams = rootUrl.split("?")[0];
  const lastDot = rootUrlWithoutUriParams.lastIndexOf(".");
  const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : "";
  let loader = null;
  for (const availableLoader of AbstractEngine._TextureLoaders) {
    if (availableLoader.canLoad(extension)) {
      loader = availableLoader;
      break;
    }
  }
  const onInternalError = (request, exception) => {
    if (rootUrl === originalRootUrl) {
      if (onError && request) {
        onError(request.status + " " + request.statusText, exception);
      }
    } else {
      Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);
      this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);
    }
  };
  if (loader) {
    const onloaddata = (data) => {
      if (beforeLoadCubeDataCallback) {
        beforeLoadCubeDataCallback(texture, data);
      }
      loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);
    };
    if (files && files.length === 6) {
      if (loader.supportCascades) {
        this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);
      } else {
        if (onError) {
          onError("Textures type does not support cascades.");
        } else {
          Logger.Warn("Texture loader does not support cascades.");
        }
      }
    } else {
      this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data)), void 0, void 0, true, onInternalError);
    }
  } else {
    if (!files || files.length === 0) {
      throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");
    }
    this._cascadeLoadImgs(scene, texture, (texture2, imgs) => {
      if (imageHandler) {
        imageHandler(texture2, imgs);
      }
    }, files, onError);
  }
  this._internalTexturesCache.push(texture);
  return texture;
};

// node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js
ThinEngine.prototype._createDepthStencilCubeTexture = function(size, options) {
  const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
  internalTexture.isCube = true;
  if (this.webGLVersion === 1) {
    Logger.Error("Depth cube texture is not supported by WebGL 1.");
    return internalTexture;
  }
  const internalOptions = {
    bilinearFiltering: false,
    comparisonFunction: 0,
    generateStencil: false,
    ...options
  };
  const gl = this._gl;
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);
  this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
  for (let face = 0; face < 6; face++) {
    if (internalOptions.generateStencil) {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);
    } else {
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
    }
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  this._internalTexturesCache.push(internalTexture);
  return internalTexture;
};
ThinEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap, maxLevel) {
  const gl = this._gl;
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  texture.samplingMode = loadMipmap ? 3 : 2;
  if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== void 0 && maxLevel > 0) {
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);
    texture._maxLodLevel = maxLevel;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
};
ThinEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {
  const gl = this._gl;
  return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, (texture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true), (texture, imgs) => {
    const width = this.needPOTTextures ? GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;
    const height = width;
    const faces = [
      gl.TEXTURE_CUBE_MAP_POSITIVE_X,
      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
    ];
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    this._unpackFlipY(false);
    const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;
    let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;
    if (texture._useSRGBBuffer && this.webGLVersion === 1) {
      texelFormat = internalFormat;
    }
    for (let index = 0; index < faces.length; index++) {
      if (imgs[index].width !== width || imgs[index].height !== height) {
        this._prepareWorkingCanvas();
        if (!this._workingCanvas || !this._workingContext) {
          Logger.Warn("Cannot create canvas to resize texture.");
          return;
        }
        this._workingCanvas.width = width;
        this._workingCanvas.height = height;
        this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);
        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);
      } else {
        gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);
      }
    }
    if (!noMipmap) {
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
    }
    this._setCubeMapTextureParams(texture, !noMipmap);
    texture.width = width;
    texture.height = height;
    texture.isReady = true;
    if (format) {
      texture.format = format;
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  }, !!useSRGBBuffer);
};
ThinEngine.prototype.generateMipMapsForCubemap = function(texture, unbind = true) {
  if (texture.generateMipMaps) {
    const gl = this._gl;
    this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
    if (unbind) {
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    }
  }
};

// node_modules/@babylonjs/core/Misc/dds.js
var DDS_MAGIC = 542327876;
var DDSD_MIPMAPCOUNT = 131072;
var DDSCAPS2_CUBEMAP = 512;
var DDPF_FOURCC = 4;
var DDPF_RGB = 64;
var DDPF_LUMINANCE = 131072;
function FourCCToInt32(value) {
  return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
}
function Int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}
var FOURCC_DXT1 = FourCCToInt32("DXT1");
var FOURCC_DXT3 = FourCCToInt32("DXT3");
var FOURCC_DXT5 = FourCCToInt32("DXT5");
var FOURCC_DX10 = FourCCToInt32("DX10");
var FOURCC_D3DFMT_R16G16B16A16F = 113;
var FOURCC_D3DFMT_R32G32B32A32F = 116;
var DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
var headerLengthInt = 31;
var off_magic = 0;
var off_size = 1;
var off_flags = 2;
var off_height = 3;
var off_width = 4;
var off_mipmapCount = 7;
var off_pfFlags = 20;
var off_pfFourCC = 21;
var off_RGBbpp = 22;
var off_RMask = 23;
var off_GMask = 24;
var off_BMask = 25;
var off_AMask = 26;
var off_caps2 = 28;
var off_dxgiFormat = 32;
var DDSTools = class _DDSTools {
  /**
   * Gets DDS information from an array buffer
   * @param data defines the array buffer view to read data from
   * @returns the DDS information
   */
  static GetDDSInfo(data) {
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);
    let mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const fourCC = header[off_pfFourCC];
    const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
    let textureType = 0;
    switch (fourCC) {
      case FOURCC_D3DFMT_R16G16B16A16F:
        textureType = 2;
        break;
      case FOURCC_D3DFMT_R32G32B32A32F:
        textureType = 1;
        break;
      case FOURCC_DX10:
        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {
          textureType = 2;
          break;
        }
        if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {
          textureType = 1;
          break;
        }
    }
    return {
      width: header[off_width],
      height: header[off_height],
      mipmapCount,
      isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,
      isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,
      isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,
      isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,
      isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,
      dxgiFormat,
      textureType
    };
  }
  static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Float32Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = FromHalfFloat(srcData[srcPos]);
        destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);
        destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (_DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Uint16Array(dataLength);
      const srcData = new Uint16Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = ToHalfFloat(lod);
          index += 4;
        }
      }
      return destArray;
    }
    return new Uint16Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    if (_DDSTools.StoreLODInAlphaChannel) {
      const destArray = new Float32Array(dataLength);
      const srcData = new Float32Array(arrayBuffer, dataOffset);
      let index = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const srcPos = (x + y * width) * 4;
          destArray[index] = srcData[srcPos];
          destArray[index + 1] = srcData[srcPos + 1];
          destArray[index + 2] = srcData[srcPos + 2];
          destArray[index + 3] = lod;
          index += 4;
        }
      }
      return destArray;
    }
    return new Float32Array(arrayBuffer, dataOffset, dataLength);
  }
  static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint16Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        destArray[index] = ToHalfFloat(srcData[index]);
        destArray[index + 1] = ToHalfFloat(srcData[index + 1]);
        destArray[index + 2] = ToHalfFloat(srcData[index + 2]);
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = ToHalfFloat(lod);
        } else {
          destArray[index + 3] = ToHalfFloat(srcData[index + 3]);
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Float32Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(srcData[srcPos]) * 255;
        destArray[index + 1] = Scalar.Clamp(srcData[srcPos + 1]) * 255;
        destArray[index + 2] = Scalar.Clamp(srcData[srcPos + 2]) * 255;
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(srcData[srcPos + 3]) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {
    const destArray = new Uint8Array(dataLength);
    const srcData = new Uint16Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        destArray[index] = Scalar.Clamp(FromHalfFloat(srcData[srcPos])) * 255;
        destArray[index + 1] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;
        destArray[index + 2] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;
        if (_DDSTools.StoreLODInAlphaChannel) {
          destArray[index + 3] = lod;
        } else {
          destArray[index + 3] = Scalar.Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;
        }
        index += 4;
      }
    }
    return destArray;
  }
  static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 4;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        byteArray[index + 3] = srcData[srcPos + aOffset];
        index += 4;
      }
    }
    return byteArray;
  }
  static _ExtractLongWordOrder(value) {
    if (value === 0 || value === 255 || value === -16777216) {
      return 0;
    }
    return 1 + _DDSTools._ExtractLongWordOrder(value >> 8);
  }
  static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = (x + y * width) * 3;
        byteArray[index] = srcData[srcPos + rOffset];
        byteArray[index + 1] = srcData[srcPos + gOffset];
        byteArray[index + 2] = srcData[srcPos + bOffset];
        index += 3;
      }
    }
    return byteArray;
  }
  static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {
    const byteArray = new Uint8Array(dataLength);
    const srcData = new Uint8Array(arrayBuffer, dataOffset);
    let index = 0;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const srcPos = x + y * width;
        byteArray[index] = srcData[srcPos];
        index++;
      }
    }
    return byteArray;
  }
  /**
   * Uploads DDS Levels to a Babylon Texture
   * @internal
   */
  static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {
    let sphericalPolynomialFaces = null;
    if (info.sphericalPolynomial) {
      sphericalPolynomialFaces = [];
    }
    const ext = !!engine.getCaps().s3tc;
    texture.generateMipMaps = loadMipmaps;
    const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);
    let fourCC, width, height, dataLength = 0, dataOffset;
    let byteArray, mipmapCount, mip;
    let internalCompressedFormat = 0;
    let blockBytes = 1;
    if (header[off_magic] !== DDS_MAGIC) {
      Logger.Error("Invalid magic number in DDS header");
      return;
    }
    if (!info.isFourCC && !info.isRGB && !info.isLuminance) {
      Logger.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");
      return;
    }
    if (info.isCompressed && !ext) {
      Logger.Error("Compressed textures are not supported on this platform.");
      return;
    }
    let bpp = header[off_RGBbpp];
    dataOffset = header[off_size] + 4;
    let computeFormats = false;
    if (info.isFourCC) {
      fourCC = header[off_pfFourCC];
      switch (fourCC) {
        case FOURCC_DXT1:
          blockBytes = 8;
          internalCompressedFormat = 33777;
          break;
        case FOURCC_DXT3:
          blockBytes = 16;
          internalCompressedFormat = 33778;
          break;
        case FOURCC_DXT5:
          blockBytes = 16;
          internalCompressedFormat = 33779;
          break;
        case FOURCC_D3DFMT_R16G16B16A16F:
          computeFormats = true;
          bpp = 64;
          break;
        case FOURCC_D3DFMT_R32G32B32A32F:
          computeFormats = true;
          bpp = 128;
          break;
        case FOURCC_DX10: {
          dataOffset += 5 * 4;
          let supported = false;
          switch (info.dxgiFormat) {
            case DXGI_FORMAT_R16G16B16A16_FLOAT:
              computeFormats = true;
              bpp = 64;
              supported = true;
              break;
            case DXGI_FORMAT_R32G32B32A32_FLOAT:
              computeFormats = true;
              bpp = 128;
              supported = true;
              break;
            case DXGI_FORMAT_B8G8R8X8_UNORM:
              info.isRGB = true;
              info.isFourCC = false;
              bpp = 32;
              supported = true;
              break;
          }
          if (supported) {
            break;
          }
        }
        default:
          Logger.Error(["Unsupported FourCC code:", Int32ToFourCC(fourCC)]);
          return;
      }
    }
    const rOffset = _DDSTools._ExtractLongWordOrder(header[off_RMask]);
    const gOffset = _DDSTools._ExtractLongWordOrder(header[off_GMask]);
    const bOffset = _DDSTools._ExtractLongWordOrder(header[off_BMask]);
    const aOffset = _DDSTools._ExtractLongWordOrder(header[off_AMask]);
    if (computeFormats) {
      internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);
    }
    mipmapCount = 1;
    if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
      mipmapCount = Math.max(1, header[off_mipmapCount]);
    }
    const startFace = currentFace || 0;
    const caps = engine.getCaps();
    for (let face = startFace; face < faces; face++) {
      width = header[off_width];
      height = header[off_height];
      for (mip = 0; mip < mipmapCount; ++mip) {
        if (lodIndex === -1 || lodIndex === mip) {
          const i = lodIndex === -1 ? mip : 0;
          if (!info.isCompressed && info.isFourCC) {
            texture.format = 5;
            dataLength = width * height * 4;
            let floatArray = null;
            if (engine._badOS || engine._badDesktopOS || !caps.textureHalfFloat && !caps.textureFloat) {
              if (bpp === 128) {
                floatArray = _DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(_DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              } else if (bpp === 64) {
                floatArray = _DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
                if (sphericalPolynomialFaces && i == 0) {
                  sphericalPolynomialFaces.push(_DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));
                }
              }
              texture.type = 0;
            } else {
              const floatAvailable = caps.textureFloat && (destTypeMustBeFilterable && caps.textureFloatLinearFiltering || !destTypeMustBeFilterable);
              const halfFloatAvailable = caps.textureHalfFloat && (destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering || !destTypeMustBeFilterable);
              const destType = (bpp === 128 || bpp === 64 && !halfFloatAvailable) && floatAvailable ? 1 : (bpp === 64 || bpp === 128 && !floatAvailable) && halfFloatAvailable ? 2 : 0;
              let dataGetter;
              let dataGetterPolynomial = null;
              switch (bpp) {
                case 128: {
                  switch (destType) {
                    case 1:
                      dataGetter = _DDSTools._GetFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = _DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = _DDSTools._GetFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
                default: {
                  switch (destType) {
                    case 1:
                      dataGetter = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      dataGetterPolynomial = null;
                      break;
                    case 2:
                      dataGetter = _DDSTools._GetHalfFloatRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                    case 0:
                      dataGetter = _DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;
                      dataGetterPolynomial = _DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;
                      break;
                  }
                  break;
                }
              }
              texture.type = destType;
              floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);
              if (sphericalPolynomialFaces && i == 0) {
                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);
              }
            }
            if (floatArray) {
              engine._uploadDataToTextureDirectly(texture, floatArray, face, i);
            }
          } else if (info.isRGB) {
            texture.type = 0;
            if (bpp === 24) {
              texture.format = 4;
              dataLength = width * height * 3;
              byteArray = _DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            } else {
              texture.format = 5;
              dataLength = width * height * 4;
              byteArray = _DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);
              engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
            }
          } else if (info.isLuminance) {
            const unpackAlignment = engine._getUnpackAlignement();
            const unpaddedRowSize = width;
            const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;
            dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;
            byteArray = _DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);
            texture.format = 1;
            texture.type = 0;
            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);
          } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
            byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);
            texture.type = 0;
            engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);
          }
        }
        dataOffset += bpp ? width * height * (bpp / 8) : dataLength;
        width *= 0.5;
        height *= 0.5;
        width = Math.max(1, width);
        height = Math.max(1, height);
      }
      if (currentFace !== void 0) {
        break;
      }
    }
    if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {
      info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({
        size: header[off_width],
        right: sphericalPolynomialFaces[0],
        left: sphericalPolynomialFaces[1],
        up: sphericalPolynomialFaces[2],
        down: sphericalPolynomialFaces[3],
        front: sphericalPolynomialFaces[4],
        back: sphericalPolynomialFaces[5],
        format: 5,
        type: 1,
        gammaSpace: false
      });
    } else {
      info.sphericalPolynomial = void 0;
    }
  }
};
DDSTools.StoreLODInAlphaChannel = false;

// node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js
var name4 = "rgbdDecodePixelShader";
var shader4 = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;
ShaderStore.ShadersStore[name4] = shader4;

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = class {
  /**
   * Expand the RGBD Texture from RGBD to Half Float if possible.
   * @param texture the texture to expand.
   */
  static ExpandRGBDTexture(texture) {
    const internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    const engine = internalTexture.getEngine();
    const caps = engine.getCaps();
    const isReady = internalTexture.isReady;
    let expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    const expandRGBDTexture = () => {
      const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false);
      rgbdPostProcess.externalTextureSamplerBinding = true;
      const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
        generateDepthBuffer: false,
        generateMipMaps: false,
        generateStencilBuffer: false,
        samplingMode: internalTexture.samplingMode,
        type: internalTexture.type,
        format: 5
      });
      rgbdPostProcess.getEffect().executeWhenCompiled(() => {
        rgbdPostProcess.onApply = (effect) => {
          effect._bindTexture("textureSampler", internalTexture);
          effect.setFloat2("scale", 1, 1);
        };
        texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
        engine.restoreDefaultFramebuffer();
        engine._releaseTexture(internalTexture);
        if (rgbdPostProcess) {
          rgbdPostProcess.dispose();
        }
        expandedTexture._swapAndDie(internalTexture);
        internalTexture.isReady = true;
      });
    };
    if (expandTexture) {
      if (isReady) {
        expandRGBDTexture();
      } else {
        texture.onLoadObservable.addOnce(expandRGBDTexture);
      }
    }
  }
  /**
   * Encode the texture to RGBD if possible.
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param outputTextureType type of the texture in which the encoding is performed
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
    return ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
  }
};

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
  if (this._texture) {
    this._texture._sphericalPolynomial = null;
    this._texture._sphericalPolynomialPromise = null;
    this._texture._sphericalPolynomialComputed = false;
  }
};
Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
  get: function() {
    if (this._texture) {
      if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
        return this._texture._sphericalPolynomial;
      }
      if (this._texture.isReady) {
        if (!this._texture._sphericalPolynomialPromise) {
          this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
          if (this._texture._sphericalPolynomialPromise === null) {
            this._texture._sphericalPolynomialComputed = true;
          } else {
            this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
              this._texture._sphericalPolynomial = sphericalPolynomial;
              this._texture._sphericalPolynomialComputed = true;
            });
          }
        }
        return null;
      }
    }
    return null;
  },
  set: function(value) {
    if (this._texture) {
      this._texture._sphericalPolynomial = value;
    }
  },
  enumerable: true,
  configurable: true
});

// node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js
var name5 = "rgbdEncodePixelShader";
var shader5 = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;
ShaderStore.ShadersStore[name5] = shader5;

// node_modules/@babylonjs/core/Misc/environmentTextureTools.js
var DefaultEnvironmentTextureImageType = "image/png";
var CurrentVersion = 2;
var MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54];
function GetEnvInfo(data) {
  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    if (dataView.getUint8(pos++) !== MagicBytes[i]) {
      Logger.Error("Not a babylon environment map");
      return null;
    }
  }
  let manifestString = "";
  let charCode = 0;
  while (charCode = dataView.getUint8(pos++)) {
    manifestString += String.fromCharCode(charCode);
  }
  let manifest = JSON.parse(manifestString);
  manifest = normalizeEnvInfo(manifest);
  if (manifest.specular) {
    manifest.specular.specularDataPosition = pos;
    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
  }
  return manifest;
}
function normalizeEnvInfo(info) {
  if (info.version > CurrentVersion) {
    throw new Error(`Unsupported babylon environment map version "${info.version}". Latest supported version is "${CurrentVersion}".`);
  }
  if (info.version === 2) {
    return info;
  }
  info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };
  return info;
}
async function CreateEnvTextureAsync(texture, options = {}) {
  var _a;
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return Promise.reject("The cube texture is invalid.");
  }
  const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;
  const engine = internalTexture.getEngine();
  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {
    return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
  }
  let textureType = 1;
  if (!engine.getCaps().textureFloatRender) {
    textureType = 2;
    if (!engine.getCaps().textureHalfFloatRender) {
      return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
    }
  }
  texture.sphericalPolynomial;
  const sphericalPolynomialPromise = (_a = texture.getInternalTexture()) == null ? void 0 : _a._sphericalPolynomialPromise;
  const cubeWidth = internalTexture.width;
  const hostingScene = new Scene(engine);
  const specularTextures = {};
  engine.flushFramebuffer();
  const mipmapsCount = Scalar.ILog2(internalTexture.width);
  for (let i = 0; i <= mipmapsCount; i++) {
    const faceWidth = Math.pow(2, mipmapsCount - i);
    for (let face = 0; face < 6; face++) {
      let faceData = await texture.readPixels(face, i, void 0, false);
      if (faceData && faceData.byteLength === faceData.length) {
        const faceDataFloat = new Float32Array(faceData.byteLength * 4);
        for (let i2 = 0; i2 < faceData.byteLength; i2++) {
          faceDataFloat[i2] = faceData[i2] / 255;
          faceDataFloat[i2] = Math.pow(faceDataFloat[i2], 2.2);
        }
        faceData = faceDataFloat;
      } else if (faceData && texture.gammaSpace) {
        const floatData = faceData;
        for (let i2 = 0; i2 < floatData.length; i2++) {
          floatData[i2] = Math.pow(floatData[i2], 2.2);
        }
      }
      const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);
      await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);
      const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);
      const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, void 0, false, true, options.imageQuality);
      specularTextures[i * 6 + face] = imageEncodedData;
      tempTexture.dispose();
    }
  }
  hostingScene.dispose();
  if (sphericalPolynomialPromise) {
    await sphericalPolynomialPromise;
  }
  const info = {
    version: CurrentVersion,
    width: cubeWidth,
    imageType,
    irradiance: _CreateEnvTextureIrradiance(texture),
    specular: {
      mipmaps: [],
      lodGenerationScale: texture.lodGenerationScale
    }
  };
  let position = 0;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const byteLength = specularTextures[i * 6 + face].byteLength;
      info.specular.mipmaps.push({
        length: byteLength,
        position
      });
      position += byteLength;
    }
  }
  const infoString = JSON.stringify(info);
  const infoBuffer = new ArrayBuffer(infoString.length + 1);
  const infoView = new Uint8Array(infoBuffer);
  for (let i = 0, strLen = infoString.length; i < strLen; i++) {
    infoView[i] = infoString.charCodeAt(i);
  }
  infoView[infoString.length] = 0;
  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;
  const finalBuffer = new ArrayBuffer(totalSize);
  const finalBufferView = new Uint8Array(finalBuffer);
  const dataView = new DataView(finalBuffer);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    dataView.setUint8(pos++, MagicBytes[i]);
  }
  finalBufferView.set(new Uint8Array(infoBuffer), pos);
  pos += infoBuffer.byteLength;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const dataBuffer = specularTextures[i * 6 + face];
      finalBufferView.set(new Uint8Array(dataBuffer), pos);
      pos += dataBuffer.byteLength;
    }
  }
  return finalBuffer;
}
function _CreateEnvTextureIrradiance(texture) {
  const polynmials = texture.sphericalPolynomial;
  if (polynmials == null) {
    return null;
  }
  return {
    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]
  };
}
function CreateImageDataArrayBufferViews(data, info) {
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  let mipmapsCount = Scalar.Log2(info.width);
  mipmapsCount = Math.round(mipmapsCount) + 1;
  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
    throw new Error(`Unsupported specular mipmaps number "${specularInfo.mipmaps.length}"`);
  }
  const imageData = new Array(mipmapsCount);
  for (let i = 0; i < mipmapsCount; i++) {
    imageData[i] = new Array(6);
    for (let face = 0; face < 6; face++) {
      const imageInfo = specularInfo.mipmaps[i * 6 + face];
      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);
    }
  }
  return imageData;
}
function UploadEnvLevelsAsync(texture, data, info) {
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  if (!specularInfo) {
    return Promise.resolve();
  }
  texture._lodGenerationScale = specularInfo.lodGenerationScale;
  const imageData = CreateImageDataArrayBufferViews(data, info);
  return UploadLevelsAsync(texture, imageData, info.imageType);
}
function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
  return new Promise((resolve, reject) => {
    if (expandTexture) {
      const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {
        reject(message);
      }, image);
      rgbdPostProcess.getEffect().executeWhenCompiled(() => {
        rgbdPostProcess.externalTextureSamplerBinding = true;
        rgbdPostProcess.onApply = (effect) => {
          effect._bindTexture("textureSampler", tempTexture);
          effect.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
        };
        if (!engine.scenes.length) {
          return;
        }
        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
        engine.restoreDefaultFramebuffer();
        tempTexture.dispose();
        URL.revokeObjectURL(url);
        resolve();
      });
    } else {
      engine._uploadImageToTexture(texture, image, face, i);
      if (generateNonLODTextures) {
        const lodTexture = lodTextures[i];
        if (lodTexture) {
          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
        }
      }
      resolve();
    }
  });
}
function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {
  if (!Tools.IsExponentOfTwo(texture.width)) {
    throw new Error("Texture size must be a power of two");
  }
  const mipmapsCount = Scalar.ILog2(texture.width) + 1;
  const engine = texture.getEngine();
  let expandTexture = false;
  let generateNonLODTextures = false;
  let rgbdPostProcess = null;
  let cubeRtt = null;
  let lodTextures = null;
  const caps = engine.getCaps();
  texture.format = 5;
  texture.type = 0;
  texture.generateMipMaps = true;
  texture._cachedAnisotropicFilteringLevel = null;
  engine.updateTextureSamplingMode(3, texture);
  if (!caps.textureLOD) {
    expandTexture = false;
    generateNonLODTextures = true;
    lodTextures = {};
  } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
    expandTexture = false;
  } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 2;
  } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 1;
  }
  if (expandTexture) {
    rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, texture.type, void 0, null, false);
    texture._isRGBD = false;
    texture.invertY = false;
    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
      generateDepthBuffer: false,
      generateMipMaps: true,
      generateStencilBuffer: false,
      samplingMode: 3,
      type: texture.type,
      format: 5
    });
  } else {
    texture._isRGBD = true;
    texture.invertY = true;
    if (generateNonLODTextures) {
      const mipSlices = 3;
      const scale = texture._lodGenerationScale;
      const offset = texture._lodGenerationOffset;
      for (let i = 0; i < mipSlices; i++) {
        const smoothness = i / (mipSlices - 1);
        const roughness = 1 - smoothness;
        const minLODIndex = offset;
        const maxLODIndex = (mipmapsCount - 1) * scale + offset;
        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
        const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);
        glTextureFromLod.isCube = true;
        glTextureFromLod.invertY = true;
        glTextureFromLod.generateMipMaps = false;
        engine.updateTextureSamplingMode(2, glTextureFromLod);
        const lodTexture = new BaseTexture(null);
        lodTexture._isCube = true;
        lodTexture._texture = glTextureFromLod;
        lodTextures[mipmapIndex] = lodTexture;
        switch (i) {
          case 0:
            texture._lodTextureLow = lodTexture;
            break;
          case 1:
            texture._lodTextureMid = lodTexture;
            break;
          case 2:
            texture._lodTextureHigh = lodTexture;
            break;
        }
      }
    }
  }
  const promises = [];
  for (let i = 0; i < imageData.length; i++) {
    for (let face = 0; face < 6; face++) {
      const bytes = imageData[i][face];
      const blob = new Blob([bytes], { type: imageType });
      const url = URL.createObjectURL(blob);
      let promise;
      if (engine._features.forceBitmapOverHTMLImageElement) {
        promise = engine.createImageBitmap(blob, { premultiplyAlpha: "none" }).then((img) => {
          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);
        });
      } else {
        const image = new Image();
        image.src = url;
        promise = new Promise((resolve, reject) => {
          image.onload = () => {
            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch((reason) => {
              reject(reason);
            });
          };
          image.onerror = (error) => {
            reject(error);
          };
        });
      }
      promises.push(promise);
    }
  }
  if (imageData.length < mipmapsCount) {
    let data;
    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);
    const dataLength = size * size * 4;
    switch (texture.type) {
      case 0: {
        data = new Uint8Array(dataLength);
        break;
      }
      case 2: {
        data = new Uint16Array(dataLength);
        break;
      }
      case 1: {
        data = new Float32Array(dataLength);
        break;
      }
    }
    for (let i = imageData.length; i < mipmapsCount; i++) {
      for (let face = 0; face < 6; face++) {
        engine._uploadArrayBufferViewToTexture(texture, data, face, i);
      }
    }
  }
  return Promise.all(promises).then(() => {
    if (cubeRtt) {
      engine._releaseTexture(texture);
      cubeRtt._swapAndDie(texture);
    }
    if (rgbdPostProcess) {
      rgbdPostProcess.dispose();
    }
    if (generateNonLODTextures) {
      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
        texture._lodTextureHigh._texture.isReady = true;
      }
      if (texture._lodTextureMid && texture._lodTextureMid._texture) {
        texture._lodTextureMid._texture.isReady = true;
      }
      if (texture._lodTextureLow && texture._lodTextureLow._texture) {
        texture._lodTextureLow._texture.isReady = true;
      }
    }
  });
}
function UploadEnvSpherical(texture, info) {
  info = normalizeEnvInfo(info);
  const irradianceInfo = info.irradiance;
  if (!irradianceInfo) {
    return;
  }
  const sp = new SphericalPolynomial();
  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
  texture._sphericalPolynomial = sp;
}
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
  const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);
  internalTexture.onRebuildCallback = (_internalTexture) => {
    return {
      proxy: proxyPromise,
      isReady: true,
      isAsync: true
    };
  };
  internalTexture._source = InternalTextureSource.CubeRawRGBD;
  internalTexture._bufferViewArrayArray = data;
  internalTexture._lodGenerationScale = lodScale;
  internalTexture._lodGenerationOffset = lodOffset;
  internalTexture._sphericalPolynomial = sphericalPolynomial;
  return UploadLevelsAsync(internalTexture, data).then(() => {
    internalTexture.isReady = true;
    return internalTexture;
  });
}
var EnvironmentTextureTools = {
  /**
   * Gets the environment info from an env file.
   * @param data The array buffer containing the .env bytes.
   * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.
   */
  GetEnvInfo,
  /**
   * Creates an environment texture from a loaded cube texture.
   * @param texture defines the cube texture to convert in env file
   * @param options options for the conversion process
   * @param options.imageType the mime type for the encoded images, with support for "image/png" (default) and "image/webp"
   * @param options.imageQuality the image quality of encoded WebP images.
   * @returns a promise containing the environment data if successful.
   */
  CreateEnvTextureAsync,
  /**
   * Creates the ArrayBufferViews used for initializing environment texture image data.
   * @param data the image data
   * @param info parameters that determine what views will be created for accessing the underlying buffer
   * @returns the views described by info providing access to the underlying buffer
   */
  CreateImageDataArrayBufferViews,
  /**
   * Uploads the texture info contained in the env file to the GPU.
   * @param texture defines the internal texture to upload to
   * @param data defines the data to load
   * @param info defines the texture info retrieved through the GetEnvInfo method
   * @returns a promise
   */
  UploadEnvLevelsAsync,
  /**
   * Uploads the levels of image data to the GPU.
   * @param texture defines the internal texture to upload to
   * @param imageData defines the array buffer views of image data [mipmap][face]
   * @param imageType the mime type of the image data
   * @returns a promise
   */
  UploadLevelsAsync,
  /**
   * Uploads spherical polynomials information to the texture.
   * @param texture defines the texture we are trying to upload the information to
   * @param info defines the environment texture info retrieved through the GetEnvInfo method
   */
  UploadEnvSpherical
};

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight = class extends Light {
  constructor() {
    super(...arguments);
    this._needProjectionMatrixCompute = true;
    this._viewMatrix = Matrix.Identity();
    this._projectionMatrix = Matrix.Identity();
  }
  _setPosition(value) {
    this._position = value;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  get position() {
    return this._position;
  }
  /**
   * Sets the position the shadow will be casted from. Also use as the light position for both
   * point and spot lights.
   */
  set position(value) {
    this._setPosition(value);
  }
  _setDirection(value) {
    this._direction = value;
  }
  /**
   * In 2d mode (needCube being false), gets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  get direction() {
    return this._direction;
  }
  /**
   * In 2d mode (needCube being false), sets the direction used to cast the shadow.
   * Also use as the light direction on spot and directional lights.
   */
  set direction(value) {
    this._setDirection(value);
  }
  /**
   * Gets the shadow projection clipping minimum z value.
   */
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  /**
   * Sets the shadow projection clipping minimum z value.
   */
  set shadowMinZ(value) {
    this._shadowMinZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Sets the shadow projection clipping maximum z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  /**
   * Gets the shadow projection clipping maximum z value.
   */
  set shadowMaxZ(value) {
    this._shadowMaxZ = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
   * @returns true if the information has been computed, false if it does not need to (no parenting)
   */
  computeTransformedInformation() {
    if (this.parent && this.parent.getWorldMatrix) {
      if (!this.transformedPosition) {
        this.transformedPosition = Vector3.Zero();
      }
      Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
      if (this.direction) {
        if (!this.transformedDirection) {
          this.transformedDirection = Vector3.Zero();
        }
        Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
      }
      return true;
    }
    return false;
  }
  /**
   * Return the depth scale used for the shadow map.
   * @returns the depth scale.
   */
  getDepthScale() {
    return 50;
  }
  /**
   * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getShadowDirection(faceIndex) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  /**
   * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.
   * @returns the position vector in world space
   */
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  /**
   * Sets the ShadowLight direction toward the passed target.
   * @param target The point to target in local space
   * @returns the updated ShadowLight direction
   */
  setDirectionToTarget(target) {
    this.direction = Vector3.Normalize(target.subtract(this.position));
    return this.direction;
  }
  /**
   * Returns the light rotation in euler definition.
   * @returns the x y z rotation in local space.
   */
  getRotation() {
    this.direction.normalize();
    const xaxis = Vector3.Cross(this.direction, Axis.Y);
    const yaxis = Vector3.Cross(xaxis, this.direction);
    return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
  }
  /**
   * Returns whether or not the shadow generation require a cube texture or a 2d texture.
   * @returns true if a cube texture needs to be use
   */
  needCube() {
    return false;
  }
  /**
   * Detects if the projection matrix requires to be recomputed this frame.
   * @returns true if it requires to be recomputed otherwise, false.
   */
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  /**
   * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
   */
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = true;
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = Vector3.Zero();
  }
  /** @internal */
  _isSynchronized() {
    if (!this._cache.position.equals(this.position)) {
      return false;
    }
    return true;
  }
  /**
   * Computes the world matrix of the node
   * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(force) {
    if (!force && this.isSynchronized()) {
      this._currentRenderId = this.getScene().getRenderId();
      return this._worldMatrix;
    }
    this._updateCache();
    this._cache.position.copyFrom(this.position);
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
    if (this.parent && this.parent.getWorldMatrix) {
      this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  getDepthMinZ(activeCamera) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  getDepthMaxZ(activeCamera) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
  }
  /**
   * Sets the shadow projection matrix in parameter to the generated projection matrix.
   * @param matrix The matrix to updated with the projection information
   * @param viewMatrix The transform matrix of the light
   * @param renderList The list of mesh to render in the map
   * @returns The current light
   */
  setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.customProjectionMatrixBuilder) {
      this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
    } else {
      this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
    return this;
  }
  /** @internal */
  _syncParentEnabledState() {
    super._syncParentEnabledState();
    if (!this.parent || !this.parent.getWorldMatrix) {
      this.transformedPosition = null;
      this.transformedDirection = null;
    }
  }
  /**
   * Returns the view matrix.
   * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.
   * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getViewMatrix(faceIndex) {
    const lightDirection = TmpVectors.Vector3[0];
    let lightPosition = this.position;
    if (this.computeTransformedInformation()) {
      lightPosition = this.transformedPosition;
    }
    Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);
    if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1) {
      lightDirection.z = 1e-13;
    }
    const lightTarget = TmpVectors.Vector3[1];
    lightPosition.addToRef(lightDirection, lightTarget);
    Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);
    return this._viewMatrix;
  }
  /**
   * Returns the projection matrix.
   * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).
   * @param viewMatrix The view transform matrix of the light (optional).
   * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).
   * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).
   */
  getProjectionMatrix(viewMatrix, renderList) {
    this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);
    return this._projectionMatrix;
  }
};
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "position", null);
__decorate([
  serializeAsVector3()
], ShadowLight.prototype, "direction", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMinZ", null);
__decorate([
  serialize()
], ShadowLight.prototype, "shadowMaxZ", null);

// node_modules/@babylonjs/core/Lights/directionalLight.js
Node.AddNodeConstructor("Light_Type_1", (name50, scene) => {
  return () => new DirectionalLight(name50, Vector3.Zero(), scene);
});
var DirectionalLight = class extends ShadowLight {
  /**
   * Fix frustum size for the shadow generation. This is disabled if the value is 0.
   */
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  /**
   * Specifies a fix frustum size for the shadow generation.
   */
  set shadowFrustumSize(value) {
    this._shadowFrustumSize = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  /**
   * Sets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  set shadowOrthoScale(value) {
    this._shadowOrthoScale = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets or sets the orthoLeft property used to build the light frustum
   */
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(left) {
    this._orthoLeft = left;
  }
  /**
   * Gets or sets the orthoRight property used to build the light frustum
   */
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(right) {
    this._orthoRight = right;
  }
  /**
   * Gets or sets the orthoTop property used to build the light frustum
   */
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(top) {
    this._orthoTop = top;
  }
  /**
   * Gets or sets the orthoBottom property used to build the light frustum
   */
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(bottom) {
    this._orthoBottom = bottom;
  }
  /**
   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
   * The directional light is emitted from everywhere in the given direction.
   * It can cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param direction The direction of the light
   * @param scene The scene the light belongs to
   */
  constructor(name50, direction, scene) {
    super(name50, scene);
    this._shadowFrustumSize = 0;
    this._shadowOrthoScale = 0.1;
    this.autoUpdateExtends = true;
    this.autoCalcShadowZBounds = false;
    this._orthoLeft = Number.MAX_VALUE;
    this._orthoRight = Number.MIN_VALUE;
    this._orthoTop = Number.MIN_VALUE;
    this._orthoBottom = Number.MAX_VALUE;
    this.position = direction.scale(-1);
    this.direction = direction;
  }
  /**
   * Returns the string "DirectionalLight".
   * @returns The class name
   */
  getClassName() {
    return "DirectionalLight";
  }
  /**
   * Returns the integer 1.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  /**
   * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  }
  /**
   * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   */
  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  /**
   * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = -Number.MAX_VALUE;
      this._orthoTop = -Number.MAX_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      let shadowMinZ = Number.MAX_VALUE;
      let shadowMaxZ = -Number.MAX_VALUE;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo();
        const boundingBox = boundingInfo.boundingBox;
        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    const xOffset = this._orthoRight - this._orthoLeft;
    const yOffset = this._orthoTop - this._orthoBottom;
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The directional light
   */
  transferToEffect(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMinZ(activeCamera) {
    const engine = this._scene.getEngine();
    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMaxZ(activeCamera) {
    const engine = this._scene.getEngine();
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowFrustumSize", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowOrthoScale", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoUpdateExtends", void 0);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
__decorate([
  serialize("orthoLeft")
], DirectionalLight.prototype, "_orthoLeft", void 0);
__decorate([
  serialize("orthoRight")
], DirectionalLight.prototype, "_orthoRight", void 0);
__decorate([
  serialize("orthoTop")
], DirectionalLight.prototype, "_orthoTop", void 0);
__decorate([
  serialize("orthoBottom")
], DirectionalLight.prototype, "_orthoBottom", void 0);
RegisterClass("BABYLON.DirectionalLight", DirectionalLight);

// node_modules/@babylonjs/core/Lights/spotLight.js
Node.AddNodeConstructor("Light_Type_2", (name50, scene) => {
  return () => new SpotLight(name50, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);
});
var SpotLight = class _SpotLight extends ShadowLight {
  /**
   * Gets the cone angle of the spot light in Radians.
   */
  get angle() {
    return this._angle;
  }
  /**
   * Sets the cone angle of the spot light in Radians.
   */
  set angle(value) {
    this._angle = value;
    this._cosHalfAngle = Math.cos(value * 0.5);
    this._projectionTextureProjectionLightDirty = true;
    this.forceProjectionMatrixCompute();
    this._computeAngleValues();
  }
  /**
   * Only used in gltf falloff mode, this defines the angle where
   * the directional falloff will start before cutting at angle which could be seen
   * as outer angle.
   */
  get innerAngle() {
    return this._innerAngle;
  }
  /**
   * Only used in gltf falloff mode, this defines the angle where
   * the directional falloff will start before cutting at angle which could be seen
   * as outer angle.
   */
  set innerAngle(value) {
    this._innerAngle = value;
    this._computeAngleValues();
  }
  /**
   * Allows scaling the angle of the light for shadow generation only.
   */
  get shadowAngleScale() {
    return this._shadowAngleScale;
  }
  /**
   * Allows scaling the angle of the light for shadow generation only.
   */
  set shadowAngleScale(value) {
    this._shadowAngleScale = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Allows reading the projection texture
   */
  get projectionTextureMatrix() {
    return this._projectionTextureMatrix;
  }
  /**
   * Gets the near clip of the Spotlight for texture projection.
   */
  get projectionTextureLightNear() {
    return this._projectionTextureLightNear;
  }
  /**
   * Sets the near clip of the Spotlight for texture projection.
   */
  set projectionTextureLightNear(value) {
    this._projectionTextureLightNear = value;
    this._projectionTextureProjectionLightDirty = true;
  }
  /**
   * Gets the far clip of the Spotlight for texture projection.
   */
  get projectionTextureLightFar() {
    return this._projectionTextureLightFar;
  }
  /**
   * Sets the far clip of the Spotlight for texture projection.
   */
  set projectionTextureLightFar(value) {
    this._projectionTextureLightFar = value;
    this._projectionTextureProjectionLightDirty = true;
  }
  /**
   * Gets the Up vector of the Spotlight for texture projection.
   */
  get projectionTextureUpDirection() {
    return this._projectionTextureUpDirection;
  }
  /**
   * Sets the Up vector of the Spotlight for texture projection.
   */
  set projectionTextureUpDirection(value) {
    this._projectionTextureUpDirection = value;
    this._projectionTextureProjectionLightDirty = true;
  }
  /**
   * Gets the projection texture of the light.
   */
  get projectionTexture() {
    return this._projectionTexture;
  }
  /**
   * Sets the projection texture of the light.
   */
  set projectionTexture(value) {
    if (this._projectionTexture === value) {
      return;
    }
    this._projectionTexture = value;
    this._projectionTextureDirty = true;
    if (this._projectionTexture && !this._projectionTexture.isReady()) {
      if (_SpotLight._IsProceduralTexture(this._projectionTexture)) {
        this._projectionTexture.getEffect().executeWhenCompiled(() => {
          this._markMeshesAsLightDirty();
        });
      } else if (_SpotLight._IsTexture(this._projectionTexture)) {
        this._projectionTexture.onLoadObservable.addOnce(() => {
          this._markMeshesAsLightDirty();
        });
      }
    }
  }
  static _IsProceduralTexture(texture) {
    return texture.onGeneratedObservable !== void 0;
  }
  static _IsTexture(texture) {
    return texture.onLoadObservable !== void 0;
  }
  /**
   * Gets or sets the light projection matrix as used by the projection texture
   */
  get projectionTextureProjectionLightMatrix() {
    return this._projectionTextureProjectionLightMatrix;
  }
  set projectionTextureProjectionLightMatrix(projection) {
    this._projectionTextureProjectionLightMatrix = projection;
    this._projectionTextureProjectionLightDirty = false;
    this._projectionTextureDirty = true;
  }
  /**
   * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
   * It can cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The light friendly name
   * @param position The position of the spot light in the scene
   * @param direction The direction of the light in the scene
   * @param angle The cone angle of the light in Radians
   * @param exponent The light decay speed with the distance from the emission spot
   * @param scene The scene the lights belongs to
   */
  constructor(name50, position, direction, angle, exponent, scene) {
    super(name50, scene);
    this._innerAngle = 0;
    this._projectionTextureMatrix = Matrix.Zero();
    this._projectionTextureLightNear = 1e-6;
    this._projectionTextureLightFar = 1e3;
    this._projectionTextureUpDirection = Vector3.Up();
    this._projectionTextureViewLightDirty = true;
    this._projectionTextureProjectionLightDirty = true;
    this._projectionTextureDirty = true;
    this._projectionTextureViewTargetVector = Vector3.Zero();
    this._projectionTextureViewLightMatrix = Matrix.Zero();
    this._projectionTextureProjectionLightMatrix = Matrix.Zero();
    this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
    this.position = position;
    this.direction = direction;
    this.angle = angle;
    this.exponent = exponent;
  }
  /**
   * Returns the string "SpotLight".
   * @returns the class name
   */
  getClassName() {
    return "SpotLight";
  }
  /**
   * Returns the integer 2.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return Light.LIGHTTYPEID_SPOTLIGHT;
  }
  /**
   * Overrides the direction setter to recompute the projection texture view light Matrix.
   * @param value
   */
  _setDirection(value) {
    super._setDirection(value);
    this._projectionTextureViewLightDirty = true;
  }
  /**
   * Overrides the position setter to recompute the projection texture view light Matrix.
   * @param value
   */
  _setPosition(value) {
    super._setPosition(value);
    this._projectionTextureViewLightDirty = true;
  }
  /**
   * Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
   * Returns the SpotLight.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    this._shadowAngleScale = this._shadowAngleScale || 1;
    const angle = this._shadowAngleScale * this._angle;
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.PerspectiveFovLHToRef(angle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
  }
  _computeProjectionTextureViewLightMatrix() {
    this._projectionTextureViewLightDirty = false;
    this._projectionTextureDirty = true;
    this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);
    Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);
  }
  _computeProjectionTextureProjectionLightMatrix() {
    this._projectionTextureProjectionLightDirty = false;
    this._projectionTextureDirty = true;
    const lightFar = this.projectionTextureLightFar;
    const lightNear = this.projectionTextureLightNear;
    const P = lightFar / (lightFar - lightNear);
    const Q = -P * lightNear;
    const S = 1 / Math.tan(this._angle / 2);
    const A = 1;
    Matrix.FromValuesToRef(S / A, 0, 0, 0, 0, S, 0, 0, 0, 0, P, 1, 0, 0, Q, 0, this._projectionTextureProjectionLightMatrix);
  }
  /**
   * Main function for light texture projection matrix computing.
   */
  _computeProjectionTextureMatrix() {
    this._projectionTextureDirty = false;
    this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);
    if (this._projectionTexture instanceof Texture) {
      const u = this._projectionTexture.uScale / 2;
      const v = this._projectionTexture.vScale / 2;
      Matrix.FromValuesToRef(u, 0, 0, 0, 0, v, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1, this._projectionTextureScalingMatrix);
    }
    this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightDirection", 3);
    this._uniformBuffer.addUniform("vLightFalloff", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  _computeAngleValues() {
    this._lightAngleScale = 1 / Math.max(1e-3, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);
    this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;
  }
  /**
   * Sets the passed Effect "effect" with the Light textures.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The light
   */
  transferTexturesToEffect(effect, lightIndex) {
    if (this.projectionTexture && this.projectionTexture.isReady()) {
      if (this._projectionTextureViewLightDirty) {
        this._computeProjectionTextureViewLightMatrix();
      }
      if (this._projectionTextureProjectionLightDirty) {
        this._computeProjectionTextureProjectionLightMatrix();
      }
      if (this._projectionTextureDirty) {
        this._computeProjectionTextureMatrix();
      }
      effect.setMatrix("textureProjectionMatrix" + lightIndex, this._projectionTextureMatrix);
      effect.setTexture("projectionLightTexture" + lightIndex, this.projectionTexture);
    }
    return this;
  }
  /**
   * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The spot light
   */
  transferToEffect(effect, lightIndex) {
    let normalizeDirection;
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);
      normalizeDirection = Vector3.Normalize(this.transformedDirection);
    } else {
      this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);
      normalizeDirection = Vector3.Normalize(this.direction);
    }
    this._uniformBuffer.updateFloat4("vLightDirection", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);
    this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    let normalizeDirection;
    if (this.computeTransformedInformation()) {
      normalizeDirection = Vector3.Normalize(this.transformedDirection);
    } else {
      normalizeDirection = Vector3.Normalize(this.direction);
    }
    if (this.getScene().useRightHandedSystem) {
      effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);
    } else {
      effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
    }
    return this;
  }
  /**
   * Disposes the light and the associated resources.
   */
  dispose() {
    super.dispose();
    if (this._projectionTexture) {
      this._projectionTexture.dispose();
    }
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the min for
   * @returns the depth min z
   */
  getDepthMinZ(activeCamera) {
    const engine = this._scene.getEngine();
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   * @param activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  getDepthMaxZ(activeCamera) {
    const engine = this._scene.getEngine();
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["SPOTLIGHT" + lightIndex] = true;
    defines["PROJECTEDLIGHTTEXTURE" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;
  }
};
__decorate([
  serialize()
], SpotLight.prototype, "angle", null);
__decorate([
  serialize()
], SpotLight.prototype, "innerAngle", null);
__decorate([
  serialize()
], SpotLight.prototype, "shadowAngleScale", null);
__decorate([
  serialize()
], SpotLight.prototype, "exponent", void 0);
__decorate([
  serialize()
], SpotLight.prototype, "projectionTextureLightNear", null);
__decorate([
  serialize()
], SpotLight.prototype, "projectionTextureLightFar", null);
__decorate([
  serialize()
], SpotLight.prototype, "projectionTextureUpDirection", null);
__decorate([
  serializeAsTexture("projectedLightTexture")
], SpotLight.prototype, "_projectionTexture", void 0);
RegisterClass("BABYLON.SpotLight", SpotLight);

// node_modules/@babylonjs/core/Engines/Extensions/engine.prefilteredCubeTexture.js
ThinEngine.prototype.createPrefilteredCubeTexture = function(rootUrl, scene, lodScale, lodOffset, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = true) {
  const callback = (loadData) => {
    if (!loadData) {
      if (onLoad) {
        onLoad(null);
      }
      return;
    }
    const texture = loadData.texture;
    if (!createPolynomials) {
      texture._sphericalPolynomial = new SphericalPolynomial();
    } else if (loadData.info.sphericalPolynomial) {
      texture._sphericalPolynomial = loadData.info.sphericalPolynomial;
    }
    texture._source = InternalTextureSource.CubePrefiltered;
    if (this.getCaps().textureLOD) {
      if (onLoad) {
        onLoad(texture);
      }
      return;
    }
    const mipSlices = 3;
    const gl = this._gl;
    const width = loadData.width;
    if (!width) {
      return;
    }
    const textures = [];
    for (let i = 0; i < mipSlices; i++) {
      const smoothness = i / (mipSlices - 1);
      const roughness = 1 - smoothness;
      const minLODIndex = lodOffset;
      const maxLODIndex = Scalar.Log2(width) * lodScale + lodOffset;
      const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
      const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
      const glTextureFromLod = new InternalTexture(this, InternalTextureSource.Temp);
      glTextureFromLod.type = texture.type;
      glTextureFromLod.format = texture.format;
      glTextureFromLod.width = Math.pow(2, Math.max(Scalar.Log2(width) - mipmapIndex, 0));
      glTextureFromLod.height = glTextureFromLod.width;
      glTextureFromLod.isCube = true;
      glTextureFromLod._cachedWrapU = 0;
      glTextureFromLod._cachedWrapV = 0;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod, true);
      glTextureFromLod.samplingMode = 2;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (loadData.isDDS) {
        const info = loadData.info;
        const data = loadData.data;
        this._unpackFlipY(info.isCompressed);
        DDSTools.UploadDDSLevels(this, glTextureFromLod, data, info, true, 6, mipmapIndex);
      } else {
        Logger.Warn("DDS is the only prefiltered cube map supported so far.");
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      const lodTexture = new BaseTexture(scene);
      lodTexture._isCube = true;
      lodTexture._texture = glTextureFromLod;
      glTextureFromLod.isReady = true;
      textures.push(lodTexture);
    }
    texture._lodTextureHigh = textures[2];
    texture._lodTextureMid = textures[1];
    texture._lodTextureLow = textures[0];
    if (onLoad) {
      onLoad(texture);
    }
  };
  return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset);
};

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var CubeTexture = class _CubeTexture extends BaseTexture {
  /**
   * Gets or sets the size of the bounding box associated with the cube texture
   * When defined, the cubemap will switch to local mode
   * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
   * @example https://www.babylonjs-playground.com/#RNASML
   */
  set boundingBoxSize(value) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
      return;
    }
    this._boundingBoxSize = value;
    const scene = this.getScene();
    if (scene) {
      scene.markAllMaterialsAsDirty(1);
    }
  }
  /**
   * Returns the bounding box size
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode
   */
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  /**
   * Sets texture matrix rotation angle around Y axis in radians.
   */
  set rotationY(value) {
    this._rotationY = value;
    this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
  }
  /**
   * Gets texture matrix rotation angle around Y axis radians.
   */
  get rotationY() {
    return this._rotationY;
  }
  /**
   * Are mip maps generated for this texture or not.
   */
  get noMipmap() {
    return this._noMipmap;
  }
  /**
   * Gets the forced extension (if any)
   */
  get forcedExtension() {
    return this._forcedExtension;
  }
  /**
   * Creates a cube texture from an array of image urls
   * @param files defines an array of image urls
   * @param scene defines the hosting scene
   * @param noMipmap specifies if mip maps are not used
   * @returns a cube texture
   */
  static CreateFromImages(files, scene, noMipmap) {
    let rootUrlKey = "";
    files.forEach((url) => rootUrlKey += url);
    return new _CubeTexture(rootUrlKey, scene, null, noMipmap, files);
  }
  /**
   * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.
   * @param url defines the url of the prefiltered texture
   * @param scene defines the scene the texture is attached to
   * @param forcedExtension defines the extension of the file if different from the url
   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
   * @returns the prefiltered texture
   */
  static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {
    const oldValue = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    const result = new _CubeTexture(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
    scene.useDelayedTextureLoading = oldValue;
    return result;
  }
  /**
   * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well
   * as prefiltered data.
   * @param rootUrl defines the url of the texture or the root name of the six images
   * @param sceneOrEngine defines the scene or engine the texture is attached to
   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
   * @param noMipmap defines if mipmaps should be created or not
   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
   * @param onLoad defines a callback triggered at the end of the file load if no errors occurred
   * @param onError defines a callback triggered in case of error during load
   * @param format defines the internal format to use for the texture once loaded
   * @param prefiltered defines whether or not the texture is created from prefiltered data
   * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name
   * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary
   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
   * @param loaderOptions options to be passed to the loader
   * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)
   * @returns the cube texture
   */
  constructor(rootUrl, sceneOrEngine, extensions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = 0.8, lodOffset = 0, loaderOptions, useSRGBBuffer) {
    var _a;
    super(sceneOrEngine);
    this._lodScale = 0.8;
    this._lodOffset = 0;
    this.onLoadObservable = new Observable();
    this.boundingBoxPosition = Vector3.Zero();
    this._rotationY = 0;
    this._files = null;
    this._forcedExtension = null;
    this._extensions = null;
    this._textureMatrixRefraction = new Matrix();
    this.name = rootUrl;
    this.url = rootUrl;
    this._noMipmap = noMipmap;
    this.hasAlpha = false;
    this._format = format;
    this.isCube = true;
    this._textureMatrix = Matrix.Identity();
    this._createPolynomials = createPolynomials;
    this.coordinatesMode = Texture.CUBIC_MODE;
    this._extensions = extensions;
    this._files = files;
    this._forcedExtension = forcedExtension;
    this._loaderOptions = loaderOptions;
    this._useSRGBBuffer = useSRGBBuffer;
    this._lodScale = lodScale;
    this._lodOffset = lodOffset;
    if (!rootUrl && !files) {
      return;
    }
    this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = this.getScene()) == null ? void 0 : _a.useDelayedTextureLoading, files);
  }
  /**
   * Get the current class name of the texture useful for serialization or dynamic coding.
   * @returns "CubeTexture"
   */
  getClassName() {
    return "CubeTexture";
  }
  /**
   * Update the url (and optional buffer) of this texture if url was null during construction.
   * @param url the url of the texture
   * @param forcedExtension defines the extension to use
   * @param onLoad callback called when the texture is loaded  (defaults to null)
   * @param prefiltered Defines whether the updated texture is prefiltered or not
   * @param onError callback called if there was an error during the loading process (defaults to null)
   * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...
   * @param delayLoad defines if the texture should be loaded now (false by default)
   * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz
   */
  updateURL(url, forcedExtension, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null) {
    if (!this.name || this.name.startsWith("data:")) {
      this.name = url;
    }
    this.url = url;
    if (forcedExtension) {
      this._forcedExtension = forcedExtension;
    }
    const lastDot = url.lastIndexOf(".");
    const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    const isDDS = extension.indexOf(".dds") === 0;
    const isEnv = extension.indexOf(".env") === 0;
    const isBasis = extension.indexOf(".basis") === 0;
    if (isEnv) {
      this.gammaSpace = false;
      this._prefiltered = false;
      this.anisotropicFilteringLevel = 1;
    } else {
      this._prefiltered = prefiltered;
      if (prefiltered) {
        this.gammaSpace = false;
        this.anisotropicFilteringLevel = 1;
      }
    }
    if (files) {
      this._files = files;
    } else {
      if (!isBasis && !isEnv && !isDDS && !extensions) {
        extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
      }
      this._files = this._files || [];
      this._files.length = 0;
      if (extensions) {
        for (let index = 0; index < extensions.length; index++) {
          this._files.push(url + extensions[index]);
        }
        this._extensions = extensions;
      }
    }
    if (delayLoad) {
      this.delayLoadState = 4;
      this._delayedOnLoad = onLoad;
      this._delayedOnError = onError;
    } else {
      this._loadTexture(onLoad, onError);
    }
  }
  /**
   * Delays loading of the cube texture
   * @param forcedExtension defines the extension to use
   */
  delayLoad(forcedExtension) {
    if (this.delayLoadState !== 4) {
      return;
    }
    if (forcedExtension) {
      this._forcedExtension = forcedExtension;
    }
    this.delayLoadState = 1;
    this._loadTexture(this._delayedOnLoad, this._delayedOnError);
  }
  /**
   * Returns the reflection texture matrix
   * @returns the reflection texture matrix
   */
  getReflectionTextureMatrix() {
    return this._textureMatrix;
  }
  /**
   * Sets the reflection texture matrix
   * @param value Reflection texture matrix
   */
  setReflectionTextureMatrix(value) {
    var _a, _b;
    if (value.updateFlag === this._textureMatrix.updateFlag) {
      return;
    }
    if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
      (_a = this.getScene()) == null ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
    }
    this._textureMatrix = value;
    if (!((_b = this.getScene()) == null ? void 0 : _b.useRightHandedSystem)) {
      return;
    }
    const scale = TmpVectors.Vector3[0];
    const quat = TmpVectors.Quaternion[0];
    const trans = TmpVectors.Vector3[1];
    this._textureMatrix.decompose(scale, quat, trans);
    quat.z *= -1;
    quat.w *= -1;
    Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);
  }
  /**
   * Gets a suitable rotate/transform matrix when the texture is used for refraction.
   * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.
   * @returns The refraction matrix
   */
  getRefractionTextureMatrix() {
    var _a;
    return ((_a = this.getScene()) == null ? void 0 : _a.useRightHandedSystem) ? this._textureMatrixRefraction : this._textureMatrix;
  }
  _loadTexture(onLoad = null, onError = null) {
    var _a;
    const scene = this.getScene();
    const oldTexture = this._texture;
    this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
    const onLoadProcessing = () => {
      var _a2;
      this.onLoadObservable.notifyObservers(this);
      if (oldTexture) {
        oldTexture.dispose();
        (_a2 = this.getScene()) == null ? void 0 : _a2.markAllMaterialsAsDirty(1);
      }
      if (onLoad) {
        onLoad();
      }
    };
    const errorHandler = (message, exception) => {
      this._loadingError = true;
      this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      Texture.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this._texture) {
      if (this._prefiltered) {
        this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
      } else {
        this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);
      }
      (_a = this._texture) == null ? void 0 : _a.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));
    } else {
      if (this._texture.isReady) {
        Tools.SetImmediate(() => onLoadProcessing());
      } else {
        this._texture.onLoadedObservable.add(() => onLoadProcessing());
      }
    }
  }
  /**
   * Parses text to create a cube texture
   * @param parsedTexture define the serialized text to read from
   * @param scene defines the hosting scene
   * @param rootUrl defines the root url of the cube texture
   * @returns a cube texture
   */
  static Parse(parsedTexture, scene, rootUrl) {
    const texture = SerializationHelper.Parse(() => {
      let prefiltered = false;
      if (parsedTexture.prefiltered) {
        prefiltered = parsedTexture.prefiltered;
      }
      return new _CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
    }, parsedTexture, scene);
    if (parsedTexture.boundingBoxPosition) {
      texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
    }
    if (parsedTexture.boundingBoxSize) {
      texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
    }
    if (parsedTexture.animations) {
      for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
        const parsedAnimation = parsedTexture.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          texture.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
    }
    return texture;
  }
  /**
   * Makes a clone, or deep copy, of the cube texture
   * @returns a new cube texture
   */
  clone() {
    let uniqueId = 0;
    const newCubeTexture = SerializationHelper.Clone(() => {
      const cubeTexture = new _CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
      uniqueId = cubeTexture.uniqueId;
      return cubeTexture;
    }, this);
    newCubeTexture.uniqueId = uniqueId;
    return newCubeTexture;
  }
};
__decorate([
  serialize()
], CubeTexture.prototype, "url", void 0);
__decorate([
  serializeAsVector3()
], CubeTexture.prototype, "boundingBoxPosition", void 0);
__decorate([
  serializeAsVector3()
], CubeTexture.prototype, "boundingBoxSize", null);
__decorate([
  serialize("rotationY")
], CubeTexture.prototype, "rotationY", null);
__decorate([
  serialize("files")
], CubeTexture.prototype, "_files", void 0);
__decorate([
  serialize("forcedExtension")
], CubeTexture.prototype, "_forcedExtension", void 0);
__decorate([
  serialize("extensions")
], CubeTexture.prototype, "_extensions", void 0);
__decorate([
  serializeAsMatrix("textureMatrix")
], CubeTexture.prototype, "_textureMatrix", void 0);
__decorate([
  serializeAsMatrix("textureMatrixRefraction")
], CubeTexture.prototype, "_textureMatrixRefraction", void 0);
Texture._CubeTextureParser = CubeTexture.Parse;
RegisterClass("BABYLON.CubeTexture", CubeTexture);

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
var _instanceNumber = 0;
var GetEnvironmentBRDFTexture = (scene) => {
  if (!scene.environmentBRDFTexture) {
    const useDelayedTextureLoading = scene.useDelayedTextureLoading;
    scene.useDelayedTextureLoading = false;
    const previousState = scene._blockEntityCollection;
    scene._blockEntityCollection = false;
    const texture = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
    scene._blockEntityCollection = previousState;
    const texturesCache = scene.getEngine().getLoadedTexturesCache();
    const index = texturesCache.indexOf(texture.getInternalTexture());
    if (index !== -1) {
      texturesCache.splice(index, 1);
    }
    texture.isRGBD = true;
    texture.wrapU = Texture.CLAMP_ADDRESSMODE;
    texture.wrapV = Texture.CLAMP_ADDRESSMODE;
    scene.environmentBRDFTexture = texture;
    scene.useDelayedTextureLoading = useDelayedTextureLoading;
    RGBDTextureTools.ExpandRGBDTexture(texture);
    const observer = scene.getEngine().onContextRestoredObservable.add(() => {
      texture.isRGBD = true;
      const oo = scene.onBeforeRenderObservable.add(() => {
        if (texture.isReady()) {
          scene.onBeforeRenderObservable.remove(oo);
          RGBDTextureTools.ExpandRGBDTexture(texture);
        }
      });
    });
    scene.onDisposeObservable.add(() => {
      scene.getEngine().onContextRestoredObservable.remove(observer);
    });
  }
  return scene.environmentBRDFTexture;
};
var BRDFTextureTools = {
  /**
   * Gets a default environment BRDF for MS-BRDF Height Correlated BRDF
   * @param scene defines the hosting scene
   * @returns the environment BRDF texture
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  GetEnvironmentBRDFTexture
};

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.CLEARCOAT = false;
    this.CLEARCOAT_DEFAULTIOR = false;
    this.CLEARCOAT_TEXTURE = false;
    this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
    this.CLEARCOAT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.CLEARCOAT_BUMP = false;
    this.CLEARCOAT_BUMPDIRECTUV = 0;
    this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    this.CLEARCOAT_REMAP_F0 = false;
    this.CLEARCOAT_TINT = false;
    this.CLEARCOAT_TINT_TEXTURE = false;
    this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TINT_GAMMATEXTURE = false;
  }
};
var PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.roughness = 0;
    this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._remapF0OnInterfaceChange = true;
    this.remapF0OnInterfaceChange = true;
    this._bumpTexture = null;
    this.bumpTexture = null;
    this._isTintEnabled = false;
    this.isTintEnabled = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.tintThickness = 1;
    this._tintTexture = null;
    this.tintTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    const disableBumpMap = this._material._disableBumpMap;
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
          if (!this._tintTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.CLEARCOAT = true;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
          } else {
            defines.CLEARCOAT_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
          } else {
            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          }
          if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
            PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
          } else {
            defines.CLEARCOAT_BUMP = false;
          }
          defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
          if (this._isTintEnabled) {
            defines.CLEARCOAT_TINT = true;
            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
              defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
            } else {
              defines.CLEARCOAT_TINT_TEXTURE = false;
            }
          } else {
            defines.CLEARCOAT_TINT = false;
            defines.CLEARCOAT_TINT_TEXTURE = false;
          }
        }
      }
    } else {
      defines.CLEARCOAT = false;
      defines.CLEARCOAT_TEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
      defines.CLEARCOAT_BUMP = false;
      defines.CLEARCOAT_TINT = false;
      defines.CLEARCOAT_TINT_TEXTURE = false;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.CLEARCOAT_DEFAULTIOR = false;
      defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
      defines.CLEARCOAT_BUMPDIRECTUV = 0;
      defines.CLEARCOAT_REMAP_F0 = false;
      defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    var _a, _b, _c, _d;
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const disableBumpMap = this._material._disableBumpMap;
    const invertNormalMapX = this._material._invertNormalMapX;
    const invertNormalMapY = this._material._invertNormalMapY;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._textureRoughness) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._textureRoughness) == null ? void 0 : _d.level) ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
        }
        if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
        }
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
        uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
        BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
        if (scene._mirroredCameraPosition) {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
        } else {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
        }
      }
      if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
        BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
      }
      uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
      const a = 1 - this._indexOfRefraction;
      const b = 1 + this._indexOfRefraction;
      const f0 = Math.pow(-a / b, 2);
      const eta = 1 / this._indexOfRefraction;
      uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
      if (this._isTintEnabled) {
        uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
        uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatSampler", this._texture);
      }
      if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
        uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
      }
      if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._tintTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._tintTexture) {
      activeTextures.push(this._tintTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      animatables.push(this._bumpTexture);
    }
    if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
      animatables.push(this._tintTexture);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b, _c, _d;
    if (forceDisposeTextures) {
      (_a = this._texture) == null ? void 0 : _a.dispose();
      (_b = this._textureRoughness) == null ? void 0 : _b.dispose();
      (_c = this._bumpTexture) == null ? void 0 : _c.dispose();
      (_d = this._tintTexture) == null ? void 0 : _d.dispose();
    }
  }
  getClassName() {
    return "PBRClearCoatConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.CLEARCOAT_BUMP) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
    }
    if (defines.CLEARCOAT_TINT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
    }
    if (defines.CLEARCOAT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vClearCoatParams", size: 2, type: "vec2" },
        { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
        { name: "vClearCoatInfos", size: 4, type: "vec4" },
        { name: "clearCoatMatrix", size: 16, type: "mat4" },
        { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
        { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
        { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatTintParams", size: 4, type: "vec4" },
        { name: "clearCoatColorAtDistance", size: 1, type: "float" },
        { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
        { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
__decorate([
  serializeAsColor3()
], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.IRIDESCENCE = false;
    this.IRIDESCENCE_TEXTURE = false;
    this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
    this.IRIDESCENCE_THICKNESS_TEXTURE = false;
    this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
  }
};
var PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
    this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
    this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.IRIDESCENCE = true;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
          } else {
            defines.IRIDESCENCE_TEXTURE = false;
          }
          if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
          } else {
            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          }
        }
      }
    } else {
      defines.IRIDESCENCE = false;
      defines.IRIDESCENCE_TEXTURE = false;
      defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
      defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
      defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    var _a, _b, _c, _d;
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.updateFloat4("vIridescenceInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._thicknessTexture) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._thicknessTexture) == null ? void 0 : _d.level) ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
        }
        if (this._thicknessTexture) {
          BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
        }
      }
      uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceSampler", this._texture);
      }
      if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._thicknessTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b;
    if (forceDisposeTextures) {
      (_a = this._texture) == null ? void 0 : _a.dispose();
      (_b = this._thicknessTexture) == null ? void 0 : _b.dispose();
    }
  }
  getClassName() {
    return "PBRIridescenceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.IRIDESCENCE) {
      fallbacks.addFallback(currentRank++, "IRIDESCENCE");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vIridescenceParams", size: 4, type: "vec4" },
        { name: "vIridescenceInfos", size: 4, type: "vec4" },
        { name: "iridescenceMatrix", size: 16, type: "mat4" },
        { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "texture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.ANISOTROPIC = false;
    this.ANISOTROPIC_TEXTURE = false;
    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
    this.ANISOTROPIC_LEGACY = false;
    this.MAINUV1 = false;
  }
};
var PBRAnisotropicConfiguration = class extends MaterialPluginBase {
  /**
   * Sets the anisotropy direction as an angle.
   */
  set angle(value) {
    this.direction.x = Math.cos(value);
    this.direction.y = Math.sin(value);
  }
  /**
   * Gets the anisotropy angle value in radians.
   * @returns the anisotropy angle value in radians.
   */
  get angle() {
    return Math.atan2(this.direction.y, this.direction.x);
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.direction = new Vector2(1, 0);
    this._texture = null;
    this.texture = null;
    this._legacy = false;
    this.legacy = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
    if (this._isEnabled) {
      defines.ANISOTROPIC = this._isEnabled;
      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
          } else {
            defines.ANISOTROPIC_TEXTURE = false;
          }
        }
      }
      if (defines._areMiscDirty) {
        defines.ANISOTROPIC_LEGACY = this._legacy;
      }
    } else {
      defines.ANISOTROPIC = false;
      defines.ANISOTROPIC_TEXTURE = false;
      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
      defines.ANISOTROPIC_LEGACY = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
        BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
      }
      uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.setTexture("anisotropySampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._texture) {
        this._texture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRAnisotropicConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.ANISOTROPIC) {
      fallbacks.addFallback(currentRank++, "ANISOTROPIC");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("anisotropySampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vAnisotropy", size: 3, type: "vec3" },
        { name: "vAnisotropyInfos", size: 2, type: "vec2" },
        { name: "anisotropyMatrix", size: 16, type: "mat4" }
      ]
    };
  }
  /**
   * Parses a anisotropy Configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    super.parse(source, scene, rootUrl);
    if (source.legacy === void 0) {
      this.legacy = true;
    }
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsVector2()
], PBRAnisotropicConfiguration.prototype, "direction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRAnisotropicConfiguration.prototype, "legacy", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SHEEN = false;
    this.SHEEN_TEXTURE = false;
    this.SHEEN_GAMMATEXTURE = false;
    this.SHEEN_TEXTURE_ROUGHNESS = false;
    this.SHEEN_TEXTUREDIRECTUV = 0;
    this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.SHEEN_LINKWITHALBEDO = false;
    this.SHEEN_ROUGHNESS = false;
    this.SHEEN_ALBEDOSCALING = false;
    this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
  }
};
var PBRSheenConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this._linkSheenWithAlbedo = false;
    this.linkSheenWithAlbedo = false;
    this.intensity = 1;
    this.color = Color3.White();
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._roughness = null;
    this.roughness = null;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._albedoScaling = false;
    this.albedoScaling = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.SheenTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.SHEEN = true;
      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
      defines.SHEEN_ROUGHNESS = this._roughness !== null;
      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
            defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
          } else {
            defines.SHEEN_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
          } else {
            defines.SHEEN_TEXTURE_ROUGHNESS = false;
          }
        }
      }
    } else {
      defines.SHEEN = false;
      defines.SHEEN_TEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS = false;
      defines.SHEEN_LINKWITHALBEDO = false;
      defines.SHEEN_ROUGHNESS = false;
      defines.SHEEN_ALBEDOSCALING = false;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.SHEEN_GAMMATEXTURE = false;
      defines.SHEEN_TEXTUREDIRECTUV = 0;
      defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    var _a, _b, _c, _d;
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", ((_a = this._texture) == null ? void 0 : _a.coordinatesIndex) ?? 0, ((_b = this._texture) == null ? void 0 : _b.level) ?? 0, ((_c = this._textureRoughness) == null ? void 0 : _c.coordinatesIndex) ?? 0, ((_d = this._textureRoughness) == null ? void 0 : _d.level) ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "sheen");
        }
        if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
        }
      }
      uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
      if (this._roughness !== null) {
        uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenSampler", this._texture);
      }
      if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
  }
  dispose(forceDisposeTextures) {
    var _a, _b;
    if (forceDisposeTextures) {
      (_a = this._texture) == null ? void 0 : _a.dispose();
      (_b = this._textureRoughness) == null ? void 0 : _b.dispose();
    }
  }
  getClassName() {
    return "PBRSheenConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SHEEN) {
      fallbacks.addFallback(currentRank++, "SHEEN");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("sheenSampler", "sheenRoughnessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vSheenColor", size: 4, type: "vec4" },
        { name: "vSheenRoughness", size: 1, type: "float" },
        { name: "vSheenInfos", size: 4, type: "vec4" },
        { name: "sheenMatrix", size: 16, type: "mat4" },
        { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
__decorate([
  serialize()
], PBRSheenConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsColor3()
], PBRSheenConfiguration.prototype, "color", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "roughness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "albedoScaling", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SUBSURFACE = false;
    this.SS_REFRACTION = false;
    this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_TRANSLUCENCY = false;
    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_SCATTERING = false;
    this.SS_DISPERSION = false;
    this.SS_THICKNESSANDMASK_TEXTURE = false;
    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
    this.SS_HAS_THICKNESS = false;
    this.SS_REFRACTIONINTENSITY_TEXTURE = false;
    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
    this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
    this.SS_REFRACTIONMAP_3D = false;
    this.SS_REFRACTIONMAP_OPPOSITEZ = false;
    this.SS_LODINREFRACTIONALPHA = false;
    this.SS_GAMMAREFRACTION = false;
    this.SS_RGBDREFRACTION = false;
    this.SS_LINEARSPECULARREFRACTION = false;
    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
    this.SS_ALBEDOFORREFRACTIONTINT = false;
    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.SS_USE_THICKNESS_AS_DEPTH = false;
    this.SS_USE_GLTF_TEXTURES = false;
  }
};
var PBRSubSurfaceConfiguration = class extends MaterialPluginBase {
  /**
   * Diffusion profile for subsurface scattering.
   * Useful for better scattering in the skins or foliages.
   */
  get scatteringDiffusionProfile() {
    if (!this._scene.subSurfaceConfiguration) {
      return null;
    }
    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
  }
  set scatteringDiffusionProfile(c) {
    if (!this._scene.enableSubSurfaceForPrePass()) {
      return;
    }
    if (c) {
      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
    }
  }
  /**
   * Index of refraction of the material's volume.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This ONLY impacts refraction. If not provided or given a non-valid value,
   * the volume will use the same IOR as the surface.
   */
  get volumeIndexOfRefraction() {
    if (this._volumeIndexOfRefraction >= 1) {
      return this._volumeIndexOfRefraction;
    }
    return this._indexOfRefraction;
  }
  set volumeIndexOfRefraction(value) {
    if (value >= 1) {
      this._volumeIndexOfRefraction = value;
    } else {
      this._volumeIndexOfRefraction = -1;
    }
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markScenePrePassDirty() {
    this._internalMarkAllSubMeshesAsTexturesDirty();
    this._internalMarkScenePrePassDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
    this._isRefractionEnabled = false;
    this.isRefractionEnabled = false;
    this._isTranslucencyEnabled = false;
    this.isTranslucencyEnabled = false;
    this._isDispersionEnabled = false;
    this.isDispersionEnabled = false;
    this._isScatteringEnabled = false;
    this.isScatteringEnabled = false;
    this._scatteringDiffusionProfileIndex = 0;
    this.refractionIntensity = 1;
    this.translucencyIntensity = 1;
    this.useAlbedoToTintRefraction = false;
    this.useAlbedoToTintTranslucency = false;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._refractionTexture = null;
    this.refractionTexture = null;
    this._indexOfRefraction = 1.5;
    this.indexOfRefraction = 1.5;
    this._volumeIndexOfRefraction = -1;
    this._invertRefractionY = false;
    this.invertRefractionY = false;
    this._linkRefractionWithTransparency = false;
    this.linkRefractionWithTransparency = false;
    this.minimumThickness = 0;
    this.maximumThickness = 1;
    this.useThicknessAsDepth = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.dispersion = 0;
    this.diffusionDistance = Color3.White();
    this._useMaskFromThicknessTexture = false;
    this.useMaskFromThicknessTexture = false;
    this._refractionIntensityTexture = null;
    this.refractionIntensityTexture = null;
    this._translucencyIntensityTexture = null;
    this.translucencyIntensityTexture = null;
    this.translucencyColor = null;
    this._translucencyColorTexture = null;
    this.translucencyColorTexture = null;
    this._useGltfStyleTextures = true;
    this.useGltfStyleTextures = true;
    this._scene = material.getScene();
    this.registerForExtraEvents = true;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
          if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const refractionTexture = this._getRefractionTexture(scene);
        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
          if (!refractionTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      defines.SUBSURFACE = false;
      defines.SS_DISPERSION = false;
      defines.SS_TRANSLUCENCY = false;
      defines.SS_SCATTERING = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
      return;
    }
    if (defines._areTexturesDirty) {
      defines.SUBSURFACE = true;
      defines.SS_DISPERSION = this._isDispersionEnabled;
      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_SCATTERING = this._isScatteringEnabled;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, "SS_TRANSLUCENCYCOLOR_TEXTURE");
          }
        }
      }
      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;
      if (this._isRefractionEnabled) {
        if (scene.texturesEnabled) {
          const refractionTexture = this._getRefractionTexture(scene);
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            defines.SS_REFRACTION = true;
            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
          }
        }
      }
      if (this._isTranslucencyEnabled) {
        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
      }
    }
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine defines the engine the material belongs to.
   * @param subMesh the submesh to bind data for
   */
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
    const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
    uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const realTimeFiltering = this._material.realTimeFiltering;
    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
    const refractionTexture = this._getRefractionTexture(scene);
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
        BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
        BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);
        BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, "translucencyColor");
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
        let depth = 1;
        if (!refractionTexture.isCube) {
          if (refractionTexture.depth) {
            depth = refractionTexture.depth;
          }
        }
        const width = refractionTexture.getSize().width;
        const refractionIor = this.volumeIndexOfRefraction;
        uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
        uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
        if (realTimeFiltering) {
          uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Scalar.Log2(width));
        }
        if (refractionTexture.boundingBoxSize) {
          const cubeTexture = refractionTexture;
          uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
          uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
        }
      }
      if (this._isScatteringEnabled) {
        uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
      }
      uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
      uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
      uniformBuffer.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0);
      uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
      uniformBuffer.updateFloat("dispersion", this.dispersion);
    }
    if (scene.texturesEnabled) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.setTexture("translucencyColorSampler", this._translucencyColorTexture);
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        if (lodBasedMicrosurface) {
          uniformBuffer.setTexture("refractionSampler", refractionTexture);
        } else {
          uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
        }
      }
    }
  }
  /**
   * Returns the texture used for refraction or null if none is used.
   * @param scene defines the scene the material belongs to.
   * @returns - Refraction texture if present.  If no refraction texture and refraction
   * is linked with transparency, returns environment texture.  Otherwise, returns null.
   */
  _getRefractionTexture(scene) {
    if (this._refractionTexture) {
      return this._refractionTexture;
    }
    if (this._isRefractionEnabled) {
      return scene.environmentTexture;
    }
    return null;
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get disableAlphaBlending() {
    return this._isRefractionEnabled && this._linkRefractionWithTransparency;
  }
  /**
   * Fills the list of render target textures.
   * @param renderTargets the list of render targets to update
   */
  fillRenderTargetTextures(renderTargets) {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      renderTargets.push(this._refractionTexture);
    }
  }
  hasTexture(texture) {
    if (this._thicknessTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    if (this._refractionIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyColorTexture === texture) {
      return true;
    }
    return false;
  }
  hasRenderTargetTextures() {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    if (this._translucencyColorTexture) {
      activeTextures.push(this._translucencyColorTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      animatables.push(this._refractionTexture);
    }
    if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {
      animatables.push(this._translucencyColorTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._thicknessTexture) {
        this._thicknessTexture.dispose();
      }
      if (this._refractionTexture) {
        this._refractionTexture.dispose();
      }
      if (this._translucencyColorTexture) {
        this._translucencyColorTexture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRSubSurfaceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SS_SCATTERING) {
      fallbacks.addFallback(currentRank++, "SS_SCATTERING");
    }
    if (defines.SS_TRANSLUCENCY) {
      fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
        { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
        { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
        { name: "vRefractionInfos", size: 4, type: "vec4" },
        { name: "refractionMatrix", size: 16, type: "mat4" },
        { name: "vThicknessInfos", size: 2, type: "vec2" },
        { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
        { name: "thicknessMatrix", size: 16, type: "mat4" },
        { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
        { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
        { name: "vThicknessParam", size: 2, type: "vec2" },
        { name: "vDiffusionDistance", size: 3, type: "vec3" },
        { name: "vTintColor", size: 4, type: "vec4" },
        { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
        { name: "vRefractionPosition", size: 3, type: "vec3" },
        { name: "vRefractionSize", size: 3, type: "vec3" },
        { name: "scatteringDiffusionProfile", size: 1, type: "float" },
        { name: "dispersion", size: 1, type: "float" },
        { name: "vTranslucencyColor", size: 4, type: "vec4" },
        { name: "vTranslucencyColorInfos", size: 2, type: "vec2" },
        { name: "translucencyColorMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markScenePrePassDirty")
], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "translucencyColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyColorTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.BRDF_V_HEIGHT_CORRELATED = false;
    this.MS_BRDF_ENERGY_CONSERVATION = false;
    this.SPHERICAL_HARMONICS = false;
    this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
  }
};
var PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
    this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
    this._enable(true);
  }
  prepareDefines(defines) {
    defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
    defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
    defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
    defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
  }
  getClassName() {
    return "PBRBRDFConfiguration";
  }
};
PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js
var name6 = "pbrFragmentDeclaration";
var shader6 = `uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#ifdef SS_DISPERSION
uniform float dispersion;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;uniform vec4 vTranslucencyColor;
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
uniform vec2 vTranslucencyColorInfos;uniform mat4 translucencyColorMatrix;
#endif
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
ShaderStore.IncludesShadersStore[name6] = shader6;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js
var name7 = "pbrUboDeclaration";
var shader7 = `layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name7] = shader7;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js
var name8 = "pbrFragmentExtraDeclaration";
var shader8 = `varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;
ShaderStore.IncludesShadersStore[name8] = shader8;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js
var name9 = "samplerFragmentAlternateDeclaration";
var shader9 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name9] = shader9;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js
var name10 = "pbrFragmentSamplersDeclaration";
var shader10 = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_SAMPLERNAME_,translucencyColor)
#endif
`;
ShaderStore.IncludesShadersStore[name10] = shader10;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js
var name11 = "subSurfaceScatteringFunctions";
var shader11 = `bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;
ShaderStore.IncludesShadersStore[name11] = shader11;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js
var name12 = "importanceSampling";
var shader12 = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;
ShaderStore.IncludesShadersStore[name12] = shader12;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js
var name13 = "pbrHelperFunctions";
var shader13 = `#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;
ShaderStore.IncludesShadersStore[name13] = shader13;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js
var name14 = "harmonicsFunctions";
var shader14 = `#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name14] = shader14;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js
var name15 = "pbrDirectLightingSetupFunctions";
var shader15 = `struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;
ShaderStore.IncludesShadersStore[name15] = shader15;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js
var name16 = "pbrDirectLightingFalloffFunctions";
var shader16 = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;
ShaderStore.IncludesShadersStore[name16] = shader16;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js
var name17 = "pbrBRDFFunctions";
var shader17 = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;
ShaderStore.IncludesShadersStore[name17] = shader17;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js
var name18 = "hdrFilteringFunctions";
var shader18 = `#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; 
if (alphaG==0.) {
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name18] = shader18;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js
var name19 = "pbrDirectLightingFunctions";
var shader19 = `#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;
ShaderStore.IncludesShadersStore[name19] = shader19;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js
var name20 = "pbrIBLFunctions";
var shader20 = `#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;
ShaderStore.IncludesShadersStore[name20] = shader20;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js
var name21 = "pbrBlockAlbedoOpacity";
var shader21 = `struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;
ShaderStore.IncludesShadersStore[name21] = shader21;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js
var name22 = "pbrBlockReflectivity";
var shader22 = `struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;
ShaderStore.IncludesShadersStore[name22] = shader22;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js
var name23 = "pbrBlockAmbientOcclusion";
var shader23 = `struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;
ShaderStore.IncludesShadersStore[name23] = shader23;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js
var name24 = "pbrBlockAlphaFresnel";
var shader24 = `#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name24] = shader24;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js
var name25 = "pbrBlockAnisotropic";
var shader25 = `#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;
ShaderStore.IncludesShadersStore[name25] = shader25;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js
var name26 = "pbrBlockReflection";
var shader26 = `#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;
ShaderStore.IncludesShadersStore[name26] = shader26;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js
var name27 = "pbrBlockSheen";
var shader27 = `#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;
ShaderStore.IncludesShadersStore[name27] = shader27;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js
var name28 = "pbrBlockClearcoat";
var shader28 = `struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name28] = shader28;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js
var name29 = "pbrBlockIridescence";
var shader29 = `struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;
ShaderStore.IncludesShadersStore[name29] = shader29;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js
var name30 = "pbrBlockSubSurface";
var shader30 = `struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#define pbr_inline
#define inline
vec4 sampleEnvironmentRefraction(
in float ior
,in float thickness
,in float refractionLOD
,in vec3 normalW
,in vec3 vPositionW
,in vec3 viewDirectionW
,in mat4 view
,in vec4 vRefractionInfos
,in mat4 refractionMatrix
,in vec4 vRefractionMicrosurfaceInfos
,in float alphaG
#ifdef SS_REFRACTIONMAP_3D
,in samplerCube refractionSampler
#ifndef LODBASEDMICROSFURACE
,in samplerCube refractionSamplerLow
,in samplerCube refractionSamplerHigh
#endif
#else
,in sampler2D refractionSampler
#ifndef LODBASEDMICROSFURACE
,in sampler2D refractionSamplerLow
,in sampler2D refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,in anisotropicOutParams anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,in vec2 vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,in vec3 refractionPosition
,in vec3 refractionSize
#endif
) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,ior);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
return environmentRefraction;}
#endif
#define pbr_inline
#define inline
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#ifdef SS_DISPERSION
in float dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
in vec4 vTranslucencyColor,
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
in vec4 translucencyColorMap,
#endif
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS)
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS)
#ifdef SS_USE_GLTF_TEXTURES
translucencyIntensity*=thicknessMap.a;
#else
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#if defined(SS_REFRACTION) && defined(SS_REFRACTIONINTENSITY_TEXTURE)
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCYINTENSITY_TEXTURE)
#ifdef SS_USE_GLTF_TEXTURES
translucencyIntensity*=translucencyIntensityMap.a;
#else
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec4 translucencyColor=vTranslucencyColor;
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
translucencyColor*=translucencyColorMap;
#endif
vec3 transmittance=transmittanceBRDF_Burley(translucencyColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
float refraction_ior=vRefractionInfos.y;
#ifdef SS_DISPERSION
float realIOR=1.0/refraction_ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {refraction_ior=iors[i];
#endif
vec4 envSample=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG
#ifdef SS_REFRACTIONMAP_3D
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#else
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,refractionPosition
,refractionSize
#endif
);
#ifdef SS_DISPERSION
environmentRefraction[i]=envSample[i];}
#else
environmentRefraction=envSample;
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name30] = shader30;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js
var name31 = "pbrBlockNormalGeometric";
var shader31 = `vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;
ShaderStore.IncludesShadersStore[name31] = shader31;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js
var name32 = "pbrBlockNormalFinal";
var shader32 = `#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;
ShaderStore.IncludesShadersStore[name32] = shader32;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js
var name33 = "pbrBlockLightmapInit";
var shader33 = `#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;
ShaderStore.IncludesShadersStore[name33] = shader33;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js
var name34 = "pbrBlockGeometryInfo";
var shader34 = `float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name34] = shader34;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js
var name35 = "pbrBlockReflectance0";
var shader35 = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;
ShaderStore.IncludesShadersStore[name35] = shader35;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js
var name36 = "pbrBlockReflectance";
var shader36 = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name36] = shader36;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js
var name37 = "pbrBlockDirectLighting";
var shader37 = `vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;
ShaderStore.IncludesShadersStore[name37] = shader37;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js
var name38 = "pbrBlockFinalLitComponents";
var shader38 = `aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;
ShaderStore.IncludesShadersStore[name38] = shader38;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js
var name39 = "pbrBlockFinalUnlitComponents";
var shader39 = `vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;
ShaderStore.IncludesShadersStore[name39] = shader39;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js
var name40 = "pbrBlockFinalColorComposition";
var shader40 = `vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;
ShaderStore.IncludesShadersStore[name40] = shader40;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js
var name41 = "pbrBlockImageProcessing";
var shader41 = `#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;
ShaderStore.IncludesShadersStore[name41] = shader41;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js
var name42 = "pbrDebug";
var shader42 = `#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#elif DEBUGMODE==89
gl_FragColor.rgb=aoOut.ambientOcclusionColor.rgb;
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;
ShaderStore.IncludesShadersStore[name42] = shader42;

// node_modules/@babylonjs/core/Shaders/pbr.fragment.js
var name43 = "pbrPixelShader";
var shader43 = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
vec4 translucencyColorMap=texture2D(translucencyColorSampler,vTranslucencyColorUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#ifdef SS_DISPERSION
dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
vTranslucencyColor,
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
translucencyColorMap,
#endif
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
ShaderStore.ShadersStore[name43] = shader43;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js
var name44 = "pbrVertexDeclaration";
var shader44 = `uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYCOLOR_TEXTURE
uniform vec2 vTranslucencyColorInfos;uniform mat4 translucencyColorMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;
ShaderStore.IncludesShadersStore[name44] = shader44;

// node_modules/@babylonjs/core/Shaders/pbr.vertex.js
var name45 = "pbrVertexShader";
var shader45 = `precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheenRoughness,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYCOLOR_TEXTURE,_VARYINGNAME_,TranslucencyColor,_MATRIXNAME_,translucencyColor,_INFONAME_,TranslucencyColorInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;
ShaderStore.ShadersStore[name45] = shader45;

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var PBRMaterialDefines = class extends MaterialDefines {
  /**
   * Initializes the PBR Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.PBR = true;
    this.NUM_SAMPLES = "0";
    this.REALTIME_FILTERING = false;
    this.MAINUV1 = false;
    this.MAINUV2 = false;
    this.MAINUV3 = false;
    this.MAINUV4 = false;
    this.MAINUV5 = false;
    this.MAINUV6 = false;
    this.UV1 = false;
    this.UV2 = false;
    this.UV3 = false;
    this.UV4 = false;
    this.UV5 = false;
    this.UV6 = false;
    this.ALBEDO = false;
    this.GAMMAALBEDO = false;
    this.ALBEDODIRECTUV = 0;
    this.VERTEXCOLOR = false;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.AMBIENTINGRAYSCALE = false;
    this.OPACITY = false;
    this.VERTEXALPHA = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHABLEND = false;
    this.ALPHAFROMALBEDO = false;
    this.ALPHATESTVALUE = "0.5";
    this.SPECULAROVERALPHA = false;
    this.RADIANCEOVERALPHA = false;
    this.ALPHAFRESNEL = false;
    this.LINEARALPHAFRESNEL = false;
    this.PREMULTIPLYALPHA = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.GAMMAEMISSIVE = false;
    this.REFLECTIVITY = false;
    this.REFLECTIVITY_GAMMA = false;
    this.REFLECTIVITYDIRECTUV = 0;
    this.SPECULARTERM = false;
    this.MICROSURFACEFROMREFLECTIVITYMAP = false;
    this.MICROSURFACEAUTOMATIC = false;
    this.LODBASEDMICROSFURACE = false;
    this.MICROSURFACEMAP = false;
    this.MICROSURFACEMAPDIRECTUV = 0;
    this.METALLICWORKFLOW = false;
    this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    this.METALLNESSSTOREINMETALMAPBLUE = false;
    this.AOSTOREINMETALMAPRED = false;
    this.METALLIC_REFLECTANCE = false;
    this.METALLIC_REFLECTANCE_GAMMA = false;
    this.METALLIC_REFLECTANCEDIRECTUV = 0;
    this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
    this.REFLECTANCE = false;
    this.REFLECTANCE_GAMMA = false;
    this.REFLECTANCEDIRECTUV = 0;
    this.ENVIRONMENTBRDF = false;
    this.ENVIRONMENTBRDF_RGBD = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.NORMALXYSCALE = true;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.GAMMALIGHTMAP = false;
    this.RGBDLIGHTMAP = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.USESPHERICALFROMREFLECTIONMAP = false;
    this.USEIRRADIANCEMAP = false;
    this.USESPHERICALINVERTEX = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.LINEARSPECULARREFLECTION = false;
    this.RADIANCEOCCLUSION = false;
    this.HORIZONOCCLUSION = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.PREPASS = false;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.NONUNIFORMSCALING = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.IMAGEPROCESSING = false;
    this.VIGNETTE = false;
    this.VIGNETTEBLENDMODEMULTIPLY = false;
    this.VIGNETTEBLENDMODEOPAQUE = false;
    this.TONEMAPPING = 0;
    this.CONTRAST = false;
    this.COLORCURVES = false;
    this.COLORGRADING = false;
    this.COLORGRADING3D = false;
    this.SAMPLER3DGREENDEPTH = false;
    this.SAMPLER3DBGRMAP = false;
    this.DITHER = false;
    this.IMAGEPROCESSINGPOSTPROCESS = false;
    this.SKIPFINALCOLORCLAMP = false;
    this.EXPOSURE = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.USEPHYSICALLIGHTFALLOFF = false;
    this.USEGLTFLIGHTFALLOFF = false;
    this.TWOSIDEDLIGHTING = false;
    this.SHADOWFLOAT = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LOGARITHMICDEPTH = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.FORCENORMALFORWARD = false;
    this.SPECULARAA = false;
    this.UNLIT = false;
    this.DECAL_AFTER_DETAIL = false;
    this.DEBUGMODE = 0;
    this.rebuild();
  }
  /**
   * Resets the PBR Material defines.
   */
  reset() {
    super.reset();
    this.ALPHATESTVALUE = "0.5";
    this.PBR = true;
    this.NORMALXYSCALE = true;
  }
};
var PBRBaseMaterial = class _PBRBaseMaterial extends PushMaterial {
  /**
   * Enables realtime filtering on the texture.
   */
  get realTimeFiltering() {
    return this._realTimeFiltering;
  }
  set realTimeFiltering(b) {
    this._realTimeFiltering = b;
    this.markAsDirty(1);
  }
  /**
   * Quality switch for realtime filtering
   */
  get realTimeFilteringQuality() {
    return this._realTimeFilteringQuality;
  }
  set realTimeFilteringQuality(n) {
    this._realTimeFilteringQuality = n;
    this.markAsDirty(1);
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Attaches a new image processing configuration to the PBR Material.
   * @param configuration
   */
  _attachImageProcessingConfiguration(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    if (!configuration) {
      this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
        this._markAllSubMeshesAsImageProcessingDirty();
      });
    }
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   */
  constructor(name50, scene) {
    super(name50, scene);
    this._directIntensity = 1;
    this._emissiveIntensity = 1;
    this._environmentIntensity = 1;
    this._specularIntensity = 1;
    this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
    this._disableBumpMap = false;
    this._albedoTexture = null;
    this._ambientTexture = null;
    this._ambientTextureStrength = 1;
    this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._reflectivityTexture = null;
    this._metallicTexture = null;
    this._metallic = null;
    this._roughness = null;
    this._metallicF0Factor = 1;
    this._metallicReflectanceColor = Color3.White();
    this._useOnlyMetallicFromMetallicReflectanceTexture = false;
    this._metallicReflectanceTexture = null;
    this._reflectanceTexture = null;
    this._microSurfaceTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._ambientColor = new Color3(0, 0, 0);
    this._albedoColor = new Color3(1, 1, 1);
    this._reflectivityColor = new Color3(1, 1, 1);
    this._reflectionColor = new Color3(1, 1, 1);
    this._emissiveColor = new Color3(0, 0, 0);
    this._microSurface = 0.9;
    this._useLightmapAsShadowmap = false;
    this._useHorizonOcclusion = true;
    this._useRadianceOcclusion = true;
    this._useAlphaFromAlbedoTexture = false;
    this._useSpecularOverAlpha = true;
    this._useMicroSurfaceFromReflectivityMapAlpha = false;
    this._useRoughnessFromMetallicTextureAlpha = true;
    this._useRoughnessFromMetallicTextureGreen = false;
    this._useMetallnessFromMetallicTextureBlue = false;
    this._useAmbientOcclusionFromMetallicTextureRed = false;
    this._useAmbientInGrayScale = false;
    this._useAutoMicroSurfaceFromReflectivityMap = false;
    this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
    this._useRadianceOverAlpha = true;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this._parallaxScaleBias = 0.05;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._alphaCutOff = 0.4;
    this._forceAlphaTest = false;
    this._useAlphaFresnel = false;
    this._useLinearAlphaFresnel = false;
    this._environmentBRDFTexture = null;
    this._forceIrradianceInFragment = false;
    this._realTimeFiltering = false;
    this._realTimeFilteringQuality = 8;
    this._forceNormalForward = false;
    this._enableSpecularAntiAliasing = false;
    this._imageProcessingObserver = null;
    this._renderTargets = new SmartArray(16);
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._unlit = false;
    this._applyDecalMapAfterDetailMap = false;
    this._debugMode = 0;
    this.debugMode = 0;
    this.debugLimit = -1;
    this.debugFactor = 1;
    this._cacheHasRenderTargetTextures = false;
    this.brdf = new PBRBRDFConfiguration(this);
    this.clearCoat = new PBRClearCoatConfiguration(this);
    this.iridescence = new PBRIridescenceConfiguration(this);
    this.anisotropy = new PBRAnisotropicConfiguration(this);
    this.sheen = new PBRSheenConfiguration(this);
    this.subSurface = new PBRSubSurfaceConfiguration(this);
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
    this.prePassConfiguration = new PrePassConfiguration();
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * @returns the name of the material class.
   */
  getClassName() {
    return "PBRBaseMaterial";
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get _disableAlphaBlending() {
    var _a;
    return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || ((_a = this.subSurface) == null ? void 0 : _a.disableAlphaBlending);
  }
  /**
   * @returns whether or not this material should be rendered in alpha blend mode.
   */
  needAlphaBlending() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
  }
  /**
   * @returns whether or not this material should be rendered in alpha test mode.
   */
  needAlphaTesting() {
    var _a;
    if (this._forceAlphaTest) {
      return true;
    }
    if ((_a = this.subSurface) == null ? void 0 : _a.disableAlphaBlending) {
      return false;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
  }
  /**
   * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
   */
  _shouldUseAlphaFromAlbedoTexture() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
  }
  /**
   * @returns whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
  }
  /**
   * @returns the texture used for the alpha test.
   */
  getAlphaTestTexture() {
    return this._albedoTexture;
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param mesh - BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
   * @param useInstances - Specifies that instances should be used.
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    var _a;
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
      subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._albedoTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (reflectionTexture.irradianceTexture) {
            if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else {
            if (!reflectionTexture.sphericalPolynomial && ((_a = reflectionTexture.getInternalTexture()) == null ? void 0 : _a._sphericalPolynomialPromise)) {
              return false;
            }
          }
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            if (!this._metallicTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else if (this._reflectivityTexture) {
            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._metallicReflectanceTexture) {
            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._reflectanceTexture) {
            if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._microSurfaceTexture) {
            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
      }
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    const previousEffect = subMesh.effect;
    const lightDisposed = defines._areLightsDisposed;
    let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
    let forceWasNotReadyPreviously = false;
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        defines.markAsUnprocessed();
        forceWasNotReadyPreviously = this.isFrozen;
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines, this._materialContext);
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Specifies if the material uses metallic roughness workflow.
   * @returns boolean specifying if the material uses metallic roughness workflow.
   */
  isMetallicWorkflow() {
    if (this._metallic != null || this._roughness != null || this._metallicTexture) {
      return true;
    }
    return false;
  }
  _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {
    this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    const scene = this.getScene();
    const engine = scene.getEngine();
    const fallbacks = new EffectFallbacks();
    let fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAX_RHS) {
      fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    if (defines.BUMP) {
      fallbacks.addFallback(fallbackRank++, "BUMP");
    }
    fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.LIGHTMAP) {
      fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.AMBIENT) {
      fallbacks.addFallback(fallbackRank++, "AMBIENT");
    }
    if (defines.EMISSIVE) {
      fallbacks.addFallback(fallbackRank++, "EMISSIVE");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    const attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    for (let i = 1; i <= 6; ++i) {
      if (defines["UV" + i]) {
        attribs.push(`uv${i === 1 ? "" : i}`);
      }
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    PrepareAttributesForInstances(attribs, defines);
    PrepareAttributesForMorphTargets(attribs, mesh, defines);
    PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    let shaderName = "pbr";
    const uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "vAmbientColor",
      "vAlbedoColor",
      "vReflectivityColor",
      "vMetallicReflectanceFactors",
      "vEmissiveColor",
      "visibility",
      "vReflectionColor",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "vAlbedoInfos",
      "vAmbientInfos",
      "vOpacityInfos",
      "vReflectionInfos",
      "vReflectionPosition",
      "vReflectionSize",
      "vEmissiveInfos",
      "vReflectivityInfos",
      "vReflectionFilteringInfo",
      "vMetallicReflectanceInfos",
      "vReflectanceInfos",
      "vMicroSurfaceSamplerInfos",
      "vBumpInfos",
      "vLightmapInfos",
      "mBones",
      "albedoMatrix",
      "ambientMatrix",
      "opacityMatrix",
      "reflectionMatrix",
      "emissiveMatrix",
      "reflectivityMatrix",
      "normalMatrix",
      "microSurfaceSamplerMatrix",
      "bumpMatrix",
      "lightmapMatrix",
      "metallicReflectanceMatrix",
      "reflectanceMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vSphericalX",
      "vSphericalY",
      "vSphericalZ",
      "vSphericalXX_ZZ",
      "vSphericalYY_ZZ",
      "vSphericalZZ",
      "vSphericalXY",
      "vSphericalYZ",
      "vSphericalZX",
      "vSphericalL00",
      "vSphericalL1_1",
      "vSphericalL10",
      "vSphericalL11",
      "vSphericalL2_2",
      "vSphericalL2_1",
      "vSphericalL20",
      "vSphericalL21",
      "vSphericalL22",
      "vReflectionMicrosurfaceInfos",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices"
    ];
    const samplers = [
      "albedoSampler",
      "reflectivitySampler",
      "ambientSampler",
      "emissiveSampler",
      "bumpSampler",
      "lightmapSampler",
      "opacitySampler",
      "reflectionSampler",
      "reflectionSamplerLow",
      "reflectionSamplerHigh",
      "irradianceSampler",
      "microSurfaceSampler",
      "environmentBrdfSampler",
      "boneSampler",
      "metallicReflectanceSampler",
      "reflectanceSampler",
      "morphTargets",
      "oitDepthSampler",
      "oitFrontColorSampler"
    ];
    const uniformBuffers = ["Material", "Scene", "Mesh"];
    const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
    this._eventInfo.fallbacks = fallbacks;
    this._eventInfo.fallbackRank = fallbackRank;
    this._eventInfo.defines = defines;
    this._eventInfo.uniforms = uniforms;
    this._eventInfo.attributes = attribs;
    this._eventInfo.samplers = samplers;
    this._eventInfo.uniformBuffersNames = uniformBuffers;
    this._eventInfo.customCode = void 0;
    this._eventInfo.mesh = mesh;
    this._eventInfo.indexParameters = indexParameters;
    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(samplers);
    addClipPlaneUniforms(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    const csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    const join = defines.toString();
    const effect = engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters,
      processFinalCode: csnrOptions.processFinalCode,
      processCodeAfterIncludes: this._eventInfo.customCode,
      multiTarget: defines.PREPASS
    }, engine);
    this._eventInfo.customCode = void 0;
    return effect;
  }
  _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {
    const scene = this.getScene();
    const engine = scene.getEngine();
    PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    PrepareDefinesForOIT(scene, defines, oit);
    defines.METALLICWORKFLOW = this.isMetallicWorkflow();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.ALBEDODIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.REFLECTIVITYDIRECTUV = 0;
        defines.MICROSURFACEMAPDIRECTUV = 0;
        defines.METALLIC_REFLECTANCEDIRECTUV = 0;
        defines.REFLECTANCEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (engine.getCaps().textureLOD) {
          defines.LODBASEDMICROSFURACE = true;
        }
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
        } else {
          defines.ALBEDO = false;
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
        } else {
          defines.OPACITY = false;
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.REFLECTION = true;
          defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
          defines.RGBDREFLECTION = reflectionTexture.isRGBD;
          defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
          defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
          if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
            defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
            if (engine._features.needTypeSuffixInShaderConstants) {
              defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
            }
            defines.REALTIME_FILTERING = true;
          } else {
            defines.REALTIME_FILTERING = false;
          }
          defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
          defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
          defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          switch (reflectionTexture.coordinatesMode) {
            case Texture.EXPLICIT_MODE:
              defines.REFLECTIONMAP_EXPLICIT = true;
              break;
            case Texture.PLANAR_MODE:
              defines.REFLECTIONMAP_PLANAR = true;
              break;
            case Texture.PROJECTION_MODE:
              defines.REFLECTIONMAP_PROJECTION = true;
              break;
            case Texture.SKYBOX_MODE:
              defines.REFLECTIONMAP_SKYBOX = true;
              break;
            case Texture.SPHERICAL_MODE:
              defines.REFLECTIONMAP_SPHERICAL = true;
              break;
            case Texture.EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MODE:
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
              break;
            case Texture.CUBIC_MODE:
            case Texture.INVCUBIC_MODE:
            default:
              defines.REFLECTIONMAP_CUBIC = true;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
              break;
          }
          if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
            if (reflectionTexture.irradianceTexture) {
              defines.USEIRRADIANCEMAP = true;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
            } else if (reflectionTexture.isCube) {
              defines.USESPHERICALFROMREFLECTIONMAP = true;
              defines.USEIRRADIANCEMAP = false;
              if (this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8) {
                defines.USESPHERICALINVERTEX = false;
              } else {
                defines.USESPHERICALINVERTEX = true;
              }
            }
          }
        } else {
          defines.REFLECTION = false;
          defines.REFLECTIONMAP_3D = false;
          defines.REFLECTIONMAP_SPHERICAL = false;
          defines.REFLECTIONMAP_PLANAR = false;
          defines.REFLECTIONMAP_CUBIC = false;
          defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
          defines.REFLECTIONMAP_PROJECTION = false;
          defines.REFLECTIONMAP_SKYBOX = false;
          defines.REFLECTIONMAP_EXPLICIT = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
          defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
          defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
          defines.INVERTCUBICMAP = false;
          defines.USESPHERICALFROMREFLECTIONMAP = false;
          defines.USEIRRADIANCEMAP = false;
          defines.USESPHERICALINVERTEX = false;
          defines.REFLECTIONMAP_OPPOSITEZ = false;
          defines.LODINREFLECTIONALPHA = false;
          defines.GAMMAREFLECTION = false;
          defines.RGBDREFLECTION = false;
          defines.LINEARSPECULARREFLECTION = false;
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
        } else {
          defines.EMISSIVE = false;
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
            defines.REFLECTIVITY_GAMMA = false;
          } else if (this._reflectivityTexture) {
            PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
            defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
          } else {
            defines.REFLECTIVITY = false;
          }
          if (this._metallicReflectanceTexture || this._reflectanceTexture) {
            defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;
            if (this._metallicReflectanceTexture) {
              PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
              defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
            } else {
              defines.METALLIC_REFLECTANCE = false;
            }
            if (this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
              PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
              defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
            } else {
              defines.REFLECTANCE = false;
            }
          } else {
            defines.METALLIC_REFLECTANCE = false;
            defines.REFLECTANCE = false;
          }
          if (this._microSurfaceTexture) {
            PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
          } else {
            defines.MICROSURFACEMAP = false;
          }
        } else {
          defines.REFLECTIVITY = false;
          defines.MICROSURFACEMAP = false;
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
          defines.OBJECTSPACE_NORMALMAP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._shouldUseAlphaFromAlbedoTexture()) {
          defines.ALPHAFROMALBEDO = true;
        } else {
          defines.ALPHAFROMALBEDO = false;
        }
      }
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if (defines._areMiscDirty) {
      PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
  }
  /**
   * Force shader compilation
   * @param mesh - Define the mesh we want to force the compilation for
   * @param onCompiled - Define a callback triggered when the compilation completes
   * @param options - Define the options used to create the compilation
   */
  forceCompilation(mesh, onCompiled, options) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
    const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
    const effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
    if (this._onEffectCreatedObservable) {
      onCreatedEffectParameters.effect = effect;
      onCreatedEffectParameters.subMesh = null;
      this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
    }
    if (effect.isReady()) {
      if (onCompiled) {
        onCompiled(this);
      }
    } else {
      effect.onCompileObservable.add(() => {
        if (onCompiled) {
          onCompiled(this);
        }
      });
    }
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("vAlbedoInfos", 2);
    ubo.addUniform("vAmbientInfos", 4);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vReflectivityInfos", 3);
    ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
    ubo.addUniform("vReflectionInfos", 2);
    ubo.addUniform("vReflectionFilteringInfo", 2);
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("albedoMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("reflectivityMatrix", 16);
    ubo.addUniform("microSurfaceSamplerMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("reflectionMatrix", 16);
    ubo.addUniform("vReflectionColor", 3);
    ubo.addUniform("vAlbedoColor", 4);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vReflectivityColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vAmbientColor", 3);
    ubo.addUniform("vDebugMode", 2);
    ubo.addUniform("vMetallicReflectanceFactors", 4);
    ubo.addUniform("vMetallicReflectanceInfos", 2);
    ubo.addUniform("metallicReflectanceMatrix", 16);
    ubo.addUniform("vReflectanceInfos", 2);
    ubo.addUniform("reflectanceMatrix", 16);
    ubo.addUniform("vSphericalL00", 3);
    ubo.addUniform("vSphericalL1_1", 3);
    ubo.addUniform("vSphericalL10", 3);
    ubo.addUniform("vSphericalL11", 3);
    ubo.addUniform("vSphericalL2_2", 3);
    ubo.addUniform("vSphericalL2_1", 3);
    ubo.addUniform("vSphericalL20", 3);
    ubo.addUniform("vSphericalL21", 3);
    ubo.addUniform("vSphericalL22", 3);
    ubo.addUniform("vSphericalX", 3);
    ubo.addUniform("vSphericalY", 3);
    ubo.addUniform("vSphericalZ", 3);
    ubo.addUniform("vSphericalXX_ZZ", 3);
    ubo.addUniform("vSphericalYY_ZZ", 3);
    ubo.addUniform("vSphericalZZ", 3);
    ubo.addUniform("vSphericalXY", 3);
    ubo.addUniform("vSphericalYZ", 3);
    ubo.addUniform("vSphericalZX", 3);
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh data.
   * @param world - The world matrix.
   * @param mesh - The BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.
   */
  bindForSubMesh(world, mesh, subMesh) {
    var _a, _b, _c;
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const engine = scene.getEngine();
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    let reflectionTexture = null;
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      reflectionTexture = this._getReflectionTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
        if (scene.texturesEnabled) {
          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
            BindTextureMatrix(this._albedoTexture, ubo, "albedo");
          }
          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
            ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
            BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
            ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
            ubo.updateFloat2("vReflectionInfos", reflectionTexture.level, 0);
            if (reflectionTexture.boundingBoxSize) {
              const cubeTexture = reflectionTexture;
              ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
              ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
            }
            if (this.realTimeFiltering) {
              const width = reflectionTexture.getSize().width;
              ubo.updateFloat2("vReflectionFilteringInfo", width, Scalar.Log2(width));
            }
            if (!defines.USEIRRADIANCEMAP) {
              const polynomials = reflectionTexture.sphericalPolynomial;
              if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                if (defines.SPHERICAL_HARMONICS) {
                  const preScaledHarmonics = polynomials.preScaledHarmonics;
                  ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
                  ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                  ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
                  ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
                  ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                  ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                  ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
                  ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
                  ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
                } else {
                  ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                  ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                  ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                  ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                  ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                  ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                  ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                  ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                  ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                }
              }
            }
            ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
          }
          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (MaterialFlags.SpecularTextureEnabled) {
            if (this._metallicTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
              BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
            } else if (this._reflectivityTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
              BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
            }
            if (this._metallicReflectanceTexture) {
              ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
              BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
            }
            if (this._reflectanceTexture && defines.REFLECTANCE) {
              ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
              BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
            }
            if (this._microSurfaceTexture) {
              ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
              BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
            BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.METALLICWORKFLOW) {
          TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
          TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
          ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
          const ior = ((_a = this.subSurface) == null ? void 0 : _a._indexOfRefraction) ?? 1.5;
          const outsideIOR = 1;
          const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
          this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
          const metallicF90 = this._metallicF0Factor;
          ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
        } else {
          ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
        }
        ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
        ubo.updateColor3("vReflectionColor", this._reflectionColor);
        if (!defines.SS_REFRACTION && ((_b = this.subSurface) == null ? void 0 : _b._linkRefractionWithTransparency)) {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
        } else {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
        }
        this._lightingInfos.x = this._directIntensity;
        this._lightingInfos.y = this._emissiveIntensity;
        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = this._specularIntensity;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
        scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
        ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
      }
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          ubo.setTexture("albedoSampler", this._albedoTexture);
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          ubo.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          ubo.setTexture("opacitySampler", this._opacityTexture);
        }
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (defines.LODBASEDMICROSFURACE) {
            ubo.setTexture("reflectionSampler", reflectionTexture);
          } else {
            ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
            ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
            ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
          }
          if (defines.USEIRRADIANCEMAP) {
            ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
          }
        }
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          ubo.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          ubo.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            ubo.setTexture("reflectivitySampler", this._metallicTexture);
          } else if (this._reflectivityTexture) {
            ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
          }
          if (this._metallicReflectanceTexture) {
            ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
          }
          if (this._reflectanceTexture && defines.REFLECTANCE) {
            ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
          }
          if (this._microSurfaceTexture) {
            ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
          }
        }
        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          ubo.setTexture("bumpSampler", this._bumpTexture);
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      bindClipPlane(this._activeEffect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS) {
        this.bindView(effect);
      }
      BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        BindMorphTargetParameters(mesh, this._activeEffect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        (_c = mesh.bakedVertexAnimationManager) == null ? void 0 : _c.bind(effect, defines.INSTANCES);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      BindLogDepth(defines, this._activeEffect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
    ubo.update();
  }
  /**
   * Returns the animatable textures.
   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
      results.push(this._albedoTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
      results.push(this._metallicTexture);
    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
      results.push(this._reflectivityTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
      results.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
      results.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
      results.push(this._microSurfaceTexture);
    }
    return results;
  }
  /**
   * Returns the texture used for reflections.
   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
   */
  _getReflectionTexture() {
    if (this._reflectionTexture) {
      return this._reflectionTexture;
    }
    return this.getScene().environmentTexture;
  }
  /**
   * Returns an array of the actively used textures.
   * @returns - Array of BaseTextures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._albedoTexture) {
      activeTextures.push(this._albedoTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._reflectivityTexture) {
      activeTextures.push(this._reflectivityTexture);
    }
    if (this._metallicTexture) {
      activeTextures.push(this._metallicTexture);
    }
    if (this._metallicReflectanceTexture) {
      activeTextures.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture) {
      activeTextures.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture) {
      activeTextures.push(this._microSurfaceTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    return activeTextures;
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._albedoTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._reflectivityTexture === texture) {
      return true;
    }
    if (this._metallicTexture === texture) {
      return true;
    }
    if (this._metallicReflectanceTexture === texture) {
      return true;
    }
    if (this._reflectanceTexture === texture) {
      return true;
    }
    if (this._microSurfaceTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Sets the required values to the prepass renderer.
   * It can't be sets when subsurface scattering of this material is disabled.
   * When scene have ability to enable subsurface prepass effect, it will enable.
   * @returns - If prepass is enabled or not.
   */
  setPrePassRenderer() {
    var _a;
    if (!((_a = this.subSurface) == null ? void 0 : _a.isScatteringEnabled)) {
      return false;
    }
    const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
    if (subSurfaceConfiguration) {
      subSurfaceConfiguration.enabled = true;
    }
    return true;
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeEffect - Forces the disposal of effects.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      (_a = this._albedoTexture) == null ? void 0 : _a.dispose();
      (_b = this._ambientTexture) == null ? void 0 : _b.dispose();
      (_c = this._opacityTexture) == null ? void 0 : _c.dispose();
      (_d = this._reflectionTexture) == null ? void 0 : _d.dispose();
      (_e = this._emissiveTexture) == null ? void 0 : _e.dispose();
      (_f = this._metallicTexture) == null ? void 0 : _f.dispose();
      (_g = this._reflectivityTexture) == null ? void 0 : _g.dispose();
      (_h = this._bumpTexture) == null ? void 0 : _h.dispose();
      (_i = this._lightmapTexture) == null ? void 0 : _i.dispose();
      (_j = this._metallicReflectanceTexture) == null ? void 0 : _j.dispose();
      (_k = this._reflectanceTexture) == null ? void 0 : _k.dispose();
      (_l = this._microSurfaceTexture) == null ? void 0 : _l.dispose();
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
};
PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
__decorate([
  serializeAsImageProcessingConfiguration()
], PBRBaseMaterial.prototype, "_imageProcessingConfiguration", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBaseMaterial.prototype, "debugMode", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial = class _PBRMaterial extends PBRBaseMaterial {
  /**
   * Stores the refracted light information in a texture.
   */
  get refractionTexture() {
    return this.subSurface.refractionTexture;
  }
  set refractionTexture(value) {
    this.subSurface.refractionTexture = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    } else if (!this.subSurface.linkRefractionWithTransparency) {
      this.subSurface.isRefractionEnabled = false;
    }
  }
  /**
   * Index of refraction of the material base layer.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This does not only impact refraction but also the Base F0 of Dielectric Materials.
   *
   * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
   */
  get indexOfRefraction() {
    return this.subSurface.indexOfRefraction;
  }
  set indexOfRefraction(value) {
    this.subSurface.indexOfRefraction = value;
  }
  /**
   * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
   */
  get invertRefractionY() {
    return this.subSurface.invertRefractionY;
  }
  set invertRefractionY(value) {
    this.subSurface.invertRefractionY = value;
  }
  /**
   * This parameters will make the material used its opacity to control how much it is refracting against not.
   * Materials half opaque for instance using refraction could benefit from this control.
   */
  get linkRefractionWithTransparency() {
    return this.subSurface.linkRefractionWithTransparency;
  }
  set linkRefractionWithTransparency(value) {
    this.subSurface.linkRefractionWithTransparency = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    }
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  get usePhysicalLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  set usePhysicalLightFalloff(value) {
    if (value !== this.usePhysicalLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  get useGLTFLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  set useGLTFLightFalloff(value) {
    if (value !== this.useGLTFLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * Gets the image processing configuration used either in this material.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Sets the Default image processing configuration used either in the this material.
   *
   * If sets to null, the scene one is in use.
   */
  set imageProcessingConfiguration(value) {
    this._attachImageProcessingConfiguration(value);
    this._markAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set cameraColorCurvesEnabled(value) {
    this.imageProcessingConfiguration.colorCurvesEnabled = value;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  set cameraColorGradingEnabled(value) {
    this.imageProcessingConfiguration.colorGradingEnabled = value;
  }
  /**
   * Gets whether tonemapping is enabled or not.
   */
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  /**
   * Sets whether tonemapping is enabled or not
   */
  set cameraToneMappingEnabled(value) {
    this._imageProcessingConfiguration.toneMappingEnabled = value;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  /**
   * The camera exposure used on this material.
   * This property is here and not in the camera to allow controlling exposure without full screen post process.
   * This corresponds to a photographic exposure.
   */
  set cameraExposure(value) {
    this._imageProcessingConfiguration.exposure = value;
  }
  /**
   * Gets The camera contrast used on this material.
   */
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  /**
   * Sets The camera contrast used on this material.
   */
  set cameraContrast(value) {
    this._imageProcessingConfiguration.contrast = value;
  }
  /**
   * Gets the Color Grading 2D Lookup Texture.
   */
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  /**
   * Sets the Color Grading 2D Lookup Texture.
   */
  set cameraColorGradingTexture(value) {
    this._imageProcessingConfiguration.colorGradingTexture = value;
  }
  /**
   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  /**
   * The color grading curves provide additional color adjustment that is applied after any color grading transform (3D LUT).
   * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
   * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
   * corresponding to low luminance, medium luminance, and high luminance areas respectively.
   */
  set cameraColorCurves(value) {
    this._imageProcessingConfiguration.colorCurves = value;
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   */
  constructor(name50, scene) {
    super(name50, scene);
    this.directIntensity = 1;
    this.emissiveIntensity = 1;
    this.environmentIntensity = 1;
    this.specularIntensity = 1;
    this.disableBumpMap = false;
    this.ambientTextureStrength = 1;
    this.ambientTextureImpactOnAnalyticalLights = _PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this.metallicF0Factor = 1;
    this.metallicReflectanceColor = Color3.White();
    this.useOnlyMetallicFromMetallicReflectanceTexture = false;
    this.ambientColor = new Color3(0, 0, 0);
    this.albedoColor = new Color3(1, 1, 1);
    this.reflectivityColor = new Color3(1, 1, 1);
    this.reflectionColor = new Color3(1, 1, 1);
    this.emissiveColor = new Color3(0, 0, 0);
    this.microSurface = 1;
    this.useLightmapAsShadowmap = false;
    this.useAlphaFromAlbedoTexture = false;
    this.forceAlphaTest = false;
    this.alphaCutOff = 0.4;
    this.useSpecularOverAlpha = true;
    this.useMicroSurfaceFromReflectivityMapAlpha = false;
    this.useRoughnessFromMetallicTextureAlpha = true;
    this.useRoughnessFromMetallicTextureGreen = false;
    this.useMetallnessFromMetallicTextureBlue = false;
    this.useAmbientOcclusionFromMetallicTextureRed = false;
    this.useAmbientInGrayScale = false;
    this.useAutoMicroSurfaceFromReflectivityMap = false;
    this.useRadianceOverAlpha = true;
    this.useObjectSpaceNormalMap = false;
    this.useParallax = false;
    this.useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this.disableLighting = false;
    this.forceIrradianceInFragment = false;
    this.maxSimultaneousLights = 4;
    this.invertNormalMapX = false;
    this.invertNormalMapY = false;
    this.twoSidedLighting = false;
    this.useAlphaFresnel = false;
    this.useLinearAlphaFresnel = false;
    this.environmentBRDFTexture = null;
    this.forceNormalForward = false;
    this.enableSpecularAntiAliasing = false;
    this.useHorizonOcclusion = true;
    this.useRadianceOcclusion = true;
    this.unlit = false;
    this.applyDecalMapAfterDetailMap = false;
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
  }
  /**
   * @returns the name of this material class.
   */
  getClassName() {
    return "PBRMaterial";
  }
  /**
   * Makes a duplicate of the current material.
   * @param name - name to use for the new material.
   * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
   * @param rootUrl defines the root URL to use to load textures
   * @returns cloned material instance
   */
  clone(name50, cloneTexturesOnlyOnce = true, rootUrl = "") {
    const clone = SerializationHelper.Clone(() => new _PBRMaterial(name50, this.getScene()), this, { cloneTexturesOnlyOnce });
    clone.id = name50;
    clone.name = name50;
    this.stencil.copyTo(clone.stencil);
    this._clonePlugins(clone, rootUrl);
    return clone;
  }
  /**
   * Serializes this PBR Material.
   * @returns - An object with the serialized material.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.PBRMaterial";
    return serializationObject;
  }
  // Statics
  /**
   * Parses a PBR Material from a serialized object.
   * @param source - Serialized object.
   * @param scene - BJS scene instance.
   * @param rootUrl - url for the scene object
   * @returns - PBRMaterial
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _PBRMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    Material._ParsePlugins(source, material, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    if (source.iridescence) {
      material.iridescence.parse(source.iridescence, scene, rootUrl);
    }
    return material;
  }
};
PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "directIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "specularIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "disableBumpMap", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureStrength", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallic", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicF0Factor", void 0);
__decorate([
  serializeAsColor3(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurfaceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
], PBRMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serializeAsColor3("ambient"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientColor", void 0);
__decorate([
  serializeAsColor3("albedo"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoColor", void 0);
__decorate([
  serializeAsColor3("reflectivity"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityColor", void 0);
__decorate([
  serializeAsColor3("reflection"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionColor", void 0);
__decorate([
  serializeAsColor3("emissive"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurface", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "forceAlphaTest", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
__decorate([
  serialize()
], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
__decorate([
  serialize()
], PBRMaterial.prototype, "useGLTFLightFalloff", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAlphaFresnel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceNormalForward", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "unlit", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
RegisterClass("BABYLON.PBRMaterial", PBRMaterial);

// node_modules/@babylonjs/core/Misc/workerPool.js
var WorkerPool = class {
  /**
   * Constructor
   * @param workers Array of workers to use for actions
   */
  constructor(workers) {
    this._pendingActions = new Array();
    this._workerInfos = workers.map((worker) => ({
      workerPromise: Promise.resolve(worker),
      idle: true
    }));
  }
  /**
   * Terminates all workers and clears any pending actions.
   */
  dispose() {
    for (const workerInfo of this._workerInfos) {
      workerInfo.workerPromise.then((worker) => {
        worker.terminate();
      });
    }
    this._workerInfos.length = 0;
    this._pendingActions.length = 0;
  }
  /**
   * Pushes an action to the worker pool. If all the workers are active, the action will be
   * pended until a worker has completed its action.
   * @param action The action to perform. Call onComplete when the action is complete.
   */
  push(action) {
    if (!this._executeOnIdleWorker(action)) {
      this._pendingActions.push(action);
    }
  }
  _executeOnIdleWorker(action) {
    for (const workerInfo of this._workerInfos) {
      if (workerInfo.idle) {
        this._execute(workerInfo, action);
        return true;
      }
    }
    return false;
  }
  _execute(workerInfo, action) {
    workerInfo.idle = false;
    workerInfo.workerPromise.then((worker) => {
      action(worker, () => {
        const nextAction = this._pendingActions.shift();
        if (nextAction) {
          this._execute(workerInfo, nextAction);
        } else {
          workerInfo.idle = true;
        }
      });
    });
  }
};
var AutoReleaseWorkerPool = class _AutoReleaseWorkerPool extends WorkerPool {
  constructor(maxWorkers, createWorkerAsync, options = _AutoReleaseWorkerPool.DefaultOptions) {
    super([]);
    this._maxWorkers = maxWorkers;
    this._createWorkerAsync = createWorkerAsync;
    this._options = options;
  }
  push(action) {
    if (!this._executeOnIdleWorker(action)) {
      if (this._workerInfos.length < this._maxWorkers) {
        const workerInfo = {
          workerPromise: this._createWorkerAsync(),
          idle: false
        };
        this._workerInfos.push(workerInfo);
        this._execute(workerInfo, action);
      } else {
        this._pendingActions.push(action);
      }
    }
  }
  _execute(workerInfo, action) {
    if (workerInfo.timeoutId) {
      clearTimeout(workerInfo.timeoutId);
      delete workerInfo.timeoutId;
    }
    super._execute(workerInfo, (worker, onComplete) => {
      action(worker, () => {
        onComplete();
        if (workerInfo.idle) {
          workerInfo.timeoutId = setTimeout(() => {
            workerInfo.workerPromise.then((worker2) => {
              worker2.terminate();
            });
            const indexOf = this._workerInfos.indexOf(workerInfo);
            if (indexOf !== -1) {
              this._workerInfos.splice(indexOf, 1);
            }
          }, this._options.idleTimeElapsedBeforeRelease);
        }
      });
    });
  }
};
AutoReleaseWorkerPool.DefaultOptions = {
  idleTimeElapsedBeforeRelease: 1e3
};

// node_modules/@babylonjs/core/Misc/timer.js
var TimerState;
(function(TimerState2) {
  TimerState2[TimerState2["INIT"] = 0] = "INIT";
  TimerState2[TimerState2["STARTED"] = 1] = "STARTED";
  TimerState2[TimerState2["ENDED"] = 2] = "ENDED";
})(TimerState || (TimerState = {}));
function setAndStartTimer(options) {
  let timer = 0;
  const startTime = Date.now();
  options.observableParameters = options.observableParameters ?? {};
  const observer = options.contextObservable.add((payload) => {
    const now = Date.now();
    timer = now - startTime;
    const data = {
      startTime,
      currentTime: now,
      deltaTime: timer,
      completeRate: timer / options.timeout,
      payload
    };
    options.onTick && options.onTick(data);
    if (options.breakCondition && options.breakCondition()) {
      options.contextObservable.remove(observer);
      options.onAborted && options.onAborted(data);
    }
    if (timer >= options.timeout) {
      options.contextObservable.remove(observer);
      options.onEnded && options.onEnded(data);
    }
  }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);
  return observer;
}
var AdvancedTimer = class {
  /**
   * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.
   * @param options construction options for this advanced timer
   */
  constructor(options) {
    this.onEachCountObservable = new Observable();
    this.onTimerAbortedObservable = new Observable();
    this.onTimerEndedObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this._observer = null;
    this._breakOnNextTick = false;
    this._tick = (payload) => {
      const now = Date.now();
      this._timer = now - this._startTime;
      const data = {
        startTime: this._startTime,
        currentTime: now,
        deltaTime: this._timer,
        completeRate: this._timer / this._timeToEnd,
        payload
      };
      const shouldBreak = this._breakOnNextTick || this._breakCondition(data);
      if (shouldBreak || this._timer >= this._timeToEnd) {
        this._stop(data, shouldBreak);
      } else {
        this.onEachCountObservable.notifyObservers(data);
      }
    };
    this._setState(TimerState.INIT);
    this._contextObservable = options.contextObservable;
    this._observableParameters = options.observableParameters ?? {};
    this._breakCondition = options.breakCondition ?? (() => false);
    this._timeToEnd = options.timeout;
    if (options.onEnded) {
      this.onTimerEndedObservable.add(options.onEnded);
    }
    if (options.onTick) {
      this.onEachCountObservable.add(options.onTick);
    }
    if (options.onAborted) {
      this.onTimerAbortedObservable.add(options.onAborted);
    }
  }
  /**
   * set a breaking condition for this timer. Default is to never break during count
   * @param predicate the new break condition. Returns true to break, false otherwise
   */
  set breakCondition(predicate) {
    this._breakCondition = predicate;
  }
  /**
   * Reset ALL associated observables in this advanced timer
   */
  clearObservables() {
    this.onEachCountObservable.clear();
    this.onTimerAbortedObservable.clear();
    this.onTimerEndedObservable.clear();
    this.onStateChangedObservable.clear();
  }
  /**
   * Will start a new iteration of this timer. Only one instance of this timer can run at a time.
   *
   * @param timeToEnd how much time to measure until timer ended
   */
  start(timeToEnd = this._timeToEnd) {
    if (this._state === TimerState.STARTED) {
      throw new Error("Timer already started. Please stop it before starting again");
    }
    this._timeToEnd = timeToEnd;
    this._startTime = Date.now();
    this._timer = 0;
    this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);
    this._setState(TimerState.STARTED);
  }
  /**
   * Will force a stop on the next tick.
   */
  stop() {
    if (this._state !== TimerState.STARTED) {
      return;
    }
    this._breakOnNextTick = true;
  }
  /**
   * Dispose this timer, clearing all resources
   */
  dispose() {
    if (this._observer) {
      this._contextObservable.remove(this._observer);
    }
    this.clearObservables();
  }
  _setState(newState) {
    this._state = newState;
    this.onStateChangedObservable.notifyObservers(this._state);
  }
  _stop(data, aborted = false) {
    this._contextObservable.remove(this._observer);
    this._setState(TimerState.ENDED);
    if (aborted) {
      this.onTimerAbortedObservable.notifyObservers(data);
    } else {
      this.onTimerEndedObservable.notifyObservers(data);
    }
  }
};

// node_modules/@babylonjs/core/Lights/pointLight.js
Node.AddNodeConstructor("Light_Type_0", (name50, scene) => {
  return () => new PointLight(name50, Vector3.Zero(), scene);
});
var PointLight = class extends ShadowLight {
  /**
   * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   * This specifies what angle the shadow will use to be created.
   *
   * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
   */
  get shadowAngle() {
    return this._shadowAngle;
  }
  /**
   * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   * This specifies what angle the shadow will use to be created.
   *
   * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
   */
  set shadowAngle(value) {
    this._shadowAngle = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the direction if it has been set.
   * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   */
  get direction() {
    return this._direction;
  }
  /**
   * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
   */
  set direction(value) {
    const previousNeedCube = this.needCube();
    this._direction = value;
    if (this.needCube() !== previousNeedCube && this._shadowGenerators) {
      const iterator = this._shadowGenerators.values();
      for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
        const shadowGenerator = key.value;
        shadowGenerator.recreateShadowMap();
      }
    }
  }
  /**
   * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
   * A PointLight emits the light in every direction.
   * It can cast shadows.
   * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
   * ```javascript
   * var pointLight = new PointLight("pl", camera.position, scene);
   * ```
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The light friendly name
   * @param position The position of the point light in the scene
   * @param scene The scene the lights belongs to
   */
  constructor(name50, position, scene) {
    super(name50, scene);
    this._shadowAngle = Math.PI / 2;
    this.position = position;
  }
  /**
   * Returns the string "PointLight"
   * @returns the class name
   */
  getClassName() {
    return "PointLight";
  }
  /**
   * Returns the integer 0.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  getTypeID() {
    return Light.LIGHTTYPEID_POINTLIGHT;
  }
  /**
   * Specifies whether or not the shadowmap should be a cube texture.
   * @returns true if the shadowmap needs to be a cube texture.
   */
  needCube() {
    return !this.direction;
  }
  /**
   * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
   * @param faceIndex The index of the face we are computed the direction to generate shadow
   * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true
   */
  getShadowDirection(faceIndex) {
    if (this.direction) {
      return super.getShadowDirection(faceIndex);
    } else {
      switch (faceIndex) {
        case 0:
          return new Vector3(1, 0, 0);
        case 1:
          return new Vector3(-1, 0, 0);
        case 2:
          return new Vector3(0, -1, 0);
        case 3:
          return new Vector3(0, 1, 0);
        case 4:
          return new Vector3(0, 0, 1);
        case 5:
          return new Vector3(0, 0, -1);
      }
    }
    return Vector3.Zero();
  }
  /**
   * Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
   * - fov = PI / 2
   * - aspect ratio : 1.0
   * - z-near and far equal to the active camera minZ and maxZ.
   * Returns the PointLight.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("vLightFalloff", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The point light
   */
  transferToEffect(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, lightIndex);
    } else {
      this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, 0, lightIndex);
    }
    this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);
    } else {
      effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);
    }
    return this;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["POINTLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], PointLight.prototype, "shadowAngle", null);
RegisterClass("BABYLON.PointLight", PointLight);

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget = class _MorphTarget {
  /**
   * Gets or sets the influence of this target (ie. its weight in the overall morphing)
   */
  get influence() {
    return this._influence;
  }
  set influence(influence) {
    if (this._influence === influence) {
      return;
    }
    const previous = this._influence;
    this._influence = influence;
    if (this.onInfluenceChanged.hasObservers()) {
      this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
    }
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    if (!this._animationPropertiesOverride && this._scene) {
      return this._scene.animationPropertiesOverride;
    }
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /**
   * Creates a new MorphTarget
   * @param name defines the name of the target
   * @param influence defines the influence to use
   * @param scene defines the scene the morphtarget belongs to
   */
  constructor(name50, influence = 0, scene = null) {
    this.name = name50;
    this.animations = [];
    this._positions = null;
    this._normals = null;
    this._tangents = null;
    this._uvs = null;
    this._uniqueId = 0;
    this.onInfluenceChanged = new Observable();
    this._onDataLayoutChanged = new Observable();
    this._animationPropertiesOverride = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.influence = influence;
    if (this._scene) {
      this._uniqueId = this._scene.getUniqueId();
    }
  }
  /**
   * Gets the unique ID of this manager
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets a boolean defining if the target contains position data
   */
  get hasPositions() {
    return !!this._positions;
  }
  /**
   * Gets a boolean defining if the target contains normal data
   */
  get hasNormals() {
    return !!this._normals;
  }
  /**
   * Gets a boolean defining if the target contains tangent data
   */
  get hasTangents() {
    return !!this._tangents;
  }
  /**
   * Gets a boolean defining if the target contains texture coordinates data
   */
  get hasUVs() {
    return !!this._uvs;
  }
  /**
   * Affects position data to this target
   * @param data defines the position data to use
   */
  setPositions(data) {
    const hadPositions = this.hasPositions;
    this._positions = data;
    if (hadPositions !== this.hasPositions) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  }
  /**
   * Gets the position data stored in this target
   * @returns a FloatArray containing the position data (or null if not present)
   */
  getPositions() {
    return this._positions;
  }
  /**
   * Affects normal data to this target
   * @param data defines the normal data to use
   */
  setNormals(data) {
    const hadNormals = this.hasNormals;
    this._normals = data;
    if (hadNormals !== this.hasNormals) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  }
  /**
   * Gets the normal data stored in this target
   * @returns a FloatArray containing the normal data (or null if not present)
   */
  getNormals() {
    return this._normals;
  }
  /**
   * Affects tangent data to this target
   * @param data defines the tangent data to use
   */
  setTangents(data) {
    const hadTangents = this.hasTangents;
    this._tangents = data;
    if (hadTangents !== this.hasTangents) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  }
  /**
   * Gets the tangent data stored in this target
   * @returns a FloatArray containing the tangent data (or null if not present)
   */
  getTangents() {
    return this._tangents;
  }
  /**
   * Affects texture coordinates data to this target
   * @param data defines the texture coordinates data to use
   */
  setUVs(data) {
    const hadUVs = this.hasUVs;
    this._uvs = data;
    if (hadUVs !== this.hasUVs) {
      this._onDataLayoutChanged.notifyObservers(void 0);
    }
  }
  /**
   * Gets the texture coordinates data stored in this target
   * @returns a FloatArray containing the texture coordinates data (or null if not present)
   */
  getUVs() {
    return this._uvs;
  }
  /**
   * Clone the current target
   * @returns a new MorphTarget
   */
  clone() {
    const newOne = SerializationHelper.Clone(() => new _MorphTarget(this.name, this.influence, this._scene), this);
    newOne._positions = this._positions;
    newOne._normals = this._normals;
    newOne._tangents = this._tangents;
    newOne._uvs = this._uvs;
    return newOne;
  }
  /**
   * Serializes the current target into a Serialization object
   * @returns the serialized object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.influence = this.influence;
    serializationObject.positions = Array.prototype.slice.call(this.getPositions());
    if (this.id != null) {
      serializationObject.id = this.id;
    }
    if (this.hasNormals) {
      serializationObject.normals = Array.prototype.slice.call(this.getNormals());
    }
    if (this.hasTangents) {
      serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
    }
    if (this.hasUVs) {
      serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  }
  /**
   * Returns the string "MorphTarget"
   * @returns "MorphTarget"
   */
  getClassName() {
    return "MorphTarget";
  }
  // Statics
  /**
   * Creates a new target from serialized data
   * @param serializationObject defines the serialized data to use
   * @param scene defines the hosting scene
   * @returns a new MorphTarget
   */
  static Parse(serializationObject, scene) {
    const result = new _MorphTarget(serializationObject.name, serializationObject.influence);
    result.setPositions(serializationObject.positions);
    if (serializationObject.id != null) {
      result.id = serializationObject.id;
    }
    if (serializationObject.normals) {
      result.setNormals(serializationObject.normals);
    }
    if (serializationObject.tangents) {
      result.setTangents(serializationObject.tangents);
    }
    if (serializationObject.uvs) {
      result.setUVs(serializationObject.uvs);
    }
    if (serializationObject.animations) {
      for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
        const parsedAnimation = serializationObject.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          result.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      if (serializationObject.autoAnimate && scene) {
        scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1);
      }
    }
    return result;
  }
  /**
   * Creates a MorphTarget from mesh data
   * @param mesh defines the source mesh
   * @param name defines the name to use for the new target
   * @param influence defines the influence to attach to the target
   * @returns a new MorphTarget
   */
  static FromMesh(mesh, name50, influence) {
    if (!name50) {
      name50 = mesh.name;
    }
    const result = new _MorphTarget(name50, influence, mesh.getScene());
    result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
    if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
    }
    return result;
  }
};
__decorate([
  serialize()
], MorphTarget.prototype, "id", void 0);

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray = class _RawTexture2DArray extends Texture {
  /**
   * Gets the number of layers of the texture
   */
  get depth() {
    return this._depth;
  }
  /**
   * Create a new RawTexture2DArray
   * @param data defines the data of the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param depth defines the number of layers of the texture
   * @param format defines the texture format to use
   * @param scene defines the hosting scene
   * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)
   * @param invertY defines if texture must be stored with Y axis inverted
   * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)
   * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_INT, Engine.TEXTURETYPE_FLOAT...)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   */
  constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {
    super(null, scene, !generateMipMaps, invertY);
    this.format = format;
    this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);
    this._depth = depth;
    this.is2DArray = true;
  }
  /**
   * Update the texture with new data
   * @param data defines the data to store in the texture
   */
  update(data) {
    if (!this._texture) {
      return;
    }
    this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
  }
  /**
   * Creates a RGBA texture from some data.
   * @param data Define the texture data
   * @param width Define the width of the texture
   * @param height Define the height of the texture
   * @param depth defines the number of layers of the texture
   * @param scene defines the scene the texture will belong to
   * @param generateMipMaps Define whether or not to create mip maps for the texture
   * @param invertY define if the data should be flipped on Y when uploaded to the GPU
   * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)
   * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)
   * @returns the RGBA texture
   */
  static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {
    return new _RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
  }
};

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager = class _MorphTargetManager {
  /**
   * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers
   */
  set areUpdatesFrozen(block) {
    if (block) {
      this._blockCounter++;
    } else {
      this._blockCounter--;
      if (this._blockCounter <= 0) {
        this._blockCounter = 0;
        this._syncActiveTargets(true);
      }
    }
  }
  get areUpdatesFrozen() {
    return this._blockCounter > 0;
  }
  /**
   * Creates a new MorphTargetManager
   * @param scene defines the current scene
   */
  constructor(scene = null) {
    this._targets = new Array();
    this._targetInfluenceChangedObservers = new Array();
    this._targetDataLayoutChangedObservers = new Array();
    this._activeTargets = new SmartArray(16);
    this._supportsNormals = false;
    this._supportsTangents = false;
    this._supportsUVs = false;
    this._vertexCount = 0;
    this._textureVertexStride = 0;
    this._textureWidth = 0;
    this._textureHeight = 1;
    this._uniqueId = 0;
    this._tempInfluences = new Array();
    this._canUseTextureForTargets = false;
    this._blockCounter = 0;
    this._parentContainer = null;
    this.optimizeInfluencers = true;
    this.enableNormalMorphing = true;
    this.enableTangentMorphing = true;
    this.enableUVMorphing = true;
    this._numMaxInfluencers = 0;
    this._useTextureToStoreTargets = true;
    if (!scene) {
      scene = EngineStore.LastCreatedScene;
    }
    this._scene = scene;
    if (this._scene) {
      this._scene.addMorphTargetManager(this);
      this._uniqueId = this._scene.getUniqueId();
      const engineCaps = this._scene.getEngine().getCaps();
      this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;
    }
  }
  /**
   * Gets or sets the maximum number of influencers (targets) (default value: 0).
   * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.
   * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.
   * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.
   * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.
   * Note that this property has no effect if "useTextureToStoreTargets" is false.
   */
  get numMaxInfluencers() {
    return this._numMaxInfluencers;
  }
  set numMaxInfluencers(value) {
    if (this._numMaxInfluencers === value) {
      return;
    }
    this._numMaxInfluencers = value;
    this._syncActiveTargets(true);
  }
  /**
   * Gets the unique ID of this manager
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets the number of vertices handled by this manager
   */
  get vertexCount() {
    return this._vertexCount;
  }
  /**
   * Gets a boolean indicating if this manager supports morphing of normals
   */
  get supportsNormals() {
    return this._supportsNormals && this.enableNormalMorphing;
  }
  /**
   * Gets a boolean indicating if this manager supports morphing of tangents
   */
  get supportsTangents() {
    return this._supportsTangents && this.enableTangentMorphing;
  }
  /**
   * Gets a boolean indicating if this manager supports morphing of texture coordinates
   */
  get supportsUVs() {
    return this._supportsUVs && this.enableUVMorphing;
  }
  /**
   * Gets the number of targets stored in this manager
   */
  get numTargets() {
    return this._targets.length;
  }
  /**
   * Gets the number of influencers (ie. the number of targets with influences > 0)
   */
  get numInfluencers() {
    return this._activeTargets.length;
  }
  /**
   * Gets the list of influences (one per target)
   */
  get influences() {
    return this._influences;
  }
  /**
   * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).
   * Please note that this option is not available if the hardware does not support it
   */
  get useTextureToStoreTargets() {
    return this._useTextureToStoreTargets;
  }
  set useTextureToStoreTargets(value) {
    this._useTextureToStoreTargets = value;
  }
  /**
   * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)
   */
  get isUsingTextureForTargets() {
    var _a;
    return _MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !((_a = this._scene) == null ? void 0 : _a.getEngine().getCaps().disableMorphTargetTexture);
  }
  /**
   * Gets the active target at specified index. An active target is a target with an influence > 0
   * @param index defines the index to check
   * @returns the requested target
   */
  getActiveTarget(index) {
    return this._activeTargets.data[index];
  }
  /**
   * Gets the target at specified index
   * @param index defines the index to check
   * @returns the requested target
   */
  getTarget(index) {
    return this._targets[index];
  }
  /**
   * Gets the first target with the specified name
   * @param name defines the name to check
   * @returns the requested target
   */
  getTargetByName(name50) {
    for (const target of this._targets) {
      if (target.name === name50) {
        return target;
      }
    }
    return null;
  }
  /**
   * Add a new target to this manager
   * @param target defines the target to add
   */
  addTarget(target) {
    this._targets.push(target);
    this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {
      this._syncActiveTargets(needUpdate);
    }));
    this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {
      this._syncActiveTargets(true);
    }));
    this._syncActiveTargets(true);
  }
  /**
   * Removes a target from the manager
   * @param target defines the target to remove
   */
  removeTarget(target) {
    const index = this._targets.indexOf(target);
    if (index >= 0) {
      this._targets.splice(index, 1);
      target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
      target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
      this._syncActiveTargets(true);
    }
    if (this._scene) {
      this._scene.stopAnimation(target);
    }
  }
  /**
   * @internal
   */
  _bind(effect) {
    effect.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight);
    effect.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices);
    effect.setTexture("morphTargets", this._targetStoreTexture);
    effect.setInt("morphTargetCount", this.numInfluencers);
  }
  /**
   * Clone the current manager
   * @returns a new MorphTargetManager
   */
  clone() {
    const copy = new _MorphTargetManager(this._scene);
    for (const target of this._targets) {
      copy.addTarget(target.clone());
    }
    copy.enableNormalMorphing = this.enableNormalMorphing;
    copy.enableTangentMorphing = this.enableTangentMorphing;
    copy.enableUVMorphing = this.enableUVMorphing;
    return copy;
  }
  /**
   * Serializes the current manager into a Serialization object
   * @returns the serialized object
   */
  serialize() {
    const serializationObject = {};
    serializationObject.id = this.uniqueId;
    serializationObject.targets = [];
    for (const target of this._targets) {
      serializationObject.targets.push(target.serialize());
    }
    return serializationObject;
  }
  _syncActiveTargets(needUpdate) {
    if (this.areUpdatesFrozen) {
      return;
    }
    let influenceCount = 0;
    this._activeTargets.reset();
    this._supportsNormals = true;
    this._supportsTangents = true;
    this._supportsUVs = true;
    this._vertexCount = 0;
    if (this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount) {
      this.useTextureToStoreTargets = false;
    }
    if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {
      this._morphTargetTextureIndices = new Float32Array(this._targets.length);
    }
    let targetIndex = -1;
    for (const target of this._targets) {
      targetIndex++;
      if (target.influence === 0 && this.optimizeInfluencers) {
        continue;
      }
      if (this._activeTargets.length >= _MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {
        break;
      }
      this._activeTargets.push(target);
      this._morphTargetTextureIndices[influenceCount] = targetIndex;
      this._tempInfluences[influenceCount++] = target.influence;
      this._supportsNormals = this._supportsNormals && target.hasNormals;
      this._supportsTangents = this._supportsTangents && target.hasTangents;
      this._supportsUVs = this._supportsUVs && target.hasUVs;
      const positions = target.getPositions();
      if (positions) {
        const vertexCount = positions.length / 3;
        if (this._vertexCount === 0) {
          this._vertexCount = vertexCount;
        } else if (this._vertexCount !== vertexCount) {
          Logger.Error("Incompatible target. Targets must all have the same vertices count.");
          return;
        }
      }
    }
    if (this._morphTargetTextureIndices.length !== influenceCount) {
      this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);
    }
    if (!this._influences || this._influences.length !== influenceCount) {
      this._influences = new Float32Array(influenceCount);
    }
    for (let index = 0; index < influenceCount; index++) {
      this._influences[index] = this._tempInfluences[index];
    }
    if (needUpdate) {
      this.synchronize();
    }
  }
  /**
   * Synchronize the targets with all the meshes using this morph target manager
   */
  synchronize() {
    if (!this._scene || this.areUpdatesFrozen) {
      return;
    }
    if (this.isUsingTextureForTargets && (this._vertexCount || this.numMaxInfluencers > 0)) {
      this._textureVertexStride = 1;
      if (this._supportsNormals) {
        this._textureVertexStride++;
      }
      if (this._supportsTangents) {
        this._textureVertexStride++;
      }
      if (this._supportsUVs) {
        this._textureVertexStride++;
      }
      this._textureWidth = this._vertexCount * this._textureVertexStride || 1;
      this._textureHeight = 1;
      const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;
      if (this._textureWidth > maxTextureSize) {
        this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);
        this._textureWidth = maxTextureSize;
      }
      let mustUpdateTexture = true;
      if (this._targetStoreTexture) {
        const textureSize = this._targetStoreTexture.getSize();
        if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {
          mustUpdateTexture = false;
        }
      }
      if (mustUpdateTexture) {
        if (this._targetStoreTexture) {
          this._targetStoreTexture.dispose();
        }
        const targetCount = this._targets.length;
        const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);
        let offset = 0;
        for (let index = 0; index < targetCount; index++) {
          const target = this._targets[index];
          const positions = target.getPositions();
          const normals = target.getNormals();
          const uvs = target.getUVs();
          const tangents = target.getTangents();
          if (!positions) {
            if (index === 0) {
              Logger.Error("Invalid morph target. Target must have positions.");
            }
            return;
          }
          offset = index * this._textureWidth * this._textureHeight * 4;
          for (let vertex = 0; vertex < this._vertexCount; vertex++) {
            data[offset] = positions[vertex * 3];
            data[offset + 1] = positions[vertex * 3 + 1];
            data[offset + 2] = positions[vertex * 3 + 2];
            offset += 4;
            if (this._supportsNormals && normals) {
              data[offset] = normals[vertex * 3];
              data[offset + 1] = normals[vertex * 3 + 1];
              data[offset + 2] = normals[vertex * 3 + 2];
              offset += 4;
            }
            if (this._supportsUVs && uvs) {
              data[offset] = uvs[vertex * 2];
              data[offset + 1] = uvs[vertex * 2 + 1];
              offset += 4;
            }
            if (this._supportsTangents && tangents) {
              data[offset] = tangents[vertex * 3];
              data[offset + 1] = tangents[vertex * 3 + 1];
              data[offset + 2] = tangents[vertex * 3 + 2];
              offset += 4;
            }
          }
        }
        this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);
      }
    }
    for (const mesh of this._scene.meshes) {
      if (mesh.morphTargetManager === this) {
        mesh._syncGeometryWithMorphTargetManager();
      }
    }
  }
  /**
   * Release all resources
   */
  dispose() {
    if (this._targetStoreTexture) {
      this._targetStoreTexture.dispose();
    }
    this._targetStoreTexture = null;
    if (this._scene) {
      this._scene.removeMorphTargetManager(this);
      if (this._parentContainer) {
        const index = this._parentContainer.morphTargetManagers.indexOf(this);
        if (index > -1) {
          this._parentContainer.morphTargetManagers.splice(index, 1);
        }
        this._parentContainer = null;
      }
      for (const morph of this._targets) {
        this._scene.stopAnimation(morph);
      }
    }
  }
  // Statics
  /**
   * Creates a new MorphTargetManager from serialized data
   * @param serializationObject defines the serialized data
   * @param scene defines the hosting scene
   * @returns the new MorphTargetManager
   */
  static Parse(serializationObject, scene) {
    const result = new _MorphTargetManager(scene);
    result._uniqueId = serializationObject.id;
    for (const targetData of serializationObject.targets) {
      result.addTarget(MorphTarget.Parse(targetData, scene));
    }
    return result;
  }
};
MorphTargetManager.EnableTextureStorage = true;
MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;

// node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js
var RawCubeTexture = class _RawCubeTexture extends CubeTexture {
  /**
   * Creates a cube texture where the raw buffers are passed in.
   * @param scene defines the scene the texture is attached to
   * @param data defines the array of data to use to create each face
   * @param size defines the size of the textures
   * @param format defines the format of the data
   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
   * @param generateMipMaps  defines if the engine should generate the mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
   * @param compression defines the compression used (null by default)
   */
  constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {
    super("", scene);
    this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);
  }
  /**
   * Updates the raw cube texture.
   * @param data defines the data to store
   * @param format defines the data format
   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
   * @param invertY defines if data must be stored with Y axis inverted
   * @param compression defines the compression used (null by default)
   */
  update(data, format, type, invertY, compression = null) {
    this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);
  }
  /**
   * Updates a raw cube texture with RGBD encoded data.
   * @param data defines the array of data [mipmap][face] to use to create each face
   * @param sphericalPolynomial defines the spherical polynomial for irradiance
   * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness
   * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness
   * @returns a promise that resolves when the operation is complete
   */
  updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {
    return _UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => {
    });
  }
  /**
   * Clones the raw cube texture.
   * @returns a new cube texture
   */
  clone() {
    return SerializationHelper.Clone(() => {
      const scene = this.getScene();
      const internalTexture = this._texture;
      const texture = new _RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
      if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {
        texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);
      }
      return texture;
    }, this);
  }
};

// node_modules/@babylonjs/core/Shaders/gaussianSplatting.fragment.js
var name46 = "gaussianSplattingPixelShader";
var shader46 = `#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
varying vec4 vColor;varying vec2 vPosition;void main () { 
#include<clipPlaneFragment>
float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*vColor.a;
#include<logDepthFragment>
vec3 color=vColor.rgb;
#ifdef FOG
#include<fogFragment>
#endif
gl_FragColor=vec4(color,B);}
`;
ShaderStore.ShadersStore[name46] = shader46;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.js
var name47 = "gaussianSplattingVertexDeclaration";
var shader47 = `uniform mat4 world;uniform mat4 view;uniform mat4 projection;
`;
ShaderStore.IncludesShadersStore[name47] = shader47;

// node_modules/@babylonjs/core/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.js
var name48 = "gaussianSplattingUboDeclaration";
var shader48 = `#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
ShaderStore.IncludesShadersStore[name48] = shader48;

// node_modules/@babylonjs/core/Shaders/gaussianSplatting.vertex.js
var name49 = "gaussianSplattingVertexShader";
var shader49 = `#include<__decl__gaussianSplattingVertex>
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<logDepthDeclaration>
attribute vec2 position;attribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;varying vec4 vColor;varying vec2 vPosition;
#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)
mat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],
matrix[0][1],matrix[1][1],matrix[2][1],
matrix[0][2],matrix[1][2],matrix[2][2]);}
#endif
vec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}
void main () {vec2 splatUV=getDataUV(splatIndex,dataTextureSize);vec3 center=texture2D(centersTexture,splatUV).xyz;vec4 color=texture2D(colorsTexture,splatUV);vec3 covA=texture2D(covariancesATexture,splatUV).xyz;vec3 covB=texture2D(covariancesBTexture,splatUV).xyz;vec4 worldPos=world*vec4(center,1.0);mat4 modelView=view*world;vec4 camspace=view*worldPos;vec4 pos2d=projection*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds
|| pos2d.y<-bounds || pos2d.y>bounds) {gl_Position=vec4(0.0,0.0,2.0,1.0);return;}
mat3 Vrk=mat3(
covA.x,covA.y,covA.z,
covA.y,covB.x,covB.y,
covA.z,covB.y,covB.z
);mat3 J=mat3(
focal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),
0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),
0.,0.,0.
);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;float mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float lambda1=mid+radius,lambda2=mid-radius;if (lambda2<0.0) return;vec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vColor=color;vPosition=position;vec2 vCenter=vec2(pos2d);gl_Position=vec4(
vCenter 
+ (position.x*majorAxis
+ position.y*minorAxis)*invViewport*pos2d.w,pos2d.zw);
#include<clipPlaneVertex>
#include<fogVertex>
#include<logDepthVertex>
}
`;
ShaderStore.ShadersStore[name49] = shader49;

// node_modules/@babylonjs/core/Materials/GaussianSplatting/gaussianSplattingMaterial.js
var GaussianSplattingMaterialDefines = class extends MaterialDefines {
  /**
   * Constructor of the defines.
   */
  constructor() {
    super();
    this.FOG = false;
    this.THIN_INSTANCES = true;
    this.LOGARITHMICDEPTH = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.rebuild();
  }
};
var GaussianSplattingMaterial = class _GaussianSplattingMaterial extends PushMaterial {
  /**
   * Instantiates a Gaussian Splatting Material in the given scene
   * @param name The friendly name of the material
   * @param scene The scene to add the material to
   */
  constructor(name50, scene) {
    super(name50, scene);
    this.backFaceCulling = false;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha test mode.
   * @returns false
   */
  needAlphaTesting() {
    return false;
  }
  /**
   * Specifies whether or not this material should be rendered in alpha blend mode.
   * @returns true
   */
  needAlphaBlending() {
    return true;
  }
  /**
   * Checks whether the material is ready to be rendered for a given mesh.
   * @param mesh The mesh to render
   * @param subMesh The submesh to check against
   * @returns true if all the dependencies are ready (Textures, Effects...)
   */
  isReadyForSubMesh(mesh, subMesh) {
    const useInstances = true;
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      subMesh.materialDefines = new GaussianSplattingMaterialDefines();
    }
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const engine = scene.getEngine();
    PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines);
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);
    PrepareDefinesForAttributes(mesh, defines, false, false);
    if (defines.isDirty) {
      defines.markAsProcessed();
      scene.resetCachedMaterial();
      const attribs = [VertexBuffer.PositionKind, "splatIndex"];
      PrepareAttributesForInstances(attribs, defines);
      const uniforms = ["world", "view", "projection", "vFogInfos", "vFogColor", "logarithmicDepthConstant", "invViewport", "dataTextureSize", "focal"];
      const samplers = ["covariancesATexture", "covariancesBTexture", "centersTexture", "colorsTexture"];
      const uniformBuffers = ["Scene", "Mesh"];
      PrepareUniformsAndSamplersList({
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines
      });
      addClipPlaneUniforms(uniforms);
      const join = defines.toString();
      const effect = scene.getEngine().createEffect("gaussianSplatting", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: uniformBuffers,
        samplers,
        defines: join,
        onCompiled: this.onCompiled,
        onError: this.onError
      }, engine);
      subMesh.setEffect(effect, defines, this._materialContext);
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = true;
    drawWrapper._wasPreviouslyUsingInstances = useInstances;
    return true;
  }
  /**
   * Binds the submesh to this material by preparing the effect and shader to draw
   * @param world defines the world transformation matrix
   * @param mesh defines the mesh containing the submesh
   * @param subMesh defines the submesh to bind the material to
   */
  bindForSubMesh(world, mesh, subMesh) {
    var _a;
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    if (mustRebind) {
      this.bindView(effect);
      this.bindViewProjection(effect);
      const engine = scene.getEngine();
      const camera = this.getScene().activeCamera;
      const renderWidth = engine.getRenderWidth();
      const renderHeight = engine.getRenderHeight();
      const numberOfRigs = ((_a = camera == null ? void 0 : camera.rigParent) == null ? void 0 : _a.rigCameras.length) || 1;
      this._activeEffect.setFloat2("invViewport", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);
      let focal = 1e3;
      if (camera) {
        if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {
          focal = renderHeight / 2 / Math.tan(camera.fov / 2);
        } else {
          focal = renderWidth / 2 / Math.tan(camera.fov / 2);
        }
      }
      this._activeEffect.setFloat2("focal", focal, focal);
      const gsMesh = mesh;
      if (gsMesh.covariancesATexture) {
        const textureSize = gsMesh.covariancesATexture.getSize();
        effect.setFloat2("dataTextureSize", textureSize.width, textureSize.height);
        effect.setTexture("covariancesATexture", gsMesh.covariancesATexture);
        effect.setTexture("covariancesBTexture", gsMesh.covariancesBTexture);
        effect.setTexture("centersTexture", gsMesh.centersTexture);
        effect.setTexture("colorsTexture", gsMesh.colorsTexture);
      }
      bindClipPlane(effect, this, scene);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    BindFogParameters(scene, mesh, effect);
    if (this.useLogarithmicDepth) {
      BindLogDepth(defines, effect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
  }
  /**
   * Clones the material.
   * @param name The cloned name.
   * @returns The cloned material.
   */
  clone(name50) {
    return SerializationHelper.Clone(() => new _GaussianSplattingMaterial(name50, this.getScene()), this);
  }
  /**
   * Serializes the current material to its JSON representation.
   * @returns The JSON representation.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.GaussianSplattingMaterial";
    return serializationObject;
  }
  /**
   * Gets the class name of the material
   * @returns "GaussianSplattingMaterial"
   */
  getClassName() {
    return "GaussianSplattingMaterial";
  }
  /**
   * Parse a JSON input to create back a Gaussian Splatting material.
   * @param source The JSON data to parse
   * @param scene The scene to create the parsed material in
   * @param rootUrl The root url of the assets the material depends upon
   * @returns the instantiated GaussianSplattingMaterial.
   */
  static Parse(source, scene, rootUrl) {
    return SerializationHelper.Parse(() => new _GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);
  }
};
RegisterClass("BABYLON.GaussianSplattingMaterial", GaussianSplattingMaterial);

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompressionWorker.js
function decodeMesh(decoderModule, data, attributes, onIndicesData, onAttributeData) {
  let decoder = null;
  let buffer = null;
  let geometry = null;
  try {
    decoder = new decoderModule.Decoder();
    buffer = new decoderModule.DecoderBuffer();
    buffer.Init(data, data.byteLength);
    let status;
    const type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH: {
        const mesh = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, mesh);
        if (!status.ok() || mesh.ptr === 0) {
          throw new Error(status.error_msg());
        }
        const numFaces = mesh.num_faces();
        const numIndices = numFaces * 3;
        const byteLength = numIndices * 4;
        const ptr = decoderModule._malloc(byteLength);
        try {
          decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
          const indices = new Uint32Array(numIndices);
          indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
          onIndicesData(indices);
        } finally {
          decoderModule._free(ptr);
        }
        geometry = mesh;
        break;
      }
      case decoderModule.POINT_CLOUD: {
        const pointCloud = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);
        if (!status.ok() || !pointCloud.ptr) {
          throw new Error(status.error_msg());
        }
        geometry = pointCloud;
        break;
      }
      default: {
        throw new Error(`Invalid geometry type ${type}`);
      }
    }
    const numPoints = geometry.num_points();
    const processAttribute = (decoder2, geometry2, kind, attribute) => {
      const dataType = attribute.data_type();
      const numComponents = attribute.num_components();
      const normalized = attribute.normalized();
      const byteStride = attribute.byte_stride();
      const byteOffset = attribute.byte_offset();
      const dataTypeInfo = {
        [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },
        [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },
        [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },
        [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },
        [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },
        [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },
        [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 }
      };
      const info = dataTypeInfo[dataType];
      if (!info) {
        throw new Error(`Invalid data type ${dataType}`);
      }
      const numValues = numPoints * numComponents;
      const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;
      const ptr = decoderModule._malloc(byteLength);
      try {
        decoder2.GetAttributeDataArrayForAllPoints(geometry2, attribute, dataType, byteLength, ptr);
        const data2 = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);
        onAttributeData(kind, data2.slice(), numComponents, byteOffset, byteStride, normalized);
      } finally {
        decoderModule._free(ptr);
      }
    };
    if (attributes) {
      for (const kind in attributes) {
        const id = attributes[kind];
        const attribute = decoder.GetAttributeByUniqueId(geometry, id);
        processAttribute(decoder, geometry, kind, attribute);
      }
    } else {
      const dracoAttributeTypes = {
        position: decoderModule.POSITION,
        normal: decoderModule.NORMAL,
        color: decoderModule.COLOR,
        uv: decoderModule.TEX_COORD
      };
      for (const kind in dracoAttributeTypes) {
        const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);
        if (id !== -1) {
          const attribute = decoder.GetAttribute(geometry, id);
          processAttribute(decoder, geometry, kind, attribute);
        }
      }
    }
    return numPoints;
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    if (buffer) {
      decoderModule.destroy(buffer);
    }
    if (decoder) {
      decoderModule.destroy(decoder);
    }
  }
}
function workerFunction() {
  let decoderPromise;
  onmessage = (event) => {
    const message = event.data;
    switch (message.id) {
      case "init": {
        const decoder = message.decoder;
        if (decoder.url) {
          importScripts(decoder.url);
        }
        const initDecoderObject = decoder.wasmBinary ? { wasmBinary: decoder.wasmBinary } : {};
        decoderPromise = DracoDecoderModule(initDecoderObject);
        postMessage({ id: "initDone" });
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then((decoder) => {
          const numPoints = decodeMesh(decoder, message.dataView, message.attributes, (indices) => {
            postMessage({ id: "indices", data: indices }, [indices.buffer]);
          }, (kind, data, size, offset, stride, normalized) => {
            postMessage({ id: "attribute", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);
          });
          postMessage({ id: "decodeMeshDone", totalVertices: numPoints });
        });
        break;
      }
    }
  };
}
function initializeWebWorker(worker, decoderWasmBinary, moduleUrl) {
  return new Promise((resolve, reject) => {
    const onError = (error) => {
      worker.removeEventListener("error", onError);
      worker.removeEventListener("message", onMessage);
      reject(error);
    };
    const onMessage = (event) => {
      if (event.data.id === "initDone") {
        worker.removeEventListener("error", onError);
        worker.removeEventListener("message", onMessage);
        resolve(worker);
      }
    };
    worker.addEventListener("error", onError);
    worker.addEventListener("message", onMessage);
    if (!decoderWasmBinary) {
      worker.postMessage({
        id: "init",
        decoder: {
          url: moduleUrl
        }
      });
    } else {
      const clone = decoderWasmBinary.slice(0);
      worker.postMessage({
        id: "init",
        decoder: {
          url: moduleUrl,
          wasmBinary: clone
        }
      }, [clone]);
    }
  });
}

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js
function createDecoderAsync(wasmBinary, jsModule) {
  return new Promise((resolve) => {
    (jsModule || DracoDecoderModule)({ wasmBinary }).then((module) => {
      resolve({ module });
    });
  });
}
var DracoCompression = class _DracoCompression {
  /**
   * Returns true if the decoder configuration is available.
   */
  static get DecoderAvailable() {
    const decoder = _DracoCompression.Configuration.decoder;
    return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" || decoder.fallbackUrl);
  }
  static GetDefaultNumWorkers() {
    if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
      return 1;
    }
    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
  }
  /**
   * Default instance for the draco compression object.
   */
  static get Default() {
    if (!_DracoCompression._Default) {
      _DracoCompression._Default = new _DracoCompression();
    }
    return _DracoCompression._Default;
  }
  /**
   * Reset the default draco compression object to null and disposing the removed default instance.
   * Note that if the workerPool is a member of the static Configuration object it is recommended not to run dispose,
   * unless the static worker pool is no longer needed.
   * @param skipDispose set to true to not dispose the removed default instance
   */
  static ResetDefault(skipDispose) {
    if (_DracoCompression._Default) {
      if (!skipDispose) {
        _DracoCompression._Default.dispose();
      }
      _DracoCompression._Default = null;
    }
  }
  /**
   * Constructor
   * @param numWorkers The number of workers for async operations Or an options object. Specify `0` to disable web workers and run synchronously in the current context.
   */
  constructor(numWorkers = _DracoCompression.DefaultNumWorkers) {
    const decoder = _DracoCompression.Configuration.decoder;
    if (decoder.workerPool || typeof numWorkers === "object" && numWorkers.workerPool) {
      this._workerPoolPromise = Promise.resolve(decoder.workerPool || numWorkers.workerPool);
    } else {
      const wasmBinaryProvided = decoder.wasmBinary || typeof numWorkers === "object" && numWorkers.wasmBinary;
      const numberOfWorkers = typeof numWorkers === "number" ? numWorkers : numWorkers.numWorkers;
      const useWorkers = numberOfWorkers && typeof Worker === "function" && typeof URL === "function";
      const urlNeeded = useWorkers || !useWorkers && !decoder.jsModule;
      const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" ? {
        url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.wasmUrl, true) : "",
        wasmBinaryPromise: wasmBinaryProvided ? Promise.resolve(wasmBinaryProvided) : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(decoder.wasmBinaryUrl, true))
      } : {
        url: urlNeeded ? Tools.GetBabylonScriptURL(decoder.fallbackUrl) : "",
        wasmBinaryPromise: Promise.resolve(void 0)
      };
      if (useWorkers) {
        this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {
          const workerContent = `${decodeMesh}(${workerFunction})()`;
          const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
          return new AutoReleaseWorkerPool(numberOfWorkers, () => {
            const worker = new Worker(workerBlobUrl);
            return initializeWebWorker(worker, decoderWasmBinary, decoderInfo.url);
          });
        });
      } else {
        this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then(async (decoderWasmBinary) => {
          if (typeof DracoDecoderModule === "undefined") {
            if (!decoder.jsModule) {
              if (!decoderInfo.url) {
                throw new Error("Draco decoder module is not available");
              }
              await Tools.LoadBabylonScriptAsync(decoderInfo.url);
            }
          }
          return await createDecoderAsync(decoderWasmBinary, decoder.jsModule);
        });
      }
    }
  }
  /**
   * Stop all async operations and release resources.
   */
  dispose() {
    if (this._workerPoolPromise) {
      this._workerPoolPromise.then((workerPool) => {
        workerPool.dispose();
      });
    }
    delete this._workerPoolPromise;
    delete this._decoderModulePromise;
  }
  /**
   * Returns a promise that resolves when ready. Call this manually to ensure draco compression is ready before use.
   * @returns a promise that resolves when ready
   */
  async whenReadyAsync() {
    if (this._workerPoolPromise) {
      await this._workerPoolPromise;
      return;
    }
    if (this._decoderModulePromise) {
      await this._decoderModulePromise;
      return;
    }
  }
  /**
   * Decode Draco compressed mesh data to mesh data.
   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
   * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization
   * @returns A promise that resolves with the decoded mesh data
   */
  decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride) {
    const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);
    const applyGltfNormalizedOverride = (kind, normalized) => {
      if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== void 0) {
        if (normalized !== gltfNormalizedOverride[kind]) {
          Logger.Warn(`Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`);
        }
        return gltfNormalizedOverride[kind];
      } else {
        return normalized;
      }
    };
    if (this._workerPoolPromise) {
      return this._workerPoolPromise.then((workerPool) => {
        return new Promise((resolve, reject) => {
          workerPool.push((worker, onComplete) => {
            let resultIndices = null;
            const resultAttributes = [];
            const onError = (error) => {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(error);
              onComplete();
            };
            const onMessage = (event) => {
              const message = event.data;
              switch (message.id) {
                case "decodeMeshDone": {
                  worker.removeEventListener("error", onError);
                  worker.removeEventListener("message", onMessage);
                  resolve({ indices: resultIndices, attributes: resultAttributes, totalVertices: message.totalVertices });
                  onComplete();
                  break;
                }
                case "indices": {
                  resultIndices = message.data;
                  break;
                }
                case "attribute": {
                  resultAttributes.push({
                    kind: message.kind,
                    data: message.data,
                    size: message.size,
                    byteOffset: message.byteOffset,
                    byteStride: message.byteStride,
                    normalized: applyGltfNormalizedOverride(message.kind, message.normalized)
                  });
                  break;
                }
              }
            };
            worker.addEventListener("error", onError);
            worker.addEventListener("message", onMessage);
            const dataViewCopy = dataView.slice();
            worker.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
          });
        });
      });
    }
    if (this._decoderModulePromise) {
      return this._decoderModulePromise.then((decoder) => {
        let resultIndices = null;
        const resultAttributes = [];
        const numPoints = decodeMesh(decoder.module, dataView, attributes, (indices) => {
          resultIndices = indices;
        }, (kind, data2, size, byteOffset, byteStride, normalized) => {
          resultAttributes.push({
            kind,
            data: data2,
            size,
            byteOffset,
            byteStride,
            normalized
          });
        });
        return { indices: resultIndices, attributes: resultAttributes, totalVertices: numPoints };
      });
    }
    throw new Error("Draco decoder module is not available");
  }
  /**
   * Decode Draco compressed mesh data to Babylon geometry.
   * @param name The name to use when creating the geometry
   * @param scene The scene to use when creating the geometry
   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
   * @returns A promise that resolves with the decoded geometry
   */
  async decodeMeshToGeometryAsync(name50, scene, data, attributes) {
    const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);
    const geometry = new Geometry(name50, scene);
    if (meshData.indices) {
      geometry.setIndices(meshData.indices);
    }
    for (const attribute of meshData.attributes) {
      geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
    }
    return geometry;
  }
  /** @internal */
  async _decodeMeshToGeometryForGltfAsync(name50, scene, data, attributes, gltfNormalizedOverride) {
    const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);
    const geometry = new Geometry(name50, scene);
    if (meshData.indices) {
      geometry.setIndices(meshData.indices);
    }
    for (const attribute of meshData.attributes) {
      geometry.setVerticesBuffer(new VertexBuffer(scene.getEngine(), attribute.data, attribute.kind, false, void 0, attribute.byteStride, void 0, attribute.byteOffset, attribute.size, void 0, attribute.normalized, true), meshData.totalVertices);
    }
    return geometry;
  }
  /**
   * Decode Draco compressed mesh data to Babylon vertex data.
   * @param data The ArrayBuffer or ArrayBufferView for the Draco compression data
   * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids
   * @returns A promise that resolves with the decoded vertex data
   * @deprecated Use {@link decodeMeshToGeometryAsync} for better performance in some cases
   */
  async decodeMeshAsync(data, attributes) {
    const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);
    const vertexData = new VertexData();
    if (meshData.indices) {
      vertexData.indices = meshData.indices;
    }
    for (const attribute of meshData.attributes) {
      const floatData = VertexBuffer.GetFloatData(attribute.data, attribute.size, VertexBuffer.GetDataType(attribute.data), attribute.byteOffset, attribute.byteStride, attribute.normalized, meshData.totalVertices);
      vertexData.set(floatData, attribute.kind);
    }
    return vertexData;
  }
};
DracoCompression.Configuration = {
  decoder: {
    wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,
    wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,
    fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`
  }
};
DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();
DracoCompression._Default = null;

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var MeshoptCompression = class _MeshoptCompression {
  /**
   * Default instance for the meshoptimizer object.
   */
  static get Default() {
    if (!_MeshoptCompression._Default) {
      _MeshoptCompression._Default = new _MeshoptCompression();
    }
    return _MeshoptCompression._Default;
  }
  /**
   * Constructor
   */
  constructor() {
    const decoder = _MeshoptCompression.Configuration.decoder;
    this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {
      return MeshoptDecoder.ready;
    });
  }
  /**
   * Stop all async operations and release resources.
   */
  dispose() {
    delete this._decoderModulePromise;
  }
  /**
   * Decode meshopt data.
   * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder
   * @param source The input data.
   * @param count The number of elements.
   * @param stride The stride in bytes.
   * @param mode The compression mode.
   * @param filter The compression filter.
   * @returns a Promise<Uint8Array> that resolves to the decoded data
   */
  decodeGltfBufferAsync(source, count, stride, mode, filter) {
    return this._decoderModulePromise.then(async () => {
      MeshoptDecoder.useWorkers(1);
      const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);
      MeshoptDecoder.useWorkers(0);
      return result;
    });
  }
};
MeshoptCompression.Configuration = {
  decoder: {
    url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`
  }
};
MeshoptCompression._Default = null;

// node_modules/@babylonjs/core/Meshes/GaussianSplatting/gaussianSplattingMesh.js
var GaussianSplattingMesh = class _GaussianSplattingMesh extends Mesh {
  /**
   * Gets the covariancesA texture
   */
  get covariancesATexture() {
    return this._covariancesATexture;
  }
  /**
   * Gets the covariancesB texture
   */
  get covariancesBTexture() {
    return this._covariancesBTexture;
  }
  /**
   * Gets the centers texture
   */
  get centersTexture() {
    return this._centersTexture;
  }
  /**
   * Gets the colors texture
   */
  get colorsTexture() {
    return this._colorsTexture;
  }
  /**
   * Creates a new gaussian splatting mesh
   * @param name defines the name of the mesh
   * @param url defines the url to load from (optional)
   * @param scene defines the hosting scene (optional)
   */
  constructor(name50, url = null, scene = null) {
    super(name50, scene);
    this._vertexCount = 0;
    this._worker = null;
    this._frameIdLastUpdate = -1;
    this._modelViewMatrix = Matrix.Identity();
    this._material = null;
    this._canPostToWorker = true;
    this._covariancesATexture = null;
    this._covariancesBTexture = null;
    this._centersTexture = null;
    this._colorsTexture = null;
    const vertexData = new VertexData();
    vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];
    vertexData.indices = [0, 1, 2, 0, 2, 3];
    vertexData.applyToMesh(this);
    this.subMeshes = [];
    new SubMesh(0, 0, 4, 0, 6, this);
    this.doNotSyncBoundingInfo = true;
    this.setEnabled(false);
    this._lastProj = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    if (url) {
      this.loadFileAsync(url);
    }
  }
  /**
   * Returns the class name
   * @returns "GaussianSplattingMesh"
   */
  getClassName() {
    return "GaussianSplattingMesh";
  }
  /**
   * Returns the total number of vertices (splats) within the mesh
   * @returns the total number of vertices
   */
  getTotalVertices() {
    return this._vertexCount;
  }
  /**
   * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager
   * @param subMesh defines the subMesh to render
   * @param enableAlphaMode defines if alpha mode can be changed
   * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering
   * @returns the current mesh
   */
  render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    if (!this.material) {
      this._material = new GaussianSplattingMaterial(this.name + "_material", this._scene);
      this.material = this._material;
    }
    const frameId = this.getScene().getFrameId();
    if (frameId !== this._frameIdLastUpdate && this._worker && this._scene.activeCamera && this._canPostToWorker) {
      this.getWorldMatrix().multiplyToRef(this._scene.activeCamera.getViewMatrix(), this._modelViewMatrix);
      const dot = this._lastProj[2] * this._modelViewMatrix.m[2] + this._lastProj[6] * this._modelViewMatrix.m[6] + this._lastProj[10] * this._modelViewMatrix.m[10];
      if (Math.abs(dot - 1) >= 0.01) {
        this._frameIdLastUpdate = frameId;
        this._canPostToWorker = false;
        this._lastProj = this._modelViewMatrix.m.slice(0);
        this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix, useRightHandedSystem: this._scene.useRightHandedSystem }, [
          this._depthMix.buffer
        ]);
      }
    }
    return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);
  }
  /**
   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
   * Converts a .ply data array buffer to splat
   * if data array buffer is not ply, returns the original buffer
   * @param data the .ply data to load
   * @returns the loaded splat buffer
   */
  static ConvertPLYToSplat(data) {
    const ubuf = new Uint8Array(data);
    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
    const headerEnd = "end_header\n";
    const headerEndIndex = header.indexOf(headerEnd);
    if (headerEndIndex < 0 || !header) {
      return data;
    }
    const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
    let rowOffset = 0;
    const offsets = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1
    };
    const properties = [];
    const filtered = header.slice(0, headerEndIndex).split("\n").filter((k) => k.startsWith("property "));
    for (const prop of filtered) {
      const [, type, name50] = prop.split(" ");
      properties.push({ name: name50, type, offset: rowOffset });
      if (offsets[type]) {
        rowOffset += offsets[type];
      } else {
        Logger.Error(`Unsupported property type: ${type}. Are you sure it's a valid Gaussian Splatting file?`);
        return new ArrayBuffer(0);
      }
    }
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const SH_C0 = 0.28209479177387814;
    const dataView = new DataView(data, headerEndIndex + headerEnd.length);
    const buffer = new ArrayBuffer(rowLength * vertexCount);
    const q = new Quaternion();
    for (let i = 0; i < vertexCount; i++) {
      const position = new Float32Array(buffer, i * rowLength, 3);
      const scale = new Float32Array(buffer, i * rowLength + 12, 3);
      const rgba = new Uint8ClampedArray(buffer, i * rowLength + 24, 4);
      const rot = new Uint8ClampedArray(buffer, i * rowLength + 28, 4);
      let r0 = 255;
      let r1 = 0;
      let r2 = 0;
      let r3 = 0;
      for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
        const property = properties[propertyIndex];
        let value;
        switch (property.type) {
          case "float":
            value = dataView.getFloat32(property.offset + i * rowOffset, true);
            break;
          case "int":
            value = dataView.getInt32(property.offset + i * rowOffset, true);
            break;
          default:
            throw new Error(`Unsupported property type: ${property.type}`);
        }
        switch (property.name) {
          case "x":
            position[0] = value;
            break;
          case "y":
            position[1] = value;
            break;
          case "z":
            position[2] = value;
            break;
          case "scale_0":
            scale[0] = Math.exp(value);
            break;
          case "scale_1":
            scale[1] = Math.exp(value);
            break;
          case "scale_2":
            scale[2] = Math.exp(value);
            break;
          case "red":
            rgba[0] = value;
            break;
          case "green":
            rgba[1] = value;
            break;
          case "blue":
            rgba[2] = value;
            break;
          case "f_dc_0":
            rgba[0] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_1":
            rgba[1] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_2":
            rgba[2] = (0.5 + SH_C0 * value) * 255;
            break;
          case "f_dc_3":
            rgba[3] = (0.5 + SH_C0 * value) * 255;
            break;
          case "opacity":
            rgba[3] = 1 / (1 + Math.exp(-value)) * 255;
            break;
          case "rot_0":
            r0 = value;
            break;
          case "rot_1":
            r1 = value;
            break;
          case "rot_2":
            r2 = value;
            break;
          case "rot_3":
            r3 = value;
            break;
        }
      }
      q.set(r1, r2, r3, r0);
      q.normalize();
      rot[0] = q.w * 128 + 128;
      rot[1] = q.x * 128 + 128;
      rot[2] = q.y * 128 + 128;
      rot[3] = q.z * 128 + 128;
    }
    return buffer;
  }
  /**
   * Loads a .splat Gaussian Splatting array buffer asynchronously
   * @param data arraybuffer containing splat file
   * @returns a promise that resolves when the operation is complete
   */
  loadDataAsync(data) {
    return Promise.resolve(this._loadData(data));
  }
  /**
   * Loads a .splat Gaussian or .ply Splatting file asynchronously
   * @param url path to the splat file to load
   * @returns a promise that resolves when the operation is complete
   */
  loadFileAsync(url) {
    return Tools.LoadFileAsync(url, true).then((data) => {
      this._loadData(_GaussianSplattingMesh.ConvertPLYToSplat(data));
    });
  }
  /**
   * Releases resources associated with this mesh.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   */
  dispose(doNotRecurse) {
    var _a, _b, _c, _d, _e, _f;
    (_a = this._covariancesATexture) == null ? void 0 : _a.dispose();
    (_b = this._covariancesBTexture) == null ? void 0 : _b.dispose();
    (_c = this._centersTexture) == null ? void 0 : _c.dispose();
    (_d = this._colorsTexture) == null ? void 0 : _d.dispose();
    this._covariancesATexture = null;
    this._covariancesBTexture = null;
    this._centersTexture = null;
    this._colorsTexture = null;
    (_e = this._material) == null ? void 0 : _e.dispose(false, true);
    this._material = null;
    (_f = this._worker) == null ? void 0 : _f.terminate();
    this._worker = null;
    super.dispose(doNotRecurse);
  }
  _loadData(data) {
    var _a;
    if (!data.byteLength) {
      return;
    }
    const uBuffer = new Uint8Array(data);
    const fBuffer = new Float32Array(uBuffer.buffer);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    this._vertexCount = vertexCount;
    const textureSize = this._getTextureSize(vertexCount);
    const textureLength = textureSize.x * textureSize.y;
    const positions = new Float32Array(3 * textureLength);
    const covA = new Float32Array(3 * textureLength);
    const covB = new Float32Array(3 * textureLength);
    const matrixRotation = TmpVectors.Matrix[0];
    const matrixScale = TmpVectors.Matrix[1];
    const quaternion = TmpVectors.Quaternion[0];
    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let i = 0; i < vertexCount; i++) {
      const x = fBuffer[8 * i + 0];
      const y = -fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      positions[3 * i + 0] = x;
      positions[3 * i + 1] = y;
      positions[3 * i + 2] = z;
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
      quaternion.set((uBuffer[32 * i + 28 + 1] - 128) / 128, (uBuffer[32 * i + 28 + 2] - 128) / 128, (uBuffer[32 * i + 28 + 3] - 128) / 128, -(uBuffer[32 * i + 28 + 0] - 128) / 128);
      quaternion.toRotationMatrix(matrixRotation);
      Matrix.ScalingToRef(fBuffer[8 * i + 3 + 0] * 2, fBuffer[8 * i + 3 + 1] * 2, fBuffer[8 * i + 3 + 2] * 2, matrixScale);
      const M = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;
      covA[i * 3 + 0] = M[0] * M[0] + M[1] * M[1] + M[2] * M[2];
      covA[i * 3 + 1] = M[0] * M[4] + M[1] * M[5] + M[2] * M[6];
      covA[i * 3 + 2] = M[0] * M[8] + M[1] * M[9] + M[2] * M[10];
      covB[i * 3 + 0] = M[4] * M[4] + M[5] * M[5] + M[6] * M[6];
      covB[i * 3 + 1] = M[4] * M[8] + M[5] * M[9] + M[6] * M[10];
      covB[i * 3 + 2] = M[8] * M[8] + M[9] * M[9] + M[10] * M[10];
    }
    const binfo = this.getBoundingInfo();
    binfo.reConstruct(minimum, maximum, this.getWorldMatrix());
    binfo.isLocked = true;
    this.forcedInstanceCount = this._vertexCount;
    this.setEnabled(true);
    const splatIndex = new Float32Array(this._vertexCount * 1);
    this.thinInstanceSetBuffer("splatIndex", splatIndex, 1, false);
    const createTextureFromData = (data2, width, height, format) => {
      return new RawTexture(data2, width, height, format, this._scene, false, false, 2, 1);
    };
    const convertRgbToRgba = (rgb) => {
      const count = rgb.length / 3;
      const rgba = new Float32Array(count * 4);
      for (let i = 0; i < count; ++i) {
        rgba[i * 4 + 0] = rgb[i * 3 + 0];
        rgba[i * 4 + 1] = rgb[i * 3 + 1];
        rgba[i * 4 + 2] = rgb[i * 3 + 2];
        rgba[i * 4 + 3] = 1;
      }
      return rgba;
    };
    const colorArray = new Float32Array(textureSize.x * textureSize.y * 4);
    for (let i = 0; i < this._vertexCount; ++i) {
      colorArray[i * 4 + 0] = uBuffer[32 * i + 24 + 0] / 255;
      colorArray[i * 4 + 1] = uBuffer[32 * i + 24 + 1] / 255;
      colorArray[i * 4 + 2] = uBuffer[32 * i + 24 + 2] / 255;
      colorArray[i * 4 + 3] = uBuffer[32 * i + 24 + 3] / 255;
    }
    this._covariancesATexture = createTextureFromData(convertRgbToRgba(covA), textureSize.x, textureSize.y, 5);
    this._covariancesBTexture = createTextureFromData(convertRgbToRgba(covB), textureSize.x, textureSize.y, 5);
    this._centersTexture = createTextureFromData(convertRgbToRgba(positions), textureSize.x, textureSize.y, 5);
    this._colorsTexture = createTextureFromData(colorArray, textureSize.x, textureSize.y, 5);
    (_a = this._worker) == null ? void 0 : _a.terminate();
    this._worker = new Worker(URL.createObjectURL(new Blob(["(", _GaussianSplattingMesh._CreateWorker.toString(), ")(self)"], {
      type: "application/javascript"
    })));
    this._depthMix = new BigInt64Array(vertexCount);
    this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);
    this._worker.onmessage = (e) => {
      this._depthMix = e.data.depthMix;
      const indexMix = new Uint32Array(e.data.depthMix.buffer);
      for (let j = 0; j < this._vertexCount; j++) {
        splatIndex[j] = indexMix[2 * j];
      }
      this.thinInstanceBufferUpdated("splatIndex");
      this._canPostToWorker = true;
    };
  }
  _getTextureSize(length) {
    const engine = this._scene.getEngine();
    const width = engine.getCaps().maxTextureSize;
    let height = 1;
    if (engine.version === 1 && !engine.isWebGPU) {
      while (width * height < length) {
        height *= 2;
      }
    } else {
      height = Math.ceil(length / width);
    }
    if (height > width) {
      Logger.Error("GaussianSplatting texture size: (" + width + ", " + height + "), maxTextureSize: " + width);
      height = width;
    }
    return new Vector2(width, height);
  }
};
GaussianSplattingMesh._CreateWorker = function(self) {
  let vertexCount = 0;
  let positions;
  let depthMix;
  let indices;
  let floatMix;
  self.onmessage = (e) => {
    if (e.data.positions) {
      positions = e.data.positions;
      vertexCount = e.data.vertexCount;
    } else {
      const viewProj = e.data.view;
      if (!positions || !viewProj) {
        throw new Error("positions or view is not defined!");
      }
      depthMix = e.data.depthMix;
      indices = new Uint32Array(depthMix.buffer);
      floatMix = new Float32Array(depthMix.buffer);
      for (let j = 0; j < vertexCount; j++) {
        indices[2 * j] = j;
      }
      let depthFactor = -1;
      if (e.data.useRightHandedSystem) {
        depthFactor = 1;
      }
      for (let j = 0; j < vertexCount; j++) {
        floatMix[2 * j + 1] = 1e4 + (viewProj[2] * positions[3 * j + 0] + viewProj[6] * positions[3 * j + 1] + viewProj[10] * positions[3 * j + 2]) * depthFactor;
      }
      depthMix.sort();
      self.postMessage({ depthMix }, [depthMix.buffer]);
    }
  };
};

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred = class {
  /**
   * The resolve method of the promise associated with this deferred object.
   */
  get resolve() {
    return this._resolve;
  }
  /**
   * The reject method of the promise associated with this deferred object.
   */
  get reject() {
    return this._reject;
  }
  /**
   * Constructor for this deferred object.
   */
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
};

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader = class {
  /**
   * Constructor
   * @param buffer The buffer to read
   */
  constructor(buffer) {
    this.byteOffset = 0;
    this.buffer = buffer;
  }
  /**
   * Loads the given byte length.
   * @param byteLength The byte length to load
   * @returns A promise that resolves when the load is complete
   */
  loadAsync(byteLength) {
    return this.buffer.readAsync(this.byteOffset, byteLength).then((data) => {
      this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
      this._dataByteOffset = 0;
    });
  }
  /**
   * Read a unsigned 32-bit integer from the currently loaded data range.
   * @returns The 32-bit integer read
   */
  readUint32() {
    const value = this._dataView.getUint32(this._dataByteOffset, true);
    this._dataByteOffset += 4;
    this.byteOffset += 4;
    return value;
  }
  /**
   * Read a byte array from the currently loaded data range.
   * @param byteLength The byte length to read
   * @returns The byte array read
   */
  readUint8Array(byteLength) {
    const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
    this._dataByteOffset += byteLength;
    this.byteOffset += byteLength;
    return value;
  }
  /**
   * Read a string from the currently loaded data range.
   * @param byteLength The byte length to read
   * @returns The string read
   */
  readString(byteLength) {
    return Decode(this.readUint8Array(byteLength));
  }
  /**
   * Skips the given byte length the currently loaded data range.
   * @param byteLength The byte length to skip
   */
  skipBytes(byteLength) {
    this._dataByteOffset += byteLength;
    this.byteOffset += byteLength;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphConnection.js
var FlowGraphConnectionType;
(function(FlowGraphConnectionType2) {
  FlowGraphConnectionType2[FlowGraphConnectionType2["Input"] = 0] = "Input";
  FlowGraphConnectionType2[FlowGraphConnectionType2["Output"] = 1] = "Output";
})(FlowGraphConnectionType || (FlowGraphConnectionType = {}));
var FlowGraphConnection = class {
  constructor(name50, _connectionType, _ownerBlock) {
    this._ownerBlock = _ownerBlock;
    this._connectedPoint = [];
    this.uniqueId = RandomGUID();
    this.connectedPointIds = [];
    this.name = name50;
    this._connectionType = _connectionType;
  }
  /**
   * The type of the connection
   */
  get connectionType() {
    return this._connectionType;
  }
  /**
   * @internal
   * Override this to indicate if a point can connect to more than one point.
   */
  _isSingularConnection() {
    return true;
  }
  /**
   * Returns if a point is connected to any other point.
   * @returns boolean indicating if the point is connected.
   */
  isConnected() {
    return this._connectedPoint.length > 0;
  }
  /**
   * Connects two connections together.
   * @param point the connection to connect to.
   */
  connectTo(point) {
    if (this._connectionType === point._connectionType) {
      throw new Error(`Cannot connect two points of type ${this.connectionType}`);
    }
    if (this._isSingularConnection() && this._connectedPoint.length > 0 || point._isSingularConnection() && point._connectedPoint.length > 0) {
      throw new Error("Max number of connections for point reached");
    }
    this._connectedPoint.push(point);
    point._connectedPoint.push(this);
  }
  /**
   * Saves the connection to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject = {}) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.name = this.name;
    serializationObject._connectionType = this._connectionType;
    serializationObject.connectedPointIds = [];
    serializationObject.className = this.getClassName();
    for (const point of this._connectedPoint) {
      serializationObject.connectedPointIds.push(point.uniqueId);
    }
  }
  /**
   * @returns class name of the connection.
   */
  getClassName() {
    return "FGConnection";
  }
  /**
   * Deserialize from a object into this
   * @param serializationObject the object to deserialize from.
   */
  deserialize(serializationObject) {
    this.uniqueId = serializationObject.uniqueId;
    this.name = serializationObject.name;
    this._connectionType = serializationObject._connectionType;
    this.connectedPointIds = serializationObject.connectedPointIds;
  }
  /**
   * Parses a connection from an object
   * @param serializationObject the object to parse from.
   * @param ownerBlock the block that owns the connection.
   * @returns the parsed connection.
   */
  static Parse(serializationObject = {}, ownerBlock) {
    const type = Tools.Instantiate(serializationObject.className);
    const connection = new type(serializationObject.name, serializationObject._connectionType, ownerBlock);
    connection.deserialize(serializationObject);
    return connection;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphInteger.js
var FlowGraphInteger = class _FlowGraphInteger {
  constructor(value) {
    this.value = this._toInt(value);
  }
  /**
   * Converts a float to an integer.
   * @param n the float to convert
   * @returns the result of n | 0 - converting it to a int
   */
  _toInt(n) {
    return n | 0;
  }
  /**
   * Adds two integers together.
   * @param other the other integer to add
   * @returns a FlowGraphInteger with the result of the addition
   */
  add(other) {
    return new _FlowGraphInteger(this.value + other.value);
  }
  /**
   * Subtracts two integers.
   * @param other the other integer to subtract
   * @returns a FlowGraphInteger with the result of the subtraction
   */
  subtract(other) {
    return new _FlowGraphInteger(this.value - other.value);
  }
  /**
   * Multiplies two integers.
   * @param other the other integer to multiply
   * @returns a FlowGraphInteger with the result of the multiplication
   */
  multiply(other) {
    return new _FlowGraphInteger(Math.imul(this.value, other.value));
  }
  /**
   * Divides two integers.
   * @param other the other integer to divide
   * @returns a FlowGraphInteger with the result of the division
   */
  divide(other) {
    return new _FlowGraphInteger(this.value / other.value);
  }
  /**
   * The class name of this type.
   * @returns
   */
  getClassName() {
    return _FlowGraphInteger.ClassName;
  }
  /**
   * Compares two integers for equality.
   * @param other the other integer to compare
   * @returns
   */
  equals(other) {
    return this.value === other.value;
  }
  /**
   * Parses a FlowGraphInteger from a serialization object.
   * @param serializationObject
   * @returns
   */
  static Parse(serializationObject) {
    return new _FlowGraphInteger(serializationObject.value);
  }
};
FlowGraphInteger.ClassName = "FlowGraphInteger";
RegisterClass("FlowGraphInteger", FlowGraphInteger);

// node_modules/@babylonjs/core/FlowGraph/flowGraphRichTypes.js
var RichType = class _RichType {
  constructor(typeName, defaultValue) {
    this.typeName = typeName;
    this.defaultValue = defaultValue;
  }
  /**
   * Serializes this rich type into a serialization object.
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject) {
    serializationObject.typeName = this.typeName;
    serializationObject.defaultValue = this.defaultValue;
  }
  /**
   * Parses a rich type from a serialization object.
   * @param serializationObject a serialization object
   * @returns the parsed rich type
   */
  static Parse(serializationObject) {
    return new _RichType(serializationObject.typeName, serializationObject.defaultValue);
  }
};
var RichTypeAny = new RichType("any", void 0);
var RichTypeString = new RichType("string", "");
var RichTypeNumber = new RichType("number", 0);
var RichTypeBoolean = new RichType("boolean", false);
var RichTypeVector2 = new RichType("Vector2", Vector2.Zero());
var RichTypeVector3 = new RichType("Vector3", Vector3.Zero());
var RichTypeVector4 = new RichType("Vector4", Vector4.Zero());
var RichTypeMatrix = new RichType("Matrix", Matrix.Identity());
var RichTypeColor3 = new RichType("Color3", Color3.Black());
var RichTypeColor4 = new RichType("Color4", new Color4(0, 0, 0, 0));
var RichTypeQuaternion = new RichType("Quaternion", Quaternion.Identity());
var RichTypeFlowGraphInteger = new RichType("FlowGraphInteger", new FlowGraphInteger(0));
function getRichTypeFromValue(value) {
  switch (typeof value) {
    case "string":
      return RichTypeString;
    case "number":
      return RichTypeNumber;
    case "boolean":
      return RichTypeBoolean;
    case "object":
      if (value instanceof Vector2) {
        return RichTypeVector2;
      } else if (value instanceof Vector3) {
        return RichTypeVector3;
      } else if (value instanceof Vector4) {
        return RichTypeVector4;
      } else if (value instanceof Color3) {
        return RichTypeColor3;
      } else if (value instanceof Color4) {
        return RichTypeColor4;
      } else if (value instanceof Quaternion) {
        return RichTypeQuaternion;
      } else if (value instanceof FlowGraphInteger) {
        return RichTypeFlowGraphInteger;
      } else {
        return RichTypeAny;
      }
    default:
      return RichTypeAny;
  }
}

// node_modules/@babylonjs/core/FlowGraph/flowGraphDataConnection.js
var FlowGraphDataConnection = class extends FlowGraphConnection {
  /**
   * Create a new data connection point.
   * @param name
   * @param connectionType
   * @param ownerBlock
   * @param richType
   */
  constructor(name50, connectionType, ownerBlock, richType) {
    super(name50, connectionType, ownerBlock);
    this.richType = richType;
  }
  /**
   * An output data block can connect to multiple input data blocks,
   * but an input data block can only connect to one output data block.
   * @returns true if the connection is singular
   */
  _isSingularConnection() {
    return this.connectionType === FlowGraphConnectionType.Input;
  }
  /**
   * Set the value of the connection in a specific context.
   * @param value the value to set
   * @param context the context to which the value is set
   */
  setValue(value, context) {
    context._setConnectionValue(this, value);
  }
  /**
   * Connect this point to another point.
   * @param point the point to connect to.
   */
  connectTo(point) {
    super.connectTo(point);
  }
  _getValueOrDefault(context) {
    if (context._hasConnectionValue(this)) {
      return context._getConnectionValue(this);
    } else {
      return this.richType.defaultValue;
    }
  }
  /**
   * Gets the value of the connection in a specific context.
   * @param context the context from which the value is retrieved
   * @returns the value of the connection
   */
  getValue(context) {
    if (this.connectionType === FlowGraphConnectionType.Output) {
      context._notifyExecuteNode(this._ownerBlock);
      this._ownerBlock._updateOutputs(context);
      return this._getValueOrDefault(context);
    }
    if (!this.isConnected()) {
      return this._getValueOrDefault(context);
    } else {
      return this._connectedPoint[0].getValue(context);
    }
  }
  /**
   * @returns class name of the object.
   */
  getClassName() {
    return "FGDataConnection";
  }
  /**
   * Serializes this object.
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.richType = {};
    this.richType.serialize(serializationObject.richType);
  }
  /**
   * Parses a data connection from a serialized object.
   * @param serializationObject the object to parse from
   * @param ownerBlock the block that owns the connection
   * @returns the parsed connection
   */
  static Parse(serializationObject, ownerBlock) {
    const obj = FlowGraphConnection.Parse(serializationObject, ownerBlock);
    obj.richType = RichType.Parse(serializationObject.richType);
    return obj;
  }
};
RegisterClass("FGDataConnection", FlowGraphDataConnection);

// node_modules/@babylonjs/core/FlowGraph/serialization.js
function isMeshClassName(className) {
  return className === "Mesh" || className === "AbstractMesh" || className === "GroundMesh" || className === "InstanceMesh" || className === "LinesMesh" || className === "GoldbergMesh" || className === "GreasedLineMesh" || className === "TrailMesh";
}
function isVectorClassName(className) {
  return className === "Vector2" || className === "Vector3" || className === "Vector4" || className === "Quaternion" || className === "Color3" || className === "Color4";
}
function parseVector(className, value) {
  if (className === "Vector2") {
    return Vector2.FromArray(value);
  } else if (className === "Vector3") {
    return Vector3.FromArray(value);
  } else if (className === "Vector4") {
    return Vector4.FromArray(value);
  } else if (className === "Quaternion") {
    return Quaternion.FromArray(value);
  } else if (className === "Color3") {
    return new Color3(value[0], value[1], value[2]);
  } else if (className === "Color4") {
    return new Color4(value[0], value[1], value[2], value[3]);
  } else {
    throw new Error(`Unknown vector class name ${className}`);
  }
}
function defaultValueSerializationFunction(key, value, serializationObject) {
  var _a;
  const className = ((_a = value == null ? void 0 : value.getClassName) == null ? void 0 : _a.call(value)) ?? "";
  if (isMeshClassName(className)) {
    serializationObject[key] = {
      name: value.name,
      className
    };
  } else if (isVectorClassName(className)) {
    serializationObject[key] = {
      value: value.asArray(),
      className
    };
  } else {
    serializationObject[key] = value;
  }
}
function defaultValueParseFunction(key, serializationObject, scene) {
  const intermediateValue = serializationObject[key];
  let finalValue;
  const className = intermediateValue == null ? void 0 : intermediateValue.className;
  if (isMeshClassName(className)) {
    finalValue = scene.getMeshByName(intermediateValue.name);
  } else if (isVectorClassName(className)) {
    finalValue = parseVector(className, intermediateValue.value);
  } else if (className === "Matrix") {
    finalValue = Matrix.FromArray(intermediateValue.value);
  } else if (className === FlowGraphInteger.ClassName) {
    finalValue = FlowGraphInteger.Parse(intermediateValue);
  } else if (intermediateValue && intermediateValue.value !== void 0) {
    finalValue = intermediateValue.value;
  } else {
    finalValue = intermediateValue;
  }
  return finalValue;
}
function needsPathConverter(className) {
  return className === "FGSetPropertyBlock" || className === "FGGetPropertyBlock" || className === "FGPlayAnimationBlock" || className === "FGMeshPickEventBlock";
}

// node_modules/@babylonjs/core/FlowGraph/flowGraphBlock.js
var FlowGraphBlock = class {
  /** Constructor is protected so only subclasses can be instantiated
   * @param config optional configuration for this block
   */
  constructor(config) {
    var _a;
    this.config = config;
    this.uniqueId = RandomGUID();
    this.name = ((_a = this.config) == null ? void 0 : _a.name) ?? this.getClassName();
    this.dataInputs = [];
    this.dataOutputs = [];
  }
  /**
   * @internal
   */
  _updateOutputs(_context) {
  }
  /**
   * Registers a data input on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @returns the created connection
   */
  registerDataInput(name50, richType) {
    const input = new FlowGraphDataConnection(name50, FlowGraphConnectionType.Input, this, richType);
    this.dataInputs.push(input);
    return input;
  }
  /**
   * Registers a data output on the block.
   * @param name the name of the input
   * @param richType the type of the input
   * @returns the created connection
   */
  registerDataOutput(name50, richType) {
    const output = new FlowGraphDataConnection(name50, FlowGraphConnectionType.Output, this, richType);
    this.dataOutputs.push(output);
    return output;
  }
  /**
   * Given the name of a data input, returns the connection if it exists
   * @param name the name of the input
   * @returns the connection if it exists, undefined otherwise
   */
  getDataInput(name50) {
    return this.dataInputs.find((i) => i.name === name50);
  }
  /**
   * Given the name of a data output, returns the connection if it exists
   * @param name the name of the output
   * @returns the connection if it exists, undefined otherwise
   */
  getDataOutput(name50) {
    return this.dataOutputs.find((i) => i.name === name50);
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   * @param _valueSerializeFunction a function that serializes a specific value
   */
  serialize(serializationObject = {}, _valueSerializeFunction = defaultValueSerializationFunction) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.config = {};
    if (this.config) {
      serializationObject.config["name"] = this.config.name;
    }
    serializationObject.dataInputs = [];
    serializationObject.dataOutputs = [];
    serializationObject.className = this.getClassName();
    for (const input of this.dataInputs) {
      const serializedInput = {};
      input.serialize(serializedInput);
      serializationObject.dataInputs.push(serializedInput);
    }
    for (const output of this.dataOutputs) {
      const serializedOutput = {};
      output.serialize(serializedOutput);
      serializationObject.dataOutputs.push(serializedOutput);
    }
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return "FGBlock";
  }
  /**
   * Parses a block from a serialization object
   * @param serializationObject the object to parse from
   * @param parseOptions options for parsing the block
   * @returns the parsed block
   */
  static Parse(serializationObject, parseOptions) {
    const classType = Tools.Instantiate(serializationObject.className);
    const parsedConfig = {};
    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;
    if (serializationObject.config) {
      for (const key in serializationObject.config) {
        parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.scene);
      }
    }
    if (needsPathConverter(serializationObject.className)) {
      parsedConfig.pathConverter = parseOptions.pathConverter;
    }
    const obj = new classType(parsedConfig);
    obj.uniqueId = serializationObject.uniqueId;
    for (let i = 0; i < serializationObject.dataInputs.length; i++) {
      const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);
      if (dataInput) {
        dataInput.deserialize(serializationObject.dataInputs[i]);
      } else {
        throw new Error("Could not find data input with name " + serializationObject.dataInputs[i].name + " in block " + serializationObject.className);
      }
    }
    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {
      const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);
      if (dataOutput) {
        dataOutput.deserialize(serializationObject.dataOutputs[i]);
      } else {
        throw new Error("Could not find data output with name " + serializationObject.dataOutputs[i].name + " in block " + serializationObject.className);
      }
    }
    obj.metadata = serializationObject.metadata;
    obj.deserialize && obj.deserialize(serializationObject);
    return obj;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphSignalConnection.js
var FlowGraphSignalConnection = class extends FlowGraphConnection {
  /**
   * @internal
   * A signal input can be connected to more than one signal output,
   * but a signal output can only connect to one signal input
   * @returns true if the connection is singular
   */
  _isSingularConnection() {
    return this.connectionType === FlowGraphConnectionType.Output;
  }
  /**
   * @internal
   */
  _activateSignal(context) {
    var _a;
    if (this.connectionType === FlowGraphConnectionType.Input) {
      context._notifyExecuteNode(this._ownerBlock);
      this._ownerBlock._execute(context, this);
      context._increaseExecutionId();
    } else {
      (_a = this._connectedPoint[0]) == null ? void 0 : _a._activateSignal(context);
    }
  }
};
RegisterClass("FlowGraphSignalConnection", FlowGraphSignalConnection);

// node_modules/@babylonjs/core/FlowGraph/flowGraphExecutionBlock.js
var FlowGraphExecutionBlock = class extends FlowGraphBlock {
  constructor(config) {
    super(config);
    this.signalInputs = [];
    this.signalOutputs = [];
    this.in = this._registerSignalInput("in");
  }
  _registerSignalInput(name50) {
    const input = new FlowGraphSignalConnection(name50, FlowGraphConnectionType.Input, this);
    this.signalInputs.push(input);
    return input;
  }
  _registerSignalOutput(name50) {
    const output = new FlowGraphSignalConnection(name50, FlowGraphConnectionType.Output, this);
    this.signalOutputs.push(output);
    return output;
  }
  /**
   * Given a name of a signal input, return that input if it exists
   * @param name the name of the input
   * @returns if the input exists, the input. Otherwise, undefined.
   */
  getSignalInput(name50) {
    return this.signalInputs.find((input) => input.name === name50);
  }
  /**
   * Given a name of a signal output, return that input if it exists
   * @param name the name of the input
   * @returns if the input exists, the input. Otherwise, undefined.
   */
  getSignalOutput(name50) {
    return this.signalOutputs.find((output) => output.name === name50);
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize in
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.signalInputs = [];
    serializationObject.signalOutputs = [];
    for (const input of this.signalInputs) {
      const serializedInput = {};
      input.serialize(serializedInput);
      serializationObject.signalInputs.push(serializedInput);
    }
    for (const output of this.signalOutputs) {
      const serializedOutput = {};
      output.serialize(serializedOutput);
      serializationObject.signalOutputs.push(serializedOutput);
    }
  }
  /**
   * Deserializes from an object
   * @param serializationObject the object to deserialize from
   */
  deserialize(serializationObject) {
    for (let i = 0; i < serializationObject.signalInputs.length; i++) {
      const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);
      if (signalInput) {
        signalInput.deserialize(serializationObject.signalInputs[i]);
      } else {
        throw new Error("Could not find signal input with name " + serializationObject.signalInputs[i].name + " in block " + serializationObject.className);
      }
    }
    for (let i = 0; i < serializationObject.signalOutputs.length; i++) {
      const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);
      if (signalOutput) {
        signalOutput.deserialize(serializationObject.signalOutputs[i]);
      } else {
        throw new Error("Could not find signal output with name " + serializationObject.signalOutputs[i].name + " in block " + serializationObject.className);
      }
    }
  }
  /**
   * @returns the class name
   */
  getClassName() {
    return "FGExecutionBlock";
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphAsyncExecutionBlock.js
var FlowGraphAsyncExecutionBlock = class extends FlowGraphExecutionBlock {
  constructor(config) {
    super(config);
    this.out = this._registerSignalOutput("out");
    this.done = this._registerSignalOutput("done");
  }
  /**
   * @internal
   * @param context
   */
  _startPendingTasks(context) {
    this._preparePendingTasks(context);
    context._addPendingBlock(this);
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphEventBlock.js
var FlowGraphEventBlock = class extends FlowGraphAsyncExecutionBlock {
  /**
   * @internal
   */
  _execute(context) {
    context._notifyExecuteNode(this);
    this.out._activateSignal(context);
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphContext.js
var FlowGraphContext = class {
  constructor(params) {
    this.uniqueId = RandomGUID();
    this._userVariables = {};
    this._executionVariables = {};
    this._connectionValues = {};
    this._pendingBlocks = [];
    this._executionId = 0;
    this.onNodeExecutedObservable = new Observable();
    this._configuration = params;
  }
  /**
   * Check if a user-defined variable is defined.
   * @param name the name of the variable
   * @returns true if the variable is defined
   */
  hasVariable(name50) {
    return name50 in this._userVariables;
  }
  /**
   * Set a user-defined variable.
   * @param name the name of the variable
   * @param value the value of the variable
   */
  setVariable(name50, value) {
    this._userVariables[name50] = value;
  }
  /**
   * Get a user-defined variable.
   * @param name the name of the variable
   * @returns the value of the variable
   */
  getVariable(name50) {
    return this._userVariables[name50];
  }
  /**
   * Gets all user variables map
   */
  get userVariables() {
    return this._userVariables;
  }
  _getUniqueIdPrefixedName(obj, name50) {
    return `${obj.uniqueId}_${name50}`;
  }
  /**
   * Set an internal execution variable
   * @internal
   * @param name
   * @param value
   */
  _setExecutionVariable(block, name50, value) {
    this._executionVariables[this._getUniqueIdPrefixedName(block, name50)] = value;
  }
  /**
   * Get an internal execution variable
   * @internal
   * @param name
   * @returns
   */
  _getExecutionVariable(block, name50, defaultValue) {
    if (this._hasExecutionVariable(block, name50)) {
      return this._executionVariables[this._getUniqueIdPrefixedName(block, name50)];
    } else {
      return defaultValue;
    }
  }
  /**
   * Delete an internal execution variable
   * @internal
   * @param block
   * @param name
   */
  _deleteExecutionVariable(block, name50) {
    delete this._executionVariables[this._getUniqueIdPrefixedName(block, name50)];
  }
  /**
   * Check if an internal execution variable is defined
   * @internal
   * @param block
   * @param name
   * @returns
   */
  _hasExecutionVariable(block, name50) {
    return this._getUniqueIdPrefixedName(block, name50) in this._executionVariables;
  }
  /**
   * Check if a connection value is defined
   * @internal
   * @param connectionPoint
   * @returns
   */
  _hasConnectionValue(connectionPoint) {
    return connectionPoint.uniqueId in this._connectionValues;
  }
  /**
   * Set a connection value
   * @internal
   * @param connectionPoint
   * @param value
   */
  _setConnectionValue(connectionPoint, value) {
    this._connectionValues[connectionPoint.uniqueId] = value;
  }
  /**
   * Get a connection value
   * @internal
   * @param connectionPoint
   * @returns
   */
  _getConnectionValue(connectionPoint) {
    return this._connectionValues[connectionPoint.uniqueId];
  }
  /**
   * Get the configuration
   * @internal
   * @param name
   * @param value
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Add a block to the list of blocks that have pending tasks.
   * @internal
   * @param block
   */
  _addPendingBlock(block) {
    this._pendingBlocks.push(block);
  }
  /**
   * Remove a block from the list of blocks that have pending tasks.
   * @internal
   * @param block
   */
  _removePendingBlock(block) {
    const index = this._pendingBlocks.indexOf(block);
    if (index !== -1) {
      this._pendingBlocks.splice(index, 1);
    }
  }
  /**
   * Clear all pending blocks.
   * @internal
   */
  _clearPendingBlocks() {
    for (const block of this._pendingBlocks) {
      block._cancelPendingTasks(this);
    }
    this._pendingBlocks.length = 0;
  }
  /**
   * @internal
   * Function that notifies the node executed observable
   * @param node
   */
  _notifyExecuteNode(node) {
    this.onNodeExecutedObservable.notifyObservers(node);
  }
  /**
   * @internal
   */
  _increaseExecutionId() {
    this._executionId++;
  }
  /**
   * A monotonically increasing ID for each execution.
   * Incremented for every block executed.
   */
  get executionId() {
    return this._executionId;
  }
  /**
   * Serializes a context
   * @param serializationObject the object to write the values in
   * @param valueSerializationFunction a function to serialize complex values
   */
  serialize(serializationObject = {}, valueSerializationFunction = defaultValueSerializationFunction) {
    serializationObject.uniqueId = this.uniqueId;
    serializationObject._userVariables = {};
    for (const key in this._userVariables) {
      valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);
    }
    serializationObject._connectionValues = {};
    for (const key in this._connectionValues) {
      valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);
    }
  }
  /**
   * @returns the class name of the object.
   */
  getClassName() {
    return "FGContext";
  }
  /**
   * Parses a context
   * @param serializationObject the object containing the context serialization values
   * @param options the options for parsing the context
   * @returns
   */
  static Parse(serializationObject, options) {
    const result = options.graph.createContext();
    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
    result.uniqueId = serializationObject.uniqueId;
    for (const key in serializationObject._userVariables) {
      const value = valueParseFunction(key, serializationObject._userVariables, result._configuration.scene);
      result._userVariables[key] = value;
    }
    for (const key in serializationObject._connectionValues) {
      const value = valueParseFunction(key, serializationObject._connectionValues, result._configuration.scene);
      result._connectionValues[key] = value;
    }
    return result;
  }
};
__decorate([
  serialize()
], FlowGraphContext.prototype, "uniqueId", void 0);

// node_modules/@babylonjs/core/FlowGraph/utils.js
function _isADescendantOf(mesh1, mesh2) {
  return !!(mesh1.parent && (mesh1.parent === mesh2 || _isADescendantOf(mesh1.parent, mesh2)));
}

// node_modules/@babylonjs/core/FlowGraph/Blocks/Event/flowGraphMeshPickEventBlock.js
var FlowGraphMeshPickEventBlock = class _FlowGraphMeshPickEventBlock extends FlowGraphEventBlock {
  constructor(config) {
    super(config);
    this.config = config;
  }
  _getReferencedMesh() {
    const iAccessor = this.config.pathConverter.convert(this.config.path);
    const mesh = iAccessor.info.getObject(iAccessor.object);
    if (!mesh || !(mesh instanceof AbstractMesh)) {
      throw new Error("Mesh pick event block requires a valid mesh");
    }
    return mesh;
  }
  /**
   * @internal
   */
  _preparePendingTasks(context) {
    let pickObserver = context._getExecutionVariable(this, "meshPickObserver");
    if (!pickObserver) {
      const mesh = this._getReferencedMesh();
      context._setExecutionVariable(this, "mesh", mesh);
      pickObserver = mesh.getScene().onPointerObservable.add((pointerInfo) => {
        var _a, _b, _c;
        if (pointerInfo.type === PointerEventTypes.POINTERPICK && ((_a = pointerInfo.pickInfo) == null ? void 0 : _a.pickedMesh) && (((_b = pointerInfo.pickInfo) == null ? void 0 : _b.pickedMesh) === mesh || _isADescendantOf((_c = pointerInfo.pickInfo) == null ? void 0 : _c.pickedMesh, mesh))) {
          this._execute(context);
        }
      });
      const disposeObserver = mesh.onDisposeObservable.add(() => this._onDispose);
      context._setExecutionVariable(this, "meshPickObserver", pickObserver);
      context._setExecutionVariable(this, "meshDisposeObserver", disposeObserver);
    }
  }
  _onDispose(context) {
    this._cancelPendingTasks(context);
    context._removePendingBlock(this);
  }
  /**
   * @internal
   */
  _cancelPendingTasks(context) {
    const mesh = context._getExecutionVariable(this, "mesh");
    const pickObserver = context._getExecutionVariable(this, "meshPickObserver");
    const disposeObserver = context._getExecutionVariable(this, "meshDisposeObserver");
    mesh.getScene().onPointerObservable.remove(pickObserver);
    mesh.onDisposeObservable.remove(disposeObserver);
    context._deleteExecutionVariable(this, "mesh");
    context._deleteExecutionVariable(this, "meshPickObserver");
    context._deleteExecutionVariable(this, "meshDisposeObserver");
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphMeshPickEventBlock.ClassName;
  }
  /**
   * Serializes the block to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.config.path = this.config.path;
  }
};
FlowGraphMeshPickEventBlock.ClassName = "FGMeshPickEventBlock";
RegisterClass(FlowGraphMeshPickEventBlock.ClassName, FlowGraphMeshPickEventBlock);

// node_modules/@babylonjs/core/FlowGraph/flowGraph.js
var FlowGraphState;
(function(FlowGraphState2) {
  FlowGraphState2[FlowGraphState2["Stopped"] = 0] = "Stopped";
  FlowGraphState2[FlowGraphState2["Started"] = 1] = "Started";
})(FlowGraphState || (FlowGraphState = {}));
var FlowGraph = class _FlowGraph {
  /**
   * Construct a Flow Graph
   * @param params construction parameters. currently only the scene
   */
  constructor(params) {
    this._eventBlocks = [];
    this._executionContexts = [];
    this.state = FlowGraphState.Stopped;
    this._scene = params.scene;
    this._coordinator = params.coordinator;
    this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => this.dispose());
  }
  /**
   * Create a context. A context represents one self contained execution for the graph, with its own variables.
   * @returns the context, where you can get and set variables
   */
  createContext() {
    const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });
    this._executionContexts.push(context);
    return context;
  }
  /**
   * Returns the execution context at a given index
   * @param index the index of the context
   * @returns the execution context at that index
   */
  getContext(index) {
    return this._executionContexts[index];
  }
  /**
   * Add an event block. When the graph is started, it will start listening to events
   * from the block and execute the graph when they are triggered.
   * @param block the event block to be added
   */
  addEventBlock(block) {
    this._eventBlocks.push(block);
  }
  /**
   * Starts the flow graph. Initializes the event blocks and starts listening to events.
   */
  start() {
    if (this.state === FlowGraphState.Started) {
      return;
    }
    this.state = FlowGraphState.Started;
    if (this._executionContexts.length === 0) {
      this.createContext();
    }
    for (const context of this._executionContexts) {
      const contextualOrder = this._getContextualOrder();
      for (const block of contextualOrder) {
        block._startPendingTasks(context);
      }
    }
  }
  _getContextualOrder() {
    const order = [];
    for (const block1 of this._eventBlocks) {
      if (block1.getClassName() === FlowGraphMeshPickEventBlock.ClassName) {
        const mesh1 = block1._getReferencedMesh();
        let i = 0;
        for (; i < order.length; i++) {
          const block2 = order[i];
          const mesh2 = block2._getReferencedMesh();
          if (mesh1 && mesh2 && _isADescendantOf(mesh1, mesh2)) {
            break;
          }
        }
        order.splice(i, 0, block1);
      } else {
        order.push(block1);
      }
    }
    return order;
  }
  /**
   * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.
   */
  dispose() {
    if (this.state === FlowGraphState.Stopped) {
      return;
    }
    this.state = FlowGraphState.Stopped;
    for (const context of this._executionContexts) {
      context._clearPendingBlocks();
    }
    this._executionContexts.length = 0;
    this._eventBlocks.length = 0;
    this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
    this._sceneDisposeObserver = null;
  }
  /**
   * Executes a function in all blocks of a flow graph, starting with the event blocks.
   * @param visitor the function to execute.
   */
  visitAllBlocks(visitor) {
    const visitList = [];
    const idsAddedToVisitList = /* @__PURE__ */ new Set();
    for (const block of this._eventBlocks) {
      visitList.push(block);
      idsAddedToVisitList.add(block.uniqueId);
    }
    while (visitList.length > 0) {
      const block = visitList.pop();
      visitor(block);
      for (const dataIn of block.dataInputs) {
        for (const connection of dataIn._connectedPoint) {
          if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {
            visitList.push(connection._ownerBlock);
            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);
          }
        }
      }
      if (block instanceof FlowGraphExecutionBlock) {
        for (const signalOut of block.signalOutputs) {
          for (const connection of signalOut._connectedPoint) {
            if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {
              visitList.push(connection._ownerBlock);
              idsAddedToVisitList.add(connection._ownerBlock.uniqueId);
            }
          }
        }
      }
    }
  }
  /**
   * Serializes a graph
   * @param serializationObject the object to write the values in
   * @param valueSerializeFunction a function to serialize complex values
   */
  serialize(serializationObject = {}, valueSerializeFunction) {
    serializationObject.allBlocks = [];
    this.visitAllBlocks((block) => {
      const serializedBlock = {};
      block.serialize(serializedBlock);
      serializationObject.allBlocks.push(serializedBlock);
    });
    serializationObject.executionContexts = [];
    for (const context of this._executionContexts) {
      const serializedContext = {};
      context.serialize(serializedContext, valueSerializeFunction);
      serializationObject.executionContexts.push(serializedContext);
    }
  }
  /**
   * Given a list of blocks, find an output data connection that has a specific unique id
   * @param blocks a list of flow graph blocks
   * @param uniqueId the unique id of a connection
   * @returns the connection that has this unique id. throws an error if none was found
   */
  static GetDataOutConnectionByUniqueId(blocks, uniqueId) {
    for (const block of blocks) {
      for (const dataOut of block.dataOutputs) {
        if (dataOut.uniqueId === uniqueId) {
          return dataOut;
        }
      }
    }
    throw new Error("Could not find data out connection with unique id " + uniqueId);
  }
  /**
   * Given a list of blocks, find an input signal connection that has a specific unique id
   * @param blocks a list of flow graph blocks
   * @param uniqueId the unique id of a connection
   * @returns the connection that has this unique id. throws an error if none was found
   */
  static GetSignalInConnectionByUniqueId(blocks, uniqueId) {
    for (const block of blocks) {
      if (block instanceof FlowGraphExecutionBlock) {
        for (const signalIn of block.signalInputs) {
          if (signalIn.uniqueId === uniqueId) {
            return signalIn;
          }
        }
      }
    }
    throw new Error("Could not find signal in connection with unique id " + uniqueId);
  }
  /**
   * Parses a graph from a given serialization object
   * @param serializationObject the object where the values are written
   * @param options options for parsing the graph
   * @returns the parsed graph
   */
  static Parse(serializationObject, options) {
    const graph = options.coordinator.createGraph();
    const blocks = [];
    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
    for (const serializedBlock of serializationObject.allBlocks) {
      const block = FlowGraphBlock.Parse(serializedBlock, { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, valueParseFunction });
      blocks.push(block);
      if (block instanceof FlowGraphEventBlock) {
        graph.addEventBlock(block);
      }
    }
    for (const block of blocks) {
      for (const dataIn of block.dataInputs) {
        for (const serializedConnection of dataIn.connectedPointIds) {
          const connection = _FlowGraph.GetDataOutConnectionByUniqueId(blocks, serializedConnection);
          dataIn.connectTo(connection);
        }
      }
      if (block instanceof FlowGraphExecutionBlock) {
        for (const signalOut of block.signalOutputs) {
          for (const serializedConnection of signalOut.connectedPointIds) {
            const connection = _FlowGraph.GetSignalInConnectionByUniqueId(blocks, serializedConnection);
            signalOut.connectTo(connection);
          }
        }
      }
    }
    for (const serializedContext of serializationObject.executionContexts) {
      FlowGraphContext.Parse(serializedContext, { graph, valueParseFunction });
    }
    return graph;
  }
};

// node_modules/@babylonjs/core/FlowGraph/flowGraphCoordinator.js
var FlowGraphCoordinator = class _FlowGraphCoordinator {
  constructor(config) {
    this.config = config;
    this._flowGraphs = [];
    this._customEventsMap = /* @__PURE__ */ new Map();
    this.config.scene.onDisposeObservable.add(() => {
      this.dispose();
    });
    const coordinators = _FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];
    coordinators.push(this);
  }
  /**
   * Creates a new flow graph and adds it to the list of existing flow graphs
   * @returns a new flow graph
   */
  createGraph() {
    const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });
    this._flowGraphs.push(graph);
    return graph;
  }
  /**
   * Removes a flow graph from the list of existing flow graphs and disposes it
   * @param graph the graph to remove
   */
  removeGraph(graph) {
    const index = this._flowGraphs.indexOf(graph);
    if (index !== -1) {
      graph.dispose();
      this._flowGraphs.splice(index, 1);
    }
  }
  /**
   * Starts all graphs
   */
  start() {
    this._flowGraphs.forEach((graph) => graph.start());
  }
  /**
   * Disposes all graphs
   */
  dispose() {
    this._flowGraphs.forEach((graph) => graph.dispose());
    this._flowGraphs.length = 0;
    const coordinators = _FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];
    const index = coordinators.indexOf(this);
    if (index !== -1) {
      coordinators.splice(index, 1);
    }
  }
  /**
   * Serializes this coordinator to a JSON object.
   * @param serializationObject the object to serialize to
   * @param valueSerializeFunction the function to use to serialize the value
   */
  serialize(serializationObject, valueSerializeFunction) {
    serializationObject._flowGraphs = [];
    this._flowGraphs.forEach((graph) => {
      const serializedGraph = {};
      graph.serialize(serializedGraph, valueSerializeFunction);
      serializationObject._flowGraphs.push(serializedGraph);
    });
  }
  /**
   * Parses a serialized coordinator.
   * @param serializedObject the object to parse
   * @param options the options to use when parsing
   * @returns the parsed coordinator
   */
  static Parse(serializedObject, options) {
    var _a;
    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;
    const coordinator = new _FlowGraphCoordinator({ scene: options.scene });
    (_a = serializedObject._flowGraphs) == null ? void 0 : _a.forEach((serializedGraph) => {
      FlowGraph.Parse(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter });
    });
    return coordinator;
  }
  /**
   * Gets the list of flow graphs
   */
  get flowGraphs() {
    return this._flowGraphs;
  }
  /**
   * Get an observable that will be notified when the event with the given id is fired.
   * @param id the id of the event
   * @returns the observable for the event
   */
  getCustomEventObservable(id) {
    let observable = this._customEventsMap.get(id);
    if (!observable) {
      observable = new Observable();
      this._customEventsMap.set(id, observable);
    }
    return observable;
  }
  /**
   * Notifies the observable for the given event id with the given data.
   * @param id the id of the event
   * @param data the data to send with the event
   */
  notifyCustomEvent(id, data) {
    const observable = this._customEventsMap.get(id);
    if (observable) {
      observable.notifyObservers(data);
    }
  }
};
FlowGraphCoordinator.SceneCoordinators = /* @__PURE__ */ new Map();

// node_modules/@babylonjs/core/FlowGraph/flowGraphExecutionBlockWithOutSignal.js
var FlowGraphExecutionBlockWithOutSignal = class extends FlowGraphExecutionBlock {
  constructor(config) {
    super(config);
    this.out = this._registerSignalOutput("out");
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphConsoleLogBlock.js
var FlowGraphConsoleLogBlock = class _FlowGraphConsoleLogBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config) {
    super(config);
    this.message = this.registerDataInput("message", RichTypeAny);
  }
  /**
   * @internal
   */
  _execute(context) {
    const messageValue = this.message.getValue(context);
    Logger.Log(messageValue);
    this.out._activateSignal(context);
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphConsoleLogBlock.ClassName;
  }
};
FlowGraphConsoleLogBlock.ClassName = "FGConsoleLogBlock";
RegisterClass(FlowGraphConsoleLogBlock.ClassName, FlowGraphConsoleLogBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphSetVariableBlock.js
var FlowGraphSetVariableBlock = class _FlowGraphSetVariableBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config) {
    super(config);
    this.config = config;
    this.input = this.registerDataInput(config.variableName, RichTypeAny);
  }
  _execute(context) {
    const variableNameValue = this.config.variableName;
    const inputValue = this.input.getValue(context);
    context.setVariable(variableNameValue, inputValue);
    this.out._activateSignal(context);
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSetVariableBlock.ClassName;
  }
};
FlowGraphSetVariableBlock.ClassName = "FGSetVariableBlock";
RegisterClass(FlowGraphSetVariableBlock.ClassName, FlowGraphSetVariableBlock);

// node_modules/@babylonjs/core/FlowGraph/flowGraphPathConverterComponent.js
var pathHasTemplatesRegex = new RegExp(/\{(\w+)\}/g);
var FlowGraphPathConverterComponent = class {
  constructor(path, ownerBlock) {
    this.path = path;
    this.ownerBlock = ownerBlock;
    this.templatedInputs = [];
    let match = pathHasTemplatesRegex.exec(path);
    while (match) {
      const [, matchGroup] = match;
      this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger));
      match = pathHasTemplatesRegex.exec(path);
    }
  }
  getAccessor(pathConverter, context) {
    let finalPath = this.path;
    for (const templatedInput of this.templatedInputs) {
      const valueToReplace = templatedInput.getValue(context).value;
      finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());
    }
    return pathConverter.convert(finalPath);
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphSetPropertyBlock.js
var FlowGraphSetPropertyBlock = class _FlowGraphSetPropertyBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config) {
    super(config);
    this.config = config;
    this.a = this.registerDataInput("a", RichTypeAny);
    this.templateComponent = new FlowGraphPathConverterComponent(config.path, this);
  }
  _execute(context) {
    const value = this.a.getValue(context);
    const accessor = this.templateComponent.getAccessor(this.config.pathConverter, context);
    accessor.info.set(value, accessor.object);
    this.out._activateSignal(context);
  }
  /**
   * Serializes the block to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.config.path = this.config.path;
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSetPropertyBlock.ClassName;
  }
};
FlowGraphSetPropertyBlock.ClassName = "FGSetPropertyBlock";
RegisterClass("FGSetPropertyBlock", FlowGraphSetPropertyBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/flowGraphSendCustomEventBlock.js
var FlowGraphSendCustomEventBlock = class _FlowGraphSendCustomEventBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config) {
    super(config);
    this.config = config;
    for (let i = 0; i < this.config.eventData.length; i++) {
      const dataName = this.config.eventData[i];
      this.registerDataInput(dataName, RichTypeAny);
    }
  }
  _execute(context) {
    const eventId = this.config.eventId;
    const eventDatas = this.dataInputs.map((port) => port.getValue(context));
    context.configuration.coordinator.notifyCustomEvent(eventId, eventDatas);
    this.out._activateSignal(context);
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSendCustomEventBlock.ClassName;
  }
};
FlowGraphSendCustomEventBlock.ClassName = "FGSendCustomEventBlock";
RegisterClass("FGSendCustomEventBlock", FlowGraphSendCustomEventBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphDoNBlock.js
var FlowGraphDoNBlock = class _FlowGraphDoNBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config = { startIndex: new FlowGraphInteger(0) }) {
    super(config);
    this.config = config;
    this.reset = this._registerSignalInput("reset");
    this.n = this.registerDataInput("n", RichTypeFlowGraphInteger);
    this.value = this.registerDataOutput("value", RichTypeFlowGraphInteger);
  }
  _execute(context, callingSignal) {
    if (callingSignal === this.reset) {
      this.value.setValue(this.config.startIndex, context);
    } else {
      const currentCountValue = this.value.getValue(context);
      if (currentCountValue.value < this.n.getValue(context).value) {
        this.value.setValue(new FlowGraphInteger(currentCountValue.value + 1), context);
        this.out._activateSignal(context);
      }
    }
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphDoNBlock.ClassName;
  }
};
FlowGraphDoNBlock.ClassName = "FGDoNBlock";
RegisterClass(FlowGraphDoNBlock.ClassName, FlowGraphDoNBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphTimerBlock.js
var FlowGraphTimerBlock = class _FlowGraphTimerBlock extends FlowGraphAsyncExecutionBlock {
  constructor(config) {
    super(config);
    this.timeout = this.registerDataInput("timeout", RichTypeNumber);
  }
  _preparePendingTasks(context) {
    const currentTimeout = this.timeout.getValue(context);
    if (currentTimeout !== void 0 && currentTimeout >= 0) {
      const timers = context._getExecutionVariable(this, "runningTimers") || [];
      const scene = context.configuration.scene;
      const timer = new AdvancedTimer({
        timeout: currentTimeout,
        contextObservable: scene.onBeforeRenderObservable,
        onEnded: () => this._onEnded(timer, context)
      });
      timer.start();
      timers.push(timer);
      context._setExecutionVariable(this, "runningTimers", timers);
    }
  }
  /**
   * @internal
   */
  _execute(context) {
    this._startPendingTasks(context);
    this.out._activateSignal(context);
  }
  _onEnded(timer, context) {
    const timers = context._getExecutionVariable(this, "runningTimers") || [];
    const index = timers.indexOf(timer);
    if (index !== -1) {
      timers.splice(index, 1);
    } else {
      Tools.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list");
    }
    context._removePendingBlock(this);
    this.done._activateSignal(context);
  }
  _cancelPendingTasks(context) {
    const timers = context._getExecutionVariable(this, "runningTimers") || [];
    for (const timer of timers) {
      timer.dispose();
    }
    context._deleteExecutionVariable(this, "runningTimers");
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphTimerBlock.ClassName;
  }
};
FlowGraphTimerBlock.ClassName = "FGTimerBlock";
RegisterClass("FGTimerBlock", FlowGraphTimerBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphWhileLoopBlock.js
var FlowGraphWhileLoopBlock = class _FlowGraphWhileLoopBlock extends FlowGraphExecutionBlockWithOutSignal {
  constructor(config) {
    super(config);
    this.config = config;
    this.condition = this.registerDataInput("condition", RichTypeBoolean);
    this.loopBody = this._registerSignalOutput("loopBody");
  }
  _execute(context, _callingSignal) {
    var _a;
    let conditionValue = this.condition.getValue(context);
    if (((_a = this.config) == null ? void 0 : _a.isDo) && !conditionValue) {
      this.loopBody._activateSignal(context);
    }
    while (conditionValue) {
      this.loopBody._activateSignal(context);
      conditionValue = this.condition.getValue(context);
    }
    this.out._activateSignal(context);
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphWhileLoopBlock.ClassName;
  }
  /**
   * Serializes the block to a JSON object.
   * @param serializationObject the object to serialize to.
   */
  serialize(serializationObject) {
    var _a;
    super.serialize(serializationObject);
    serializationObject.isDo = (_a = this.config) == null ? void 0 : _a.isDo;
  }
};
FlowGraphWhileLoopBlock.ClassName = "FGWhileLoopBlock";
RegisterClass(FlowGraphWhileLoopBlock.ClassName, FlowGraphWhileLoopBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSequenceBlock.js
var FlowGraphSequenceBlock = class _FlowGraphSequenceBlock extends FlowGraphExecutionBlock {
  constructor(config) {
    super(config);
    this.config = config;
    this.outFlows = [];
    for (let i = 0; i < this.config.numberOutputFlows; i++) {
      this.outFlows.push(this._registerSignalOutput(`${i}`));
    }
  }
  _execute(context) {
    for (let i = 0; i < this.config.numberOutputFlows; i++) {
      this.outFlows[i]._activateSignal(context);
    }
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSequenceBlock.ClassName;
  }
};
FlowGraphSequenceBlock.ClassName = "FGSequenceBlock";
RegisterClass(FlowGraphSequenceBlock.ClassName, FlowGraphSequenceBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphGetVariableBlock.js
var FlowGraphGetVariableBlock = class _FlowGraphGetVariableBlock extends FlowGraphBlock {
  /**
   * Construct a FlowGraphGetVariableBlock.
   * @param config construction parameters
   */
  constructor(config) {
    super(config);
    this.config = config;
    this.output = this.registerDataOutput(config.variableName, RichTypeAny);
  }
  /**
   * @internal
   */
  _updateOutputs(context) {
    const variableNameValue = this.config.variableName;
    if (context.hasVariable(variableNameValue)) {
      this.output.setValue(context.getVariable(variableNameValue), context);
    }
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return _FlowGraphGetVariableBlock.ClassName;
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.config.variableName = this.config.variableName;
  }
};
FlowGraphGetVariableBlock.ClassName = "FGGetVariableBlock";
RegisterClass(FlowGraphGetVariableBlock.ClassName, FlowGraphGetVariableBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphGetPropertyBlock.js
var FlowGraphGetPropertyBlock = class _FlowGraphGetPropertyBlock extends FlowGraphBlock {
  constructor(config) {
    super(config);
    this.config = config;
    this.value = this.registerDataOutput("value", RichTypeAny);
    this.templateComponent = new FlowGraphPathConverterComponent(config.path, this);
  }
  _updateOutputs(context) {
    const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);
    const value = accessorContainer.info.get(accessorContainer.object);
    this.value.setValue(value, context);
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return _FlowGraphGetPropertyBlock.ClassName;
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject = {}) {
    super.serialize(serializationObject);
    serializationObject.config.path = this.config.path;
  }
};
FlowGraphGetPropertyBlock.ClassName = "FGGetPropertyBlock";
RegisterClass(FlowGraphGetPropertyBlock.ClassName, FlowGraphGetPropertyBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphCachedOperationBlock.js
var cacheName = "cachedOperationValue";
var cacheExecIdName = "cachedExecutionId";
var FlowGraphCachedOperationBlock = class extends FlowGraphBlock {
  constructor(outputRichType, config) {
    super(config);
    this.value = this.registerDataOutput("value", outputRichType);
  }
  _updateOutputs(context) {
    const cachedExecutionId = context._getExecutionVariable(this, cacheExecIdName);
    const cachedValue = context._getExecutionVariable(this, cacheName);
    if (cachedValue !== void 0 && cachedExecutionId === context.executionId) {
      this.value.setValue(cachedValue, context);
    } else {
      const calculatedValue = this._doOperation(context);
      context._setExecutionVariable(this, cacheName, calculatedValue);
      context._setExecutionVariable(this, cacheExecIdName, context.executionId);
      this.value.setValue(calculatedValue, context);
    }
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphBinaryOperationBlock.js
var FlowGraphBinaryOperationBlock = class extends FlowGraphCachedOperationBlock {
  constructor(leftRichType, rightRichType, resultRichType, _operation, _className, config) {
    super(resultRichType, config);
    this._operation = _operation;
    this._className = _className;
    this.a = this.registerDataInput("a", leftRichType);
    this.b = this.registerDataInput("b", rightRichType);
  }
  /**
   * the operation performed by this block
   * @param context the graph context
   * @returns the result of the operation
   */
  _doOperation(context) {
    return this._operation(this.a.getValue(context), this.b.getValue(context));
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return this._className;
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphConstantOperationBlock.js
var FlowGraphConstantOperationBlock = class extends FlowGraphCachedOperationBlock {
  constructor(richType, _operation, _className, config) {
    super(richType, config);
    this._operation = _operation;
    this._className = _className;
  }
  /**
   * the operation performed by this block
   * @param _context the graph context
   * @returns the result of the operation
   */
  _doOperation(_context) {
    return this._operation();
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return this._className;
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphUnaryOperationBlock.js
var FlowGraphUnaryOperationBlock = class extends FlowGraphCachedOperationBlock {
  constructor(inputRichType, resultRichType, _operation, _className, config) {
    super(resultRichType, config);
    this._operation = _operation;
    this._className = _className;
    this.a = this.registerDataInput("a", inputRichType);
  }
  /**
   * the operation performed by this block
   * @param context the graph context
   * @returns the result of the operation
   */
  _doOperation(context) {
    return this._operation(this.a.getValue(context));
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return this._className;
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/flowGraphTernaryOperationBlock.js
var FlowGraphTernaryOperationBlock = class extends FlowGraphCachedOperationBlock {
  constructor(t1Type, t2Type, t3Type, resultRichType, _operation, _className, config) {
    super(resultRichType, config);
    this._operation = _operation;
    this._className = _className;
    this.a = this.registerDataInput("a", t1Type);
    this.b = this.registerDataInput("b", t2Type);
    this.c = this.registerDataInput("c", t3Type);
  }
  /**
   * the operation performed by this block
   * @param context the graph context
   * @returns the result of the operation
   */
  _doOperation(context) {
    return this._operation(this.a.getValue(context), this.b.getValue(context), this.c.getValue(context));
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return this._className;
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphMathBlocks.js
function _getClassNameOf(v) {
  if (v.getClassName) {
    return v.getClassName();
  }
  return "";
}
function _areSameVectorClass(className, className2) {
  return className === "Vector2" && className2 === "Vector2" || className === "Vector3" && className2 === "Vector3" || className === "Vector4" && className2 === "Vector4";
}
function _areSameMatrixClass(className, className2) {
  return className === "Matrix" && className2 === "Matrix";
}
function _areSameIntegerClass(className, className2) {
  return className === "FlowGraphInteger" && className2 === "FlowGraphInteger";
}
var FlowGraphAddBlock = class _FlowGraphAddBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAdd(a, b), _FlowGraphAddBlock.ClassName, config);
  }
  _polymorphicAdd(a, b) {
    const aClassName = _getClassNameOf(a);
    const bClassName = _getClassNameOf(b);
    if (_areSameVectorClass(aClassName, bClassName) || _areSameMatrixClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {
      return a.add(b);
    } else {
      return a + b;
    }
  }
};
FlowGraphAddBlock.ClassName = "FGAddBlock";
RegisterClass(FlowGraphAddBlock.ClassName, FlowGraphAddBlock);
var FlowGraphSubtractBlock = class _FlowGraphSubtractBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAdd(a, b), _FlowGraphSubtractBlock.ClassName, config);
  }
  _polymorphicAdd(a, b) {
    const aClassName = _getClassNameOf(a);
    const bClassName = _getClassNameOf(b);
    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {
      return a.subtract(b);
    } else if (_areSameMatrixClass(aClassName, bClassName)) {
      return a.add(b.scale(-1));
    } else {
      return a - b;
    }
  }
};
FlowGraphSubtractBlock.ClassName = "FGSubBlock";
RegisterClass(FlowGraphSubtractBlock.ClassName, FlowGraphSubtractBlock);
var FlowGraphMultiplyBlock = class _FlowGraphMultiplyBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMultiply(a, b), _FlowGraphMultiplyBlock.ClassName, config);
  }
  _polymorphicMultiply(a, b) {
    const aClassName = _getClassNameOf(a);
    const bClassName = _getClassNameOf(b);
    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {
      return a.multiply(b);
    } else if (_areSameMatrixClass(aClassName, bClassName)) {
      return Matrix.FromValues(a.m[0] * b.m[0], a.m[4] * b.m[4], a.m[8] * b.m[8], a.m[12] * b.m[12], a.m[1] * b.m[1], a.m[5] * b.m[5], a.m[9] * b.m[9], a.m[13] * b.m[13], a.m[2] * b.m[2], a.m[6] * b.m[6], a.m[10] * b.m[10], a.m[14] * b.m[14], a.m[3] * b.m[3], a.m[7] * b.m[7], a.m[11] * b.m[11], a.m[15] * b.m[15]);
    } else {
      return a * b;
    }
  }
};
FlowGraphMultiplyBlock.ClassName = "FGMultiplyBlock";
RegisterClass(FlowGraphMultiplyBlock.ClassName, FlowGraphMultiplyBlock);
var FlowGraphDivideBlock = class _FlowGraphDivideBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicDivide(a, b), _FlowGraphDivideBlock.ClassName, config);
  }
  _polymorphicDivide(a, b) {
    const aClassName = _getClassNameOf(a);
    const bClassName = _getClassNameOf(b);
    if (_areSameVectorClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {
      return a.divide(b);
    } else if (_areSameMatrixClass(aClassName, bClassName)) {
      return Matrix.FromValues(a.m[0] / b.m[0], a.m[4] / b.m[4], a.m[8] / b.m[8], a.m[12] / b.m[12], a.m[1] / b.m[1], a.m[5] / b.m[5], a.m[9] / b.m[9], a.m[13] / b.m[13], a.m[2] / b.m[2], a.m[6] / b.m[6], a.m[10] / b.m[10], a.m[14] / b.m[14], a.m[3] / b.m[3], a.m[7] / b.m[7], a.m[11] / b.m[11], a.m[15] / b.m[15]);
    } else {
      return a / b;
    }
  }
};
FlowGraphDivideBlock.ClassName = "FGDivideBlock";
RegisterClass(FlowGraphDivideBlock.ClassName, FlowGraphDivideBlock);
var FlowGraphRandomBlock = class _FlowGraphRandomBlock extends FlowGraphConstantOperationBlock {
  constructor(config) {
    super(RichTypeNumber, () => Math.random(), _FlowGraphRandomBlock.ClassName, config);
  }
};
FlowGraphRandomBlock.ClassName = "FGRandomBlock";
RegisterClass(FlowGraphRandomBlock.ClassName, FlowGraphRandomBlock);
var FlowGraphDotBlock = class _FlowGraphDotBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), _FlowGraphDotBlock.ClassName, config);
  }
  _polymorphicDot(a, b) {
    const className = _getClassNameOf(a);
    switch (className) {
      case "Vector2":
        return Vector2.Dot(a, b);
      case "Vector3":
        return Vector3.Dot(a, b);
      case "Vector4":
        return Vector4.Dot(a, b);
      default:
        throw new Error(`Cannot get dot product of ${a} and ${b}`);
    }
  }
};
FlowGraphDotBlock.ClassName = "FGDotBlock";
RegisterClass(FlowGraphDotBlock.ClassName, FlowGraphDotBlock);
var FlowGraphEBlock = class _FlowGraphEBlock extends FlowGraphConstantOperationBlock {
  constructor(config) {
    super(RichTypeNumber, () => Math.E, _FlowGraphEBlock.ClassName, config);
  }
};
FlowGraphEBlock.ClassName = "FGEBlock";
RegisterClass(FlowGraphEBlock.ClassName, FlowGraphEBlock);
var FlowGraphPiBlock = class _FlowGraphPiBlock extends FlowGraphConstantOperationBlock {
  constructor(config) {
    super(RichTypeNumber, () => Math.PI, _FlowGraphPiBlock.ClassName, config);
  }
};
FlowGraphPiBlock.ClassName = "FGPIBlock";
RegisterClass(FlowGraphPiBlock.ClassName, FlowGraphPiBlock);
var FlowGraphInfBlock = class _FlowGraphInfBlock extends FlowGraphConstantOperationBlock {
  constructor(config) {
    super(RichTypeNumber, () => Number.POSITIVE_INFINITY, _FlowGraphInfBlock.ClassName, config);
  }
};
FlowGraphInfBlock.ClassName = "FGInfBlock";
RegisterClass(FlowGraphInfBlock.ClassName, FlowGraphInfBlock);
var FlowGraphNaNBlock = class _FlowGraphNaNBlock extends FlowGraphConstantOperationBlock {
  constructor(config) {
    super(RichTypeNumber, () => Number.NaN, _FlowGraphNaNBlock.ClassName, config);
  }
};
FlowGraphNaNBlock.ClassName = "FGNaNBlock";
RegisterClass(FlowGraphNaNBlock.ClassName, FlowGraphNaNBlock);
function _componentWiseUnaryOperation(a, op) {
  const aClassName = _getClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      return new FlowGraphInteger(op(a.value));
    case "Vector2":
      return new Vector2(op(a.x), op(a.y));
    case "Vector3":
      return new Vector3(op(a.x), op(a.y), op(a.z));
    case "Vector4":
      return new Vector4(op(a.x), op(a.y), op(a.z), op(a.w));
    case "Matrix":
      return Matrix.FromValues(op(a.m[0]), op(a.m[4]), op(a.m[8]), op(a.m[12]), op(a.m[1]), op(a.m[5]), op(a.m[9]), op(a.m[13]), op(a.m[2]), op(a.m[6]), op(a.m[10]), op(a.m[14]), op(a.m[3]), op(a.m[7]), op(a.m[11]), op(a.m[15]));
    default:
      return op(a);
  }
}
var FlowGraphAbsBlock = class _FlowGraphAbsBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicAbs(a), _FlowGraphAbsBlock.ClassName, config);
  }
  _polymorphicAbs(a) {
    return _componentWiseUnaryOperation(a, Math.abs);
  }
};
FlowGraphAbsBlock.ClassName = "FGAbsBlock";
RegisterClass(FlowGraphAbsBlock.ClassName, FlowGraphAbsBlock);
var FlowGraphSignBlock = class _FlowGraphSignBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSign(a), _FlowGraphSignBlock.ClassName, config);
  }
  _polymorphicSign(a) {
    return _componentWiseUnaryOperation(a, Math.sign);
  }
};
FlowGraphSignBlock.ClassName = "FGSignBlock";
RegisterClass(FlowGraphSignBlock.ClassName, FlowGraphSignBlock);
var FlowGraphTruncBlock = class _FlowGraphTruncBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicTrunc(a), _FlowGraphTruncBlock.ClassName, config);
  }
  _polymorphicTrunc(a) {
    return _componentWiseUnaryOperation(a, Math.trunc);
  }
};
FlowGraphTruncBlock.ClassName = "FGTruncBlock";
RegisterClass(FlowGraphTruncBlock.ClassName, FlowGraphTruncBlock);
var FlowGraphFloorBlock = class _FlowGraphFloorBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicFloor(a), _FlowGraphFloorBlock.ClassName, config);
  }
  _polymorphicFloor(a) {
    return _componentWiseUnaryOperation(a, Math.floor);
  }
};
FlowGraphFloorBlock.ClassName = "FGFloorBlock";
RegisterClass(FlowGraphFloorBlock.ClassName, FlowGraphFloorBlock);
var FlowGraphCeilBlock = class _FlowGraphCeilBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicCeiling(a), _FlowGraphCeilBlock.ClassName, config);
  }
  _polymorphicCeiling(a) {
    return _componentWiseUnaryOperation(a, Math.ceil);
  }
};
FlowGraphCeilBlock.ClassName = "FGCeilBlock";
RegisterClass(FlowGraphCeilBlock.ClassName, FlowGraphCeilBlock);
var FlowGraphFractBlock = class _FlowGraphFractBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicFract(a), _FlowGraphFractBlock.ClassName, config);
  }
  _polymorphicFract(a) {
    return _componentWiseUnaryOperation(a, (a2) => a2 - Math.floor(a2));
  }
};
FlowGraphFractBlock.ClassName = "FGFractBlock";
RegisterClass(FlowGraphFractBlock.ClassName, FlowGraphFractBlock);
var FlowGraphNegBlock = class _FlowGraphNegBlock extends FlowGraphUnaryOperationBlock {
  /**
   * construct a new negation block.
   * @param config optional configuration
   */
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNeg(a), _FlowGraphNegBlock.ClassName, config);
  }
  _polymorphicNeg(a) {
    return _componentWiseUnaryOperation(a, (a2) => -a2);
  }
};
FlowGraphNegBlock.ClassName = "FGNegBlock";
RegisterClass(FlowGraphNegBlock.ClassName, FlowGraphNegBlock);
function _componentWiseBinaryOperation(a, b, op) {
  const aClassName = _getClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      return new FlowGraphInteger(op(a.value, b.value));
    case "Vector2":
      return new Vector2(op(a.x, b.x), op(a.y, b.y));
    case "Vector3":
      return new Vector3(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));
    case "Vector4":
      return new Vector4(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));
    case "Matrix":
      return Matrix.FromValues(op(a.m[0], b.m[0]), op(a.m[4], b.m[4]), op(a.m[8], b.m[8]), op(a.m[12], b.m[12]), op(a.m[1], b.m[1]), op(a.m[5], b.m[5]), op(a.m[9], b.m[9]), op(a.m[13], b.m[13]), op(a.m[2], b.m[2]), op(a.m[6], b.m[6]), op(a.m[10], b.m[10]), op(a.m[14], b.m[14]), op(a.m[3], b.m[3]), op(a.m[7], b.m[7]), op(a.m[11], b.m[11]), op(a.m[15], b.m[15]));
    default:
      return op(a, b);
  }
}
var FlowGraphRemainderBlock = class _FlowGraphRemainderBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicRemainder(a, b), _FlowGraphRemainderBlock.ClassName, config);
  }
  _polymorphicRemainder(a, b) {
    return _componentWiseBinaryOperation(a, b, (a2, b2) => a2 % b2);
  }
};
FlowGraphRemainderBlock.ClassName = "FGRemainderBlock";
RegisterClass(FlowGraphRemainderBlock.ClassName, FlowGraphRemainderBlock);
var FlowGraphMinBlock = class _FlowGraphMinBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMin(a, b), _FlowGraphMinBlock.ClassName, config);
  }
  _polymorphicMin(a, b) {
    return _componentWiseBinaryOperation(a, b, Math.min);
  }
};
FlowGraphMinBlock.ClassName = "FGMinBlock";
RegisterClass(FlowGraphMinBlock.ClassName, FlowGraphMinBlock);
var FlowGraphMaxBlock = class _FlowGraphMaxBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicMax(a, b), _FlowGraphMaxBlock.ClassName, config);
  }
  _polymorphicMax(a, b) {
    return _componentWiseBinaryOperation(a, b, Math.max);
  }
};
FlowGraphMaxBlock.ClassName = "FGMaxBlock";
RegisterClass(FlowGraphMaxBlock.ClassName, FlowGraphMaxBlock);
function _clamp(a, b, c) {
  return Math.min(Math.max(a, Math.min(b, c)), Math.max(b, c));
}
function _componentWiseTernaryOperation(a, b, c, op) {
  const aClassName = _getClassNameOf(a);
  switch (aClassName) {
    case "FlowGraphInteger":
      return new FlowGraphInteger(op(a.value, b.value, c.value));
    case "Vector2":
      return new Vector2(op(a.x, b.x, c.x), op(a.y, b.y, c.y));
    case "Vector3":
      return new Vector3(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z));
    case "Vector4":
      return new Vector4(op(a.x, b.x, c.x), op(a.y, b.y, c.y), op(a.z, b.z, c.z), op(a.w, b.w, c.w));
    case "Matrix":
      return Matrix.FromValues(op(a.m[0], b.m[0], c.m[0]), op(a.m[4], b.m[4], c.m[4]), op(a.m[8], b.m[8], c.m[8]), op(a.m[12], b.m[12], c.m[12]), op(a.m[1], b.m[1], c.m[1]), op(a.m[5], b.m[5], c.m[5]), op(a.m[9], b.m[9], c.m[9]), op(a.m[13], b.m[13], c.m[13]), op(a.m[2], b.m[2], c.m[2]), op(a.m[6], b.m[6], c.m[6]), op(a.m[10], b.m[10], c.m[10]), op(a.m[14], b.m[14], c.m[14]), op(a.m[3], b.m[3], c.m[3]), op(a.m[7], b.m[7], c.m[7]), op(a.m[11], b.m[11], c.m[11]), op(a.m[15], b.m[15], c.m[15]));
    default:
      return op(a, b, c);
  }
}
var FlowGraphClampBlock = class _FlowGraphClampBlock extends FlowGraphTernaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicClamp(a, b, c), _FlowGraphClampBlock.ClassName, config);
  }
  _polymorphicClamp(a, b, c) {
    return _componentWiseTernaryOperation(a, b, c, _clamp);
  }
};
FlowGraphClampBlock.ClassName = "FGClampBlock";
RegisterClass(FlowGraphClampBlock.ClassName, FlowGraphClampBlock);
function _saturate(a) {
  return Math.min(Math.max(a, 0), 1);
}
var FlowGraphSaturateBlock = class _FlowGraphSaturateBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSaturate(a), _FlowGraphSaturateBlock.ClassName, config);
  }
  _polymorphicSaturate(a) {
    return _componentWiseUnaryOperation(a, _saturate);
  }
};
FlowGraphSaturateBlock.ClassName = "FGSaturateBlock";
RegisterClass(FlowGraphSaturateBlock.ClassName, FlowGraphSaturateBlock);
var FlowGraphInterpolateBlock = class _FlowGraphInterpolateBlock extends FlowGraphTernaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, RichTypeAny, (a, b, c) => this._polymorphicInterpolate(a, b, c), _FlowGraphInterpolateBlock.ClassName, config);
  }
  _interpolate(a, b, c) {
    return (1 - c) * a + c * b;
  }
  _polymorphicInterpolate(a, b, c) {
    return _componentWiseTernaryOperation(a, b, c, this._interpolate);
  }
};
FlowGraphInterpolateBlock.ClassName = "FGInterpolateBlock";
RegisterClass(FlowGraphInterpolateBlock.ClassName, FlowGraphInterpolateBlock);
var FlowGraphEqBlock = class _FlowGraphEqBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicEq(a, b), _FlowGraphEqBlock.ClassName, config);
  }
  _polymorphicEq(a, b) {
    const aClassName = _getClassNameOf(a);
    const bClassName = _getClassNameOf(b);
    if (_areSameVectorClass(aClassName, bClassName) || _areSameMatrixClass(aClassName, bClassName) || _areSameIntegerClass(aClassName, bClassName)) {
      return a.equals(b);
    } else {
      return a === b;
    }
  }
};
FlowGraphEqBlock.ClassName = "FGEqBlock";
RegisterClass(FlowGraphEqBlock.ClassName, FlowGraphEqBlock);
function _comparisonOperators(a, b, op) {
  const aClassName = _getClassNameOf(a);
  const bClassName = _getClassNameOf(b);
  if (aClassName === bClassName) {
    if (aClassName === "") {
      return op(a, b);
    } else if (aClassName === "FlowGraphInteger") {
      return op(a.value, b.value);
    } else {
      throw new Error(`Cannot compare ${a} and ${b}`);
    }
  }
  throw new Error(`${a} and ${b} are of different types.`);
}
var FlowGraphLessThanBlock = class _FlowGraphLessThanBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThan(a, b), _FlowGraphLessThanBlock.ClassName, config);
  }
  _polymorphicLessThan(a, b) {
    return _comparisonOperators(a, b, (a2, b2) => a2 < b2);
  }
};
FlowGraphLessThanBlock.ClassName = "FGLessThanBlock";
RegisterClass(FlowGraphLessThanBlock.ClassName, FlowGraphLessThanBlock);
var FlowGraphLessThanOrEqualBlock = class _FlowGraphLessThanOrEqualBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicLessThanOrEqual(a, b), _FlowGraphLessThanOrEqualBlock.ClassName, config);
  }
  _polymorphicLessThanOrEqual(a, b) {
    return _comparisonOperators(a, b, (a2, b2) => a2 <= b2);
  }
};
FlowGraphLessThanOrEqualBlock.ClassName = "FGLessThanOrEqualBlock";
var FlowGraphGreaterThanBlock = class _FlowGraphGreaterThanBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThan(a, b), _FlowGraphGreaterThanBlock.ClassName, config);
  }
  _polymorphicGreaterThan(a, b) {
    return _comparisonOperators(a, b, (a2, b2) => a2 > b2);
  }
};
FlowGraphGreaterThanBlock.ClassName = "FGGreaterThanBlock";
RegisterClass(FlowGraphGreaterThanBlock.ClassName, FlowGraphGreaterThanBlock);
var FlowGraphGreaterThanOrEqualBlock = class _FlowGraphGreaterThanOrEqualBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeBoolean, (a, b) => this._polymorphicGreaterThanOrEqual(a, b), _FlowGraphGreaterThanOrEqualBlock.ClassName, config);
  }
  _polymorphicGreaterThanOrEqual(a, b) {
    return _comparisonOperators(a, b, (a2, b2) => a2 >= b2);
  }
};
FlowGraphGreaterThanOrEqualBlock.ClassName = "FGGreaterThanOrEqualBlock";
RegisterClass(FlowGraphGreaterThanOrEqualBlock.ClassName, FlowGraphGreaterThanOrEqualBlock);
var FlowGraphIsNanBlock = class _FlowGraphIsNanBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeBoolean, (a) => this._polymorphicIsNan(a), _FlowGraphIsNanBlock.ClassName, config);
  }
  _polymorphicIsNan(a) {
    const aClassName = _getClassNameOf(a);
    if (aClassName === "") {
      return isNaN(a);
    } else if (aClassName === "FlowGraphInteger") {
      return isNaN(a.value);
    } else {
      throw new Error(`Cannot get NaN of ${a}`);
    }
  }
};
FlowGraphIsNanBlock.ClassName = "FGIsNanBlock";
RegisterClass(FlowGraphIsNanBlock.ClassName, FlowGraphIsNanBlock);
var FlowGraphIsInfBlock = class _FlowGraphIsInfBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeBoolean, (a) => this._polymorphicIsInf(a), _FlowGraphIsInfBlock.ClassName, config);
  }
  _polymorphicIsInf(a) {
    const aClassName = _getClassNameOf(a);
    if (aClassName === "") {
      return !isFinite(a);
    } else if (aClassName === "FlowGraphInteger") {
      return !isFinite(a.value);
    } else {
      throw new Error(`Cannot get isInf of ${a}`);
    }
  }
};
FlowGraphIsInfBlock.ClassName = "FGIsInfBlock";
var FlowGraphDegToRadBlock = class _FlowGraphDegToRadBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicDegToRad(a), _FlowGraphDegToRadBlock.ClassName, config);
  }
  _degToRad(a) {
    return a * Math.PI / 180;
  }
  _polymorphicDegToRad(a) {
    return _componentWiseUnaryOperation(a, this._degToRad);
  }
};
FlowGraphDegToRadBlock.ClassName = "FGDegToRadBlock";
RegisterClass(FlowGraphDegToRadBlock.ClassName, FlowGraphDegToRadBlock);
var FlowGraphRadToDegBlock = class _FlowGraphRadToDegBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicRadToDeg(a), _FlowGraphRadToDegBlock.ClassName, config);
  }
  _radToDeg(a) {
    return a * 180 / Math.PI;
  }
  _polymorphicRadToDeg(a) {
    return _componentWiseUnaryOperation(a, this._radToDeg);
  }
};
FlowGraphRadToDegBlock.ClassName = "FGRadToDegBlock";
RegisterClass(FlowGraphRadToDegBlock.ClassName, FlowGraphRadToDegBlock);
var FlowGraphSinBlock = class _FlowGraphSinBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSin(a), _FlowGraphSinBlock.ClassName, config);
  }
  _polymorphicSin(a) {
    return _componentWiseUnaryOperation(a, Math.sin);
  }
};
FlowGraphSinBlock.ClassName = "FGSinBlock";
RegisterClass(FlowGraphSinBlock.ClassName, FlowGraphSinBlock);
var FlowGraphCosBlock = class _FlowGraphCosBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicCos(a), _FlowGraphCosBlock.ClassName, config);
  }
  _polymorphicCos(a) {
    return _componentWiseUnaryOperation(a, Math.cos);
  }
};
FlowGraphCosBlock.ClassName = "FGCosBlock";
RegisterClass(FlowGraphCosBlock.ClassName, FlowGraphCosBlock);
var FlowGraphTanBlock = class _FlowGraphTanBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicTan(a), _FlowGraphTanBlock.ClassName, config);
  }
  _polymorphicTan(a) {
    return _componentWiseUnaryOperation(a, Math.tan);
  }
};
FlowGraphTanBlock.ClassName = "FGTanBlock";
RegisterClass(FlowGraphTanBlock.ClassName, FlowGraphTanBlock);
var FlowGraphAsinBlock = class _FlowGraphAsinBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicAsin(a), _FlowGraphAsinBlock.ClassName, config);
  }
  _polymorphicAsin(a) {
    return _componentWiseUnaryOperation(a, Math.asin);
  }
};
FlowGraphAsinBlock.ClassName = "FGAsinBlock";
RegisterClass(FlowGraphAsinBlock.ClassName, FlowGraphAsinBlock);
var FlowGraphAcosBlock = class _FlowGraphAcosBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicAcos(a), _FlowGraphAcosBlock.ClassName, config);
  }
  _polymorphicAcos(a) {
    return _componentWiseUnaryOperation(a, Math.acos);
  }
};
FlowGraphAcosBlock.ClassName = "FGAcosBlock";
RegisterClass(FlowGraphAcosBlock.ClassName, FlowGraphAcosBlock);
var FlowGraphAtanBlock = class _FlowGraphAtanBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicAtan(a), _FlowGraphAtanBlock.ClassName, config);
  }
  _polymorphicAtan(a) {
    return _componentWiseUnaryOperation(a, Math.atan);
  }
};
FlowGraphAtanBlock.ClassName = "FGAtanBlock";
RegisterClass(FlowGraphAtanBlock.ClassName, FlowGraphAtanBlock);
var FlowGraphAtan2Block = class _FlowGraphAtan2Block extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeAny, (a, b) => this._polymorphicAtan2(a, b), _FlowGraphAtan2Block.ClassName, config);
  }
  _polymorphicAtan2(a, b) {
    return _componentWiseBinaryOperation(a, b, Math.atan2);
  }
};
FlowGraphAtan2Block.ClassName = "FGAtan2Block";
RegisterClass(FlowGraphAtan2Block.ClassName, FlowGraphAtan2Block);
var FlowGraphSinhBlock = class _FlowGraphSinhBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicSinh(a), _FlowGraphSinhBlock.ClassName, config);
  }
  _polymorphicSinh(a) {
    return _componentWiseUnaryOperation(a, Math.sinh);
  }
};
FlowGraphSinhBlock.ClassName = "FGSinhBlock";
RegisterClass(FlowGraphSinhBlock.ClassName, FlowGraphSinhBlock);
var FlowGraphCoshBlock = class _FlowGraphCoshBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicCosh(a), _FlowGraphCoshBlock.ClassName, config);
  }
  _polymorphicCosh(a) {
    return _componentWiseUnaryOperation(a, Math.cosh);
  }
};
FlowGraphCoshBlock.ClassName = "FGCoshBlock";
RegisterClass(FlowGraphCoshBlock.ClassName, FlowGraphCoshBlock);
var FlowGraphTanhBlock = class _FlowGraphTanhBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicTanh(a), _FlowGraphTanhBlock.ClassName, config);
  }
  _polymorphicTanh(a) {
    return _componentWiseUnaryOperation(a, Math.tanh);
  }
};
FlowGraphTanhBlock.ClassName = "FGTanhBlock";
RegisterClass(FlowGraphTanhBlock.ClassName, FlowGraphTanhBlock);
var FlowGraphAsinhBlock = class _FlowGraphAsinhBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAsinh(a), _FlowGraphAsinhBlock.ClassName, config);
  }
  _polymorphicAsinh(a) {
    return _componentWiseUnaryOperation(a, Math.asinh);
  }
};
FlowGraphAsinhBlock.ClassName = "FGAsinhBlock";
RegisterClass(FlowGraphAsinhBlock.ClassName, FlowGraphAsinhBlock);
var FlowGraphAcoshBlock = class _FlowGraphAcoshBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAcosh(a), _FlowGraphAcoshBlock.ClassName, config);
  }
  _polymorphicAcosh(a) {
    return _componentWiseUnaryOperation(a, Math.acosh);
  }
};
FlowGraphAcoshBlock.ClassName = "FGAcoshBlock";
RegisterClass(FlowGraphAcoshBlock.ClassName, FlowGraphAcoshBlock);
var FlowGraphAtanhBlock = class _FlowGraphAtanhBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicAtanh(a), _FlowGraphAtanhBlock.ClassName, config);
  }
  _polymorphicAtanh(a) {
    return _componentWiseUnaryOperation(a, Math.atanh);
  }
};
FlowGraphAtanhBlock.ClassName = "FGAtanhBlock";
RegisterClass(FlowGraphAtanhBlock.ClassName, FlowGraphAtanhBlock);
var FlowGraphExpBlock = class _FlowGraphExpBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicExp(a), _FlowGraphExpBlock.ClassName, config);
  }
  _polymorphicExp(a) {
    return _componentWiseUnaryOperation(a, Math.exp);
  }
};
FlowGraphExpBlock.ClassName = "FGExpBlock";
RegisterClass(FlowGraphExpBlock.ClassName, FlowGraphExpBlock);
var FlowGraphLogBlock = class _FlowGraphLogBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog(a), _FlowGraphLogBlock.ClassName, config);
  }
  _polymorphicLog(a) {
    return _componentWiseUnaryOperation(a, Math.log);
  }
};
FlowGraphLogBlock.ClassName = "FGLogBlock";
RegisterClass(FlowGraphLogBlock.ClassName, FlowGraphLogBlock);
var FlowGraphLog2Block = class _FlowGraphLog2Block extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog2(a), _FlowGraphLog2Block.ClassName, config);
  }
  _polymorphicLog2(a) {
    return _componentWiseUnaryOperation(a, Math.log2);
  }
};
FlowGraphLog2Block.ClassName = "FGLog2Block";
RegisterClass(FlowGraphLog2Block.ClassName, FlowGraphLog2Block);
var FlowGraphLog10Block = class _FlowGraphLog10Block extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLog10(a), _FlowGraphLog10Block.ClassName, config);
  }
  _polymorphicLog10(a) {
    return _componentWiseUnaryOperation(a, Math.log10);
  }
};
FlowGraphLog10Block.ClassName = "FGLog10Block";
RegisterClass(FlowGraphLog10Block.ClassName, FlowGraphLog10Block);
var FlowGraphSqrtBlock = class _FlowGraphSqrtBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicSqrt(a), _FlowGraphSqrtBlock.ClassName, config);
  }
  _polymorphicSqrt(a) {
    return _componentWiseUnaryOperation(a, Math.sqrt);
  }
};
FlowGraphSqrtBlock.ClassName = "FGSqrtBlock";
RegisterClass(FlowGraphSqrtBlock.ClassName, FlowGraphSqrtBlock);
var FlowGraphCubeRootBlock = class _FlowGraphCubeRootBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicCubeRoot(a), _FlowGraphCubeRootBlock.ClassName, config);
  }
  _polymorphicCubeRoot(a) {
    return _componentWiseUnaryOperation(a, Math.cbrt);
  }
};
FlowGraphCubeRootBlock.ClassName = "FGCubeRootBlock";
RegisterClass(FlowGraphCubeRootBlock.ClassName, FlowGraphCubeRootBlock);
var FlowGraphPowBlock = class _FlowGraphPowBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, RichTypeNumber, (a, b) => this._polymorphicPow(a, b), _FlowGraphPowBlock.ClassName, config);
  }
  _polymorphicPow(a, b) {
    return _componentWiseBinaryOperation(a, b, Math.pow);
  }
};
FlowGraphPowBlock.ClassName = "FGPowBlock";
RegisterClass(FlowGraphPowBlock.ClassName, FlowGraphPowBlock);
var FlowGraphLengthBlock = class _FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), _FlowGraphLengthBlock.ClassName, config);
  }
  _polymorphicLength(a) {
    const aClassName = _getClassNameOf(a);
    switch (aClassName) {
      case "Vector2":
      case "Vector3":
      case "Vector4":
        return a.length();
      default:
        throw new Error(`Cannot compute length of value ${a}`);
    }
  }
};
FlowGraphLengthBlock.ClassName = "FGLengthBlock";
RegisterClass(FlowGraphLengthBlock.ClassName, FlowGraphLengthBlock);
var FlowGraphNormalizeBlock = class _FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), _FlowGraphNormalizeBlock.ClassName, config);
  }
  _polymorphicNormalize(a) {
    const aClassName = _getClassNameOf(a);
    switch (aClassName) {
      case "Vector2":
      case "Vector3":
      case "Vector4":
        return a.normalize();
      default:
        throw new Error(`Cannot normalize value ${a}`);
    }
  }
};
FlowGraphNormalizeBlock.ClassName = "FGNormalizeBlock";
RegisterClass(FlowGraphNormalizeBlock.ClassName, FlowGraphNormalizeBlock);
var FlowGraphCrossBlock = class _FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), _FlowGraphCrossBlock.ClassName, config);
  }
};
FlowGraphCrossBlock.ClassName = "FGCrossBlock";
RegisterClass(FlowGraphCrossBlock.ClassName, FlowGraphCrossBlock);
var FlowGraphRotate2DBlock = class _FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => Vector2.Transform(a, Matrix.RotationZ(b)), _FlowGraphRotate2DBlock.ClassName, config);
  }
};
FlowGraphRotate2DBlock.ClassName = "FGRotate2DBlock";
RegisterClass(FlowGraphRotate2DBlock.ClassName, FlowGraphRotate2DBlock);
var FlowGraphRotate3DBlock = class _FlowGraphRotate3DBlock extends FlowGraphTernaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeVector3, RichTypeNumber, RichTypeVector3, (a, b, c) => Vector3.TransformCoordinates(a, Matrix.RotationAxis(b, c)), _FlowGraphRotate3DBlock.ClassName, config);
  }
};
FlowGraphRotate3DBlock.ClassName = "FGRotate3DBlock";
RegisterClass(FlowGraphRotate3DBlock.ClassName, FlowGraphRotate3DBlock);
var FlowGraphTransposeBlock = class _FlowGraphTransposeBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeMatrix, RichTypeMatrix, (a) => Matrix.Transpose(a), _FlowGraphTransposeBlock.ClassName, config);
  }
};
FlowGraphTransposeBlock.ClassName = "FGTransposeBlock";
RegisterClass(FlowGraphTransposeBlock.ClassName, FlowGraphTransposeBlock);
var FlowGraphDeterminantBlock = class _FlowGraphDeterminantBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeMatrix, RichTypeNumber, (a) => a.determinant(), _FlowGraphDeterminantBlock.ClassName, config);
  }
};
FlowGraphDeterminantBlock.ClassName = "FGDeterminantBlock";
RegisterClass(FlowGraphDeterminantBlock.ClassName, FlowGraphDeterminantBlock);
var FlowGraphInvertMatrixBlock = class _FlowGraphInvertMatrixBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeMatrix, RichTypeMatrix, (a) => Matrix.Invert(a), _FlowGraphInvertMatrixBlock.ClassName, config);
  }
};
FlowGraphInvertMatrixBlock.ClassName = "FGInvertMatrixBlock";
RegisterClass(FlowGraphInvertMatrixBlock.ClassName, FlowGraphInvertMatrixBlock);
var FlowGraphMatMulBlock = class _FlowGraphMatMulBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeMatrix, RichTypeMatrix, RichTypeMatrix, (a, b) => b.multiply(a), _FlowGraphMatMulBlock.ClassName, config);
  }
};
FlowGraphMatMulBlock.ClassName = "FGMatMulBlock";
RegisterClass(FlowGraphMatMulBlock.ClassName, FlowGraphMatMulBlock);
var FlowGraphBitwiseNotBlock = class _FlowGraphBitwiseNotBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(~a.value), _FlowGraphBitwiseNotBlock.ClassName, config);
  }
};
FlowGraphBitwiseNotBlock.ClassName = "FGBitwiseNotBlock";
RegisterClass(FlowGraphBitwiseNotBlock.ClassName, FlowGraphBitwiseNotBlock);
var FlowGraphBitwiseAndBlock = class _FlowGraphBitwiseAndBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value & b.value), _FlowGraphBitwiseAndBlock.ClassName, config);
  }
};
FlowGraphBitwiseAndBlock.ClassName = "FGBitwiseAndBlock";
RegisterClass(FlowGraphBitwiseAndBlock.ClassName, FlowGraphBitwiseAndBlock);
var FlowGraphBitwiseOrBlock = class _FlowGraphBitwiseOrBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value | b.value), _FlowGraphBitwiseOrBlock.ClassName, config);
  }
};
FlowGraphBitwiseOrBlock.ClassName = "FGBitwiseOrBlock";
RegisterClass(FlowGraphBitwiseOrBlock.ClassName, FlowGraphBitwiseOrBlock);
var FlowGraphBitwiseXorBlock = class _FlowGraphBitwiseXorBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value ^ b.value), _FlowGraphBitwiseXorBlock.ClassName, config);
  }
};
FlowGraphBitwiseXorBlock.ClassName = "FGBitwiseXorBlock";
RegisterClass(FlowGraphBitwiseXorBlock.ClassName, FlowGraphBitwiseXorBlock);
var FlowGraphBitwiseLeftShiftBlock = class _FlowGraphBitwiseLeftShiftBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value << b.value), _FlowGraphBitwiseLeftShiftBlock.ClassName, config);
  }
};
FlowGraphBitwiseLeftShiftBlock.ClassName = "FGBitwiseLeftShiftBlock";
RegisterClass(FlowGraphBitwiseLeftShiftBlock.ClassName, FlowGraphBitwiseLeftShiftBlock);
var FlowGraphBitwiseRightShiftBlock = class _FlowGraphBitwiseRightShiftBlock extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a, b) => new FlowGraphInteger(a.value >> b.value), _FlowGraphBitwiseRightShiftBlock.ClassName, config);
  }
};
FlowGraphBitwiseRightShiftBlock.ClassName = "FGBitwiseRightShiftBlock";
RegisterClass(FlowGraphBitwiseRightShiftBlock.ClassName, FlowGraphBitwiseRightShiftBlock);
var FlowGraphCountLeadingZerosBlock = class _FlowGraphCountLeadingZerosBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(Math.clz32(a.value)), _FlowGraphCountLeadingZerosBlock.ClassName, config);
  }
};
FlowGraphCountLeadingZerosBlock.ClassName = "FGCountLeadingZerosBlock";
RegisterClass(FlowGraphCountLeadingZerosBlock.ClassName, FlowGraphCountLeadingZerosBlock);
var FlowGraphCountTrailingZerosBlock = class _FlowGraphCountTrailingZerosBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(a.value ? 31 - Math.clz32(a.value & -a.value) : 32), _FlowGraphCountTrailingZerosBlock.ClassName, config);
  }
};
FlowGraphCountTrailingZerosBlock.ClassName = "FGCountTrailingZerosBlock";
RegisterClass(FlowGraphCountTrailingZerosBlock.ClassName, FlowGraphCountTrailingZerosBlock);
function _countOnes(n) {
  let result = 0;
  while (n) {
    result += n & 1;
    n >>= 1;
  }
  return result;
}
var FlowGraphCountOneBitsBlock = class _FlowGraphCountOneBitsBlock extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeFlowGraphInteger, RichTypeFlowGraphInteger, (a) => new FlowGraphInteger(_countOnes(a.value)), _FlowGraphCountOneBitsBlock.ClassName, config);
  }
};
FlowGraphCountOneBitsBlock.ClassName = "FGCountOneBitsBlock";
RegisterClass(FlowGraphCountOneBitsBlock.ClassName, FlowGraphCountOneBitsBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Event/flowGraphSceneReadyEventBlock.js
var FlowGraphSceneReadyEventBlock = class _FlowGraphSceneReadyEventBlock extends FlowGraphEventBlock {
  /**
   * @internal
   */
  _preparePendingTasks(context) {
    if (!context._getExecutionVariable(this, "sceneReadyObserver")) {
      const scene = context.configuration.scene;
      const contextObserver = scene.onReadyObservable.add(() => {
        this._execute(context);
      });
      context._setExecutionVariable(this, "sceneReadyObserver", contextObserver);
    }
  }
  /**
   * @internal
   */
  _cancelPendingTasks(context) {
    const contextObserver = context._getExecutionVariable(this, "sceneReadyObserver");
    const scene = context.configuration.scene;
    scene.onReadyObservable.remove(contextObserver);
    context._deleteExecutionVariable(this, "sceneReadyObserver");
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSceneReadyEventBlock.ClassName;
  }
};
FlowGraphSceneReadyEventBlock.ClassName = "FGSceneReadyEventBlock";
RegisterClass("FGSceneReadyEventBlock", FlowGraphSceneReadyEventBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.js
var FlowGraphReceiveCustomEventBlock = class _FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {
  constructor(config) {
    super(config);
    this.config = config;
    for (let i = 0; i < this.config.eventData.length; i++) {
      const dataName = this.config.eventData[i];
      this.registerDataOutput(dataName, RichTypeAny);
    }
  }
  _preparePendingTasks(context) {
    const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);
    this._eventObserver = observable.add((eventDatas) => {
      for (let i = 0; i < eventDatas.length; i++) {
        this.dataOutputs[i].setValue(eventDatas[i], context);
      }
      this._execute(context);
    });
  }
  _cancelPendingTasks(context) {
    const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);
    if (observable) {
      observable.remove(this._eventObserver);
    } else {
      Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);
    }
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphReceiveCustomEventBlock.ClassName;
  }
  /**
   * Serializes this block
   * @param serializationObject the object to serialize to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.eventId = this.config.eventId;
    serializationObject.eventData = this.config.eventData;
  }
};
FlowGraphReceiveCustomEventBlock.ClassName = "FGReceiveCustomEventBlock";
RegisterClass(FlowGraphReceiveCustomEventBlock.ClassName, FlowGraphReceiveCustomEventBlock);

// node_modules/@babylonjs/core/FlowGraph/Blocks/Event/flowGraphSceneTickEventBlock.js
var FlowGraphSceneTickEventBlock = class _FlowGraphSceneTickEventBlock extends FlowGraphEventBlock {
  /**
   * @internal
   */
  _preparePendingTasks(context) {
    if (!context._getExecutionVariable(this, "sceneBeforeRender")) {
      const scene = context.configuration.scene;
      const contextObserver = scene.onBeforeRenderObservable.add(() => {
        this._execute(context);
      });
      context._setExecutionVariable(this, "sceneBeforeRender", contextObserver);
    }
  }
  /**
   * @internal
   */
  _cancelPendingTasks(context) {
    const contextObserver = context._getExecutionVariable(this, "sceneBeforeRender");
    const scene = context.configuration.scene;
    scene.onBeforeRenderObservable.remove(contextObserver);
    context._deleteExecutionVariable(this, "sceneBeforeRender");
  }
  /**
   * @returns class name of the block.
   */
  getClassName() {
    return _FlowGraphSceneTickEventBlock.ClassName;
  }
};
FlowGraphSceneTickEventBlock.ClassName = "FGSceneTickEventBlock";
RegisterClass(FlowGraphSceneTickEventBlock.ClassName, FlowGraphSceneTickEventBlock);

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
  if (!this.getScene().getEngine().getCaps().instancedArrays) {
    Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
    return -1;
  }
  this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
  const index = this._thinInstanceDataStorage.instancesCount;
  if (Array.isArray(matrix)) {
    for (let i = 0; i < matrix.length; ++i) {
      this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
    }
  } else {
    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
  }
  return index;
};
Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
  return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
};
Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  this.removeVerticesData(kind);
  this._thinInstanceInitializeUserStorage();
  this._userThinInstanceBuffersStorage.strides[kind] = stride;
  this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
  this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
  this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
  this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
};
Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
  if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  matrix.copyToArray(matrixData, index * 16);
  if (this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices[index] = matrix;
  }
  if (refresh) {
    this.thinInstanceBufferUpdated("matrix");
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  }
  return true;
};
Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
    return false;
  }
  this._thinInstanceUpdateBufferSize(kind, 0);
  this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
  if (refresh) {
    this.thinInstanceBufferUpdated(kind);
  }
  return true;
};
Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
  get: function() {
    return this._thinInstanceDataStorage.instancesCount;
  },
  set: function(value) {
    var _a;
    const matrixData = this._thinInstanceDataStorage.matrixData ?? ((_a = this.source) == null ? void 0 : _a._thinInstanceDataStorage.matrixData);
    const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
    if (value <= numMaxInstances) {
      this._thinInstanceDataStorage.instancesCount = value;
    }
  },
  enumerable: true,
  configurable: true
});
Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = true) {
  const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
  for (let i = 0; i < 4; i++) {
    this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
  }
  return matrixBuffer;
};
Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = true) {
  var _a, _b, _c;
  stride = stride || 16;
  if (kind === "matrix") {
    (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
    this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
    this._thinInstanceDataStorage.matrixData = buffer;
    this._thinInstanceDataStorage.worldMatrices = null;
    if (buffer !== null) {
      this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
      if (!this.doNotSyncBoundingInfo) {
        this.thinInstanceRefreshBoundingInfo(false);
      }
    } else {
      this._thinInstanceDataStorage.instancesCount = 0;
      if (!this.doNotSyncBoundingInfo) {
        this.refreshBoundingInfo();
      }
    }
  } else if (kind === "previousMatrix") {
    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
    this._thinInstanceDataStorage.previousMatrixBuffer = null;
    this._thinInstanceDataStorage.previousMatrixData = buffer;
    if (buffer !== null) {
      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if (buffer === null) {
      if ((_c = this._userThinInstanceBuffersStorage) == null ? void 0 : _c.data[kind]) {
        this.removeVerticesData(kind);
        delete this._userThinInstanceBuffersStorage.data[kind];
        delete this._userThinInstanceBuffersStorage.strides[kind];
        delete this._userThinInstanceBuffersStorage.sizes[kind];
        delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
      }
    } else {
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.data[kind] = buffer;
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
  var _a, _b, _c;
  if (kind === "matrix") {
    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {
      this._thinInstanceRecreateBuffer(kind);
    }
    (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else if (kind === "previousMatrix") {
    if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {
      this._thinInstanceRecreateBuffer(kind);
    }
    (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if ((_c = this._userThinInstanceBuffersStorage) == null ? void 0 : _c.vertexBuffers[kind]) {
      if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {
        this._thinInstanceRecreateBuffer(kind);
      }
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
    }
  }
};
Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
  var _a;
  if (kind === "matrix") {
    if (this._thinInstanceDataStorage.matrixBuffer) {
      this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    if ((_a = this._userThinInstanceBuffersStorage) == null ? void 0 : _a.vertexBuffers[kind]) {
      this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
    }
  }
};
Mesh.prototype.thinInstanceGetWorldMatrices = function() {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return [];
  }
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (!this._thinInstanceDataStorage.worldMatrices) {
    this._thinInstanceDataStorage.worldMatrices = [];
    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
      this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
    }
  }
  return this._thinInstanceDataStorage.worldMatrices;
};
Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
  if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
    return;
  }
  const vectors = this._thinInstanceDataStorage.boundingVectors;
  if (forceRefreshParentInfo || !this.rawBoundingInfo) {
    vectors.length = 0;
    this.refreshBoundingInfo(applySkeleton, applyMorph);
    const boundingInfo2 = this.getBoundingInfo();
    this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
  }
  const boundingInfo = this.getBoundingInfo();
  const matrixData = this._thinInstanceDataStorage.matrixData;
  if (vectors.length === 0) {
    for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
      vectors.push(boundingInfo.boundingBox.vectors[v].clone());
    }
  }
  TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
  TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
  for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
    Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
    for (let v = 0; v < vectors.length; ++v) {
      Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
      TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
      TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
    }
  }
  boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
  this._updateBoundingInfo();
};
Mesh.prototype._thinInstanceRecreateBuffer = function(kind, staticBuffer = true) {
  var _a, _b, _c;
  if (kind === "matrix") {
    (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
    this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, staticBuffer);
  } else if (kind === "previousMatrix") {
    if (this._scene.needsPreviousWorldMatrices) {
      (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
      this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);
    }
  } else {
    if (kind === VertexBuffer.ColorKind) {
      kind = VertexBuffer.ColorInstanceKind;
    }
    (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) == null ? void 0 : _c.dispose();
    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);
    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
  }
};
Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
  var _a, _b, _c;
  if (kind === VertexBuffer.ColorKind) {
    kind = VertexBuffer.ColorInstanceKind;
  }
  const kindIsMatrix = kind === "matrix";
  if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
    return;
  }
  const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
  const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
  let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
  const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
  let newSize = currentSize;
  while (newSize < bufferSize) {
    newSize *= 2;
  }
  if (!data || currentSize != newSize) {
    if (!data) {
      data = new Float32Array(newSize);
    } else {
      const newData = new Float32Array(newSize);
      newData.set(data, 0);
      data = newData;
    }
    if (kindIsMatrix) {
      (_a = this._thinInstanceDataStorage.matrixBuffer) == null ? void 0 : _a.dispose();
      this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
      this._thinInstanceDataStorage.matrixData = data;
      this._thinInstanceDataStorage.matrixBufferSize = newSize;
      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) == null ? void 0 : _b.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
      }
    } else {
      (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) == null ? void 0 : _c.dispose();
      this._userThinInstanceBuffersStorage.data[kind] = data;
      this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    }
  }
};
Mesh.prototype._thinInstanceInitializeUserStorage = function() {
  if (!this._userThinInstanceBuffersStorage) {
    this._userThinInstanceBuffersStorage = {
      data: {},
      sizes: {},
      vertexBuffers: {},
      strides: {}
    };
  }
};
Mesh.prototype._disposeThinInstanceSpecificData = function() {
  var _a;
  if ((_a = this._thinInstanceDataStorage) == null ? void 0 : _a.matrixBuffer) {
    this._thinInstanceDataStorage.matrixBuffer.dispose();
    this._thinInstanceDataStorage.matrixBuffer = null;
  }
};

export {
  Bone,
  AnimationEvent,
  InstancedMesh,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  Sound,
  WeightedSound,
  RawTexture,
  Skeleton,
  BaseCameraMouseWheelInput,
  CameraInputTypes,
  CameraInputsManager,
  FreeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  FreeCameraMouseWheelInput,
  FreeCameraTouchInput,
  FreeCameraInputsManager,
  TargetCamera,
  FreeCamera,
  PassPostProcess,
  PassCubePostProcess,
  SphericalHarmonics,
  SphericalPolynomial,
  CubeMapToSphericalPolynomialTools,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  GetTextureDataAsync,
  TextureTools,
  DDSTools,
  RGBDTextureTools,
  GetEnvInfo,
  normalizeEnvInfo,
  CreateEnvTextureAsync,
  CreateImageDataArrayBufferViews,
  UploadEnvLevelsAsync,
  UploadLevelsAsync,
  UploadEnvSpherical,
  _UpdateRGBDAsync,
  EnvironmentTextureTools,
  ShadowLight,
  DirectionalLight,
  SpotLight,
  CubeTexture,
  GetEnvironmentBRDFTexture,
  BRDFTextureTools,
  PBRBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  PBRMaterial,
  WorkerPool,
  AutoReleaseWorkerPool,
  TimerState,
  setAndStartTimer,
  AdvancedTimer,
  PointLight,
  MorphTarget,
  RawTexture2DArray,
  MorphTargetManager,
  RawCubeTexture,
  GaussianSplattingMaterial,
  DracoCompression,
  MeshoptCompression,
  GaussianSplattingMesh,
  Deferred,
  DataReader,
  FlowGraphConnectionType,
  FlowGraphConnection,
  RichType,
  RichTypeAny,
  RichTypeString,
  RichTypeNumber,
  RichTypeBoolean,
  RichTypeVector2,
  RichTypeVector3,
  RichTypeVector4,
  RichTypeMatrix,
  RichTypeColor3,
  RichTypeColor4,
  RichTypeQuaternion,
  RichTypeFlowGraphInteger,
  getRichTypeFromValue,
  FlowGraphDataConnection,
  defaultValueSerializationFunction,
  FlowGraphBlock,
  FlowGraphSignalConnection,
  FlowGraphExecutionBlock,
  FlowGraphAsyncExecutionBlock,
  FlowGraphEventBlock,
  FlowGraphContext,
  FlowGraphMeshPickEventBlock,
  FlowGraphState,
  FlowGraph,
  FlowGraphCoordinator,
  FlowGraphExecutionBlockWithOutSignal,
  FlowGraphConsoleLogBlock,
  FlowGraphSetVariableBlock,
  FlowGraphPathConverterComponent,
  FlowGraphSetPropertyBlock,
  FlowGraphSendCustomEventBlock,
  FlowGraphDoNBlock,
  FlowGraphTimerBlock,
  FlowGraphWhileLoopBlock,
  FlowGraphSequenceBlock,
  FlowGraphGetVariableBlock,
  FlowGraphGetPropertyBlock,
  FlowGraphBinaryOperationBlock,
  FlowGraphUnaryOperationBlock,
  FlowGraphAddBlock,
  FlowGraphSubtractBlock,
  FlowGraphMultiplyBlock,
  FlowGraphDivideBlock,
  FlowGraphRandomBlock,
  FlowGraphDotBlock,
  FlowGraphEBlock,
  FlowGraphPiBlock,
  FlowGraphInfBlock,
  FlowGraphNaNBlock,
  FlowGraphAbsBlock,
  FlowGraphSignBlock,
  FlowGraphTruncBlock,
  FlowGraphFloorBlock,
  FlowGraphCeilBlock,
  FlowGraphFractBlock,
  FlowGraphNegBlock,
  FlowGraphRemainderBlock,
  FlowGraphMinBlock,
  FlowGraphMaxBlock,
  FlowGraphClampBlock,
  FlowGraphSaturateBlock,
  FlowGraphInterpolateBlock,
  FlowGraphEqBlock,
  FlowGraphLessThanBlock,
  FlowGraphLessThanOrEqualBlock,
  FlowGraphGreaterThanBlock,
  FlowGraphGreaterThanOrEqualBlock,
  FlowGraphIsNanBlock,
  FlowGraphIsInfBlock,
  FlowGraphDegToRadBlock,
  FlowGraphRadToDegBlock,
  FlowGraphSinBlock,
  FlowGraphCosBlock,
  FlowGraphTanBlock,
  FlowGraphAsinBlock,
  FlowGraphAcosBlock,
  FlowGraphAtanBlock,
  FlowGraphAtan2Block,
  FlowGraphSinhBlock,
  FlowGraphCoshBlock,
  FlowGraphTanhBlock,
  FlowGraphAsinhBlock,
  FlowGraphAcoshBlock,
  FlowGraphAtanhBlock,
  FlowGraphExpBlock,
  FlowGraphLogBlock,
  FlowGraphLog2Block,
  FlowGraphLog10Block,
  FlowGraphSqrtBlock,
  FlowGraphCubeRootBlock,
  FlowGraphPowBlock,
  FlowGraphLengthBlock,
  FlowGraphNormalizeBlock,
  FlowGraphCrossBlock,
  FlowGraphRotate2DBlock,
  FlowGraphRotate3DBlock,
  FlowGraphTransposeBlock,
  FlowGraphDeterminantBlock,
  FlowGraphInvertMatrixBlock,
  FlowGraphMatMulBlock,
  FlowGraphBitwiseNotBlock,
  FlowGraphBitwiseAndBlock,
  FlowGraphBitwiseOrBlock,
  FlowGraphBitwiseXorBlock,
  FlowGraphBitwiseLeftShiftBlock,
  FlowGraphBitwiseRightShiftBlock,
  FlowGraphCountLeadingZerosBlock,
  FlowGraphCountTrailingZerosBlock,
  FlowGraphCountOneBitsBlock,
  FlowGraphSceneReadyEventBlock,
  FlowGraphReceiveCustomEventBlock,
  FlowGraphSceneTickEventBlock
};
//# sourceMappingURL=chunk-CPUNWLL3.js.map
